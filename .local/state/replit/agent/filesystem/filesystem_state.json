{"file_contents":{"index.js":{"content":"","size_bytes":0},"README.md":{"content":"# üé∞ Litecoin Casino Discord Bot\n\nA complete, production-ready Discord bot for running a Litecoin-based casino with automatic deposit detection, balance management, withdrawal functionality, and real-time currency conversion.\n\n## ‚ú® Features\n\n### üéØ Core Casino Features\n- **Automatic Deposit Detection**: Real-time monitoring of Litecoin deposits (30-second intervals)\n- **Balance Management**: Complete user profile system with transaction history\n- **Secure Withdrawals**: Cryptographically secure transaction broadcasting\n- **Address Generation**: Unique Litecoin addresses for each user deposit\n\n### üí¨ Discord Integration\n- **Slash Commands**: Modern Discord slash command interface\n- **Interactive Panels**: Button-based casino interface\n- **Private Channels**: Auto-created private casino sessions\n- **Real-time Notifications**: Instant deposit confirmations via DM\n\n### üí± Currency Features\n- **EUR ‚áÑ USD Conversion**: Real-time exchange rates\n- **LTC Price Display**: Current Litecoin prices in USD/EUR\n- **Multi-currency Support**: Formatted currency displays\n\n### üéÆ Gaming Ready\n- **Modular Architecture**: Easy to add games (blackjack, roulette, slots)\n- **Balance Transfers**: Users can send LTC to each other\n- **Leaderboards**: Top players by balance\n- **Transaction History**: Complete audit trail\n\n## üöÄ Quick Start\n\n### 1. Environment Setup\n\n1. Copy the environment template:\n   ```bash\n   cp .env.example .env\n   ```\n\n2. Fill in your configuration:\n   ```env\n   DISCORD_TOKEN=your_discord_bot_token_here\n   DISCORD_CLIENT_ID=your_discord_application_id_here\n   ```\n\n### 2. Discord Bot Setup\n\n1. Go to [Discord Developer Portal](https://discord.com/developers/applications)\n2. Create a new application\n3. Go to \"Bot\" section and create a bot\n4. Copy the token to your `.env` file\n5. Go to \"General Information\" and copy the Application ID\n6. Enable required bot permissions:\n   - Send Messages\n   - Use Slash Commands\n   - Manage Channels\n   - Read Message History\n\n### 3. API Keys\n\n#### Plus d'API externe requise !\nLe bot utilise maintenant une connexion directe aux explorateurs Litecoin publics.\nAucune cl√© API n'est n√©cessaire pour les op√©rations blockchain.\n\n#### Alternative: Bitquery\n1. Sign up at [Bitquery](https://bitquery.io/)\n2. Get your API key\n3. Add to `.env` as `BITQUERY_API_KEY`\n\n### 4. Deploy Commands\n\n```bash\nnpm run deploy\n```\n\n### 5. Start the Bot\n\n```bash\nnpm start\n```\n\n## üìã Available Commands\n\n### User Commands\n- `/casino` - Open the main casino panel\n- `/profile` - View your casino profile and stats\n- `/balance [@user]` - Check balance (yours or another user's)\n- `/givebal @user amount` - Transfer LTC to another user\n- `/convert-eur-usd amount` - Convert EUR to USD\n- `/convert-usd-eur amount` - Convert USD to EUR\n\n### Interactive Features\n- **Add Balance Button**: Generates unique LTC deposit address\n- **Create Channel Button**: Creates private casino session\n- **Leaderboard**: View top players by balance\n\n## üèóÔ∏è Project Structure\n\n```\n‚îú‚îÄ‚îÄ commands/           # Slash commands\n‚îÇ   ‚îú‚îÄ‚îÄ casino.js      # Main casino panel\n‚îÇ   ‚îú‚îÄ‚îÄ profile.js     # User profile display\n‚îÇ   ‚îú‚îÄ‚îÄ balance.js     # Balance checking\n‚îÇ   ‚îú‚îÄ‚îÄ givebal.js     # Balance transfers\n‚îÇ   ‚îú‚îÄ‚îÄ convert-eur-usd.js\n‚îÇ   ‚îî‚îÄ‚îÄ convert-usd-eur.js\n‚îú‚îÄ‚îÄ events/            # Discord event handlers\n‚îÇ   ‚îú‚îÄ‚îÄ ready.js       # Bot startup & deposit monitoring\n‚îÇ   ‚îî‚îÄ‚îÄ interactionCreate.js\n‚îú‚îÄ‚îÄ utils/             # Utility modules\n‚îÇ   ‚îú‚îÄ‚îÄ userProfiles.js    # User data management\n‚îÇ   ‚îî‚îÄ‚îÄ currencyConverter.js\n‚îú‚îÄ‚îÄ data/              # JSON data storage\n‚îÇ   ‚îú‚îÄ‚îÄ user_profiles.json\n‚îÇ   ‚îî‚îÄ‚îÄ address_mapping.json\n‚îú‚îÄ‚îÄ discord-bot.js     # Main Discord bot file\n‚îú‚îÄ‚îÄ litecoin-casino-bot.js # Litecoin wallet system\n‚îú‚îÄ‚îÄ deploy-commands.js # Command deployment script\n‚îî‚îÄ‚îÄ addresses.json     # Generated LTC addresses\n```\n\n## üîß Core Systems\n\n### Litecoin Wallet System\n- **Address Generation**: Uses `litecore-lib` for secure key generation\n- **UTXO Management**: Automatic unspent output tracking\n- **Transaction Broadcasting**: Direct blockchain submission\n- **Balance Monitoring**: Real-time balance updates\n\n### User Profile System\n- **Persistent Storage**: JSON-based user data\n- **Transaction History**: Complete deposit/withdrawal logs\n- **Balance Tracking**: Real-time balance updates\n- **Address Linking**: Maps LTC addresses to Discord users\n\n### Deposit Detection\n- **Automatic Monitoring**: 30-second interval checks\n- **Real-time Notifications**: Instant Discord DMs\n- **Balance Updates**: Automatic profile updates\n- **Transaction Logging**: Complete audit trail\n\n## üéÆ Adding Casino Games\n\nThe bot is designed for easy game integration. Example blackjack implementation:\n\n```javascript\n// commands/blackjack.js\nconst { SlashCommandBuilder, EmbedBuilder } = require('discord.js');\nconst userProfiles = require('../utils/userProfiles.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('blackjack')\n        .setDescription('Play blackjack')\n        .addNumberOption(option =>\n            option.setName('bet')\n                .setDescription('Bet amount in LTC')\n                .setRequired(true)\n                .setMinValue(0.001)\n        ),\n    \n    async execute(interaction) {\n        // Game implementation here\n        // Deduct bet from user balance\n        // Play game logic\n        // Update balance based on result\n    }\n};\n```\n\n## üîí Security Features\n\n### Private Key Management\n- **Local Generation**: Keys never leave your server\n- **Secure Storage**: JSON file storage with proper permissions\n- **No Exposure**: Private keys never logged or transmitted\n\n### API Security\n- **Token Authentication**: All API calls authenticated\n- **Rate Limiting**: Respects API limits (3 req/sec BlockCypher)\n- **Error Handling**: Graceful degradation on API failures\n\n### Discord Security\n- **Permission Validation**: Proper permission checks\n- **Ephemeral Responses**: Sensitive data hidden from others\n- **DM Notifications**: Private transaction notifications\n\n## üìä Monitoring & Analytics\n\n### Real-time Statistics\n- **Active Users**: Track user engagement\n- **Transaction Volume**: Monitor LTC flow\n- **Deposit Success Rate**: API reliability metrics\n- **Game Performance**: Win/loss statistics (when games added)\n\n### Logging\n- **Comprehensive Logs**: All transactions logged\n- **Error Tracking**: Detailed error information\n- **Performance Metrics**: API response times\n\n## üîß Configuration Options\n\n### Environment Variables\n```env\n# Required\nDISCORD_TOKEN=              # Discord bot token\nDISCORD_CLIENT_ID=          # Discord application ID\nBLOCKCYPHER_TOKEN=          # BlockCypher API token\n\n# Optional\nDISCORD_GUILD_ID=           # For development commands\nBITQUERY_API_KEY=           # Alternative API\n```\n\n### Customization\n- **Check Intervals**: Modify deposit checking frequency\n- **Fee Rates**: Adjust transaction fees\n- **Currencies**: Add more currency pairs\n- **Permissions**: Customize channel permissions\n\n## üöÄ Deployment\n\n### Local Development\n```bash\nnpm install\nnpm run deploy\nnpm start\n```\n\n### Production Deployment\n1. Set up environment variables\n2. Deploy to your preferred hosting service\n3. Ensure persistent file storage for JSON data\n4. Set up monitoring and alerts\n\n### Replit Deployment\n1. Import this project to Replit\n2. Add secrets in the Secrets tab\n3. Run the bot using the Run button\n\n## ü§ù Contributing\n\n1. Fork the repository\n2. Create a feature branch\n3. Add your casino game or feature\n4. Test thoroughly\n5. Submit a pull request\n\n## üìù License\n\nThis project is licensed under the ISC License.\n\n## ‚ö†Ô∏è Disclaimer\n\nThis software is for educational and development purposes. Please ensure compliance with local gambling and cryptocurrency regulations before deploying in production.\n\n## üÜò Support\n\n- **Documentation**: Check this README for common issues\n- **Issues**: Report bugs on GitHub\n- **Discord**: Join our support server (link in bio)\n\n---\n\n**Built with ‚ù§Ô∏è for the crypto casino community**","size_bytes":8181},"SETUP.md":{"content":"# üöÄ Quick Setup Guide\n\n## 1. Get Your API Keys\n\n### Discord Bot Setup\n1. Go to https://discord.com/developers/applications\n2. Click \"New Application\" and give it a name\n3. Go to \"Bot\" section ‚Üí \"Add Bot\"\n4. Copy the **Token** (this is your `DISCORD_TOKEN`)\n5. Go back to \"General Information\" ‚Üí Copy the **Application ID** (this is your `DISCORD_CLIENT_ID`)\n6. Go to \"Bot\" ‚Üí Enable these permissions:\n   - Send Messages\n   - Use Slash Commands\n   - Manage Channels\n   - Read Message History\n\n### BlockCypher API (Free)\n1. Sign up at https://www.blockcypher.com/\n2. Get your free API token (allows 3 requests/second)\n3. This is your `BLOCKCYPHER_TOKEN`\n\n## 2. Configure Environment\n\nAdd these secrets in Replit:\n- `DISCORD_TOKEN` - Your Discord bot token\n- `DISCORD_CLIENT_ID` - Your Discord application ID\n- `BLOCKCYPHER_TOKEN` - Your BlockCypher API token\n\n## 3. Invite Bot to Server\n\nUse this URL (replace YOUR_CLIENT_ID):\n```\nhttps://discord.com/api/oauth2/authorize?client_id=YOUR_CLIENT_ID&permissions=268528640&scope=bot%20applications.commands\n```\n\n## 4. Deploy Commands\n\nRun this once to register slash commands:\n```bash\nnpm run deploy\n```\n\n## 5. Start the Bot\n\n```bash\nnpm start\n```\n\n## üéØ Quick Test\n\n1. In Discord, type `/casino` to open the main panel\n2. Click \"üí∞ Add Balance\" to generate a Litecoin address\n3. Send a small amount of LTC to test deposit detection\n4. Use `/profile` to view your balance\n\n## üîß Troubleshooting\n\n- **\"DISCORD_TOKEN is required\"**: Add your Discord token to secrets\n- **Commands not showing**: Run `npm run deploy` first\n- **No deposit detection**: Check if `BLOCKCYPHER_TOKEN` is set correctly\n- **Permission errors**: Make sure bot has required permissions in your server\n\n## üéÆ Ready Features\n\n### üîí Security System\n- ‚úÖ Password-protected accounts (`/setpassword`)\n- ‚úÖ Recovery key system (`/recoverykey`)\n- ‚úÖ Timed gambling sessions (`/enable`)\n- ‚úÖ 100% wagering requirement before cashout\n\n### üí∞ Financial System  \n- ‚úÖ Smart deposit monitoring (only when needed)\n- ‚úÖ Unique addresses for each deposit\n- ‚úÖ Secure password-protected withdrawals (`/cashout`)\n- ‚úÖ Balance management and transfers\n- ‚úÖ Currency conversion (EUR/USD)\n\n### üé∞ Casino Features\n- ‚úÖ User profiles and statistics\n- ‚úÖ Private channel creation\n- ‚úÖ Test gambling system (`/testgamble`)\n- üöß Games (blackjack, roulette) - Ready for implementation\n\n## üì± Example Usage\n\n### Initial Setup\n```\nUser: /setpassword mypassword123\nBot: ‚úÖ Password set! Recovery key: A1B2C3D4E5F6...\n\nUser: /casino\nBot: [Shows casino panel with Add Balance button]\n```\n\n### Adding Balance\n```\nUser: [Clicks Add Balance]\nBot: Send LTC to: LxxxxxxxxxxxxxxxxxxxxxxxxxxxX\n     [NEW unique address generated]\n\nUser: [Sends 0.01 LTC]\nBot: ‚úÖ Deposit confirmed! 0.01 LTC added\n     Note: Must wager 100% before cashout\n```\n\n### Gambling Session\n```\nUser: /enable 30 mypassword123\nBot: ‚úÖ Gambling session active for 30 minutes\n\nUser: /testgamble 0.005\nBot: üéâ You won! +0.009 LTC\n     Cashout progress: 50% complete\n```\n\n### Secure Cashout\n```\nUser: /cashout LxxxDestinationxxx 0.015 mypassword123\nBot: ‚úÖ Withdrawal successful! TXID: abc123...\n```\n\nYour casino bot is now ready! üé∞","size_bytes":3227},"attached_assets/casino/README.md":{"content":"# üé∞ Litecoin Casino Discord Bot\n\nA complete, production-ready Discord bot for running a Litecoin-based casino with automatic deposit detection, balance management, withdrawal functionality, and real-time currency conversion.\n\n## ‚ú® Features\n\n### üéØ Core Casino Features\n- **Automatic Deposit Detection**: Real-time monitoring of Litecoin deposits (30-second intervals)\n- **Balance Management**: Complete user profile system with transaction history\n- **Secure Withdrawals**: Cryptographically secure transaction broadcasting\n- **Address Generation**: Unique Litecoin addresses for each user deposit\n\n### üí¨ Discord Integration\n- **Slash Commands**: Modern Discord slash command interface\n- **Interactive Panels**: Button-based casino interface\n- **Private Channels**: Auto-created private casino sessions\n- **Real-time Notifications**: Instant deposit confirmations via DM\n\n### üí± Currency Features\n- **EUR ‚áÑ USD Conversion**: Real-time exchange rates\n- **LTC Price Display**: Current Litecoin prices in USD/EUR\n- **Multi-currency Support**: Formatted currency displays\n\n### üéÆ Gaming Ready\n- **Modular Architecture**: Easy to add games (blackjack, roulette, slots)\n- **Balance Transfers**: Users can send LTC to each other\n- **Leaderboards**: Top players by balance\n- **Transaction History**: Complete audit trail\n\n## üöÄ Quick Start\n\n### 1. Environment Setup\n\n1. Copy the environment template:\n   ```bash\n   cp .env.example .env\n   ```\n\n2. Fill in your configuration:\n   ```env\n   DISCORD_TOKEN=your_discord_bot_token_here\n   DISCORD_CLIENT_ID=your_discord_application_id_here\n   ```\n\n### 2. Discord Bot Setup\n\n1. Go to [Discord Developer Portal](https://discord.com/developers/applications)\n2. Create a new application\n3. Go to \"Bot\" section and create a bot\n4. Copy the token to your `.env` file\n5. Go to \"General Information\" and copy the Application ID\n6. Enable required bot permissions:\n   - Send Messages\n   - Use Slash Commands\n   - Manage Channels\n   - Read Message History\n\n### 3. API Keys\n\n#### Plus d'API externe requise !\nLe bot utilise maintenant une connexion directe aux explorateurs Litecoin publics.\nAucune cl√© API n'est n√©cessaire pour les op√©rations blockchain.\n\n#### Alternative: Bitquery\n1. Sign up at [Bitquery](https://bitquery.io/)\n2. Get your API key\n3. Add to `.env` as `BITQUERY_API_KEY`\n\n### 4. Deploy Commands\n\n```bash\nnpm run deploy\n```\n\n### 5. Start the Bot\n\n```bash\nnpm start\n```\n\n## üìã Available Commands\n\n### User Commands\n- `/casino` - Open the main casino panel\n- `/profile` - View your casino profile and stats\n- `/balance [@user]` - Check balance (yours or another user's)\n- `/givebal @user amount` - Transfer LTC to another user\n- `/convert-eur-usd amount` - Convert EUR to USD\n- `/convert-usd-eur amount` - Convert USD to EUR\n\n### Interactive Features\n- **Add Balance Button**: Generates unique LTC deposit address\n- **Create Channel Button**: Creates private casino session\n- **Leaderboard**: View top players by balance\n\n## üèóÔ∏è Project Structure\n\n```\n‚îú‚îÄ‚îÄ commands/           # Slash commands\n‚îÇ   ‚îú‚îÄ‚îÄ casino.js      # Main casino panel\n‚îÇ   ‚îú‚îÄ‚îÄ profile.js     # User profile display\n‚îÇ   ‚îú‚îÄ‚îÄ balance.js     # Balance checking\n‚îÇ   ‚îú‚îÄ‚îÄ givebal.js     # Balance transfers\n‚îÇ   ‚îú‚îÄ‚îÄ convert-eur-usd.js\n‚îÇ   ‚îî‚îÄ‚îÄ convert-usd-eur.js\n‚îú‚îÄ‚îÄ events/            # Discord event handlers\n‚îÇ   ‚îú‚îÄ‚îÄ ready.js       # Bot startup & deposit monitoring\n‚îÇ   ‚îî‚îÄ‚îÄ interactionCreate.js\n‚îú‚îÄ‚îÄ utils/             # Utility modules\n‚îÇ   ‚îú‚îÄ‚îÄ userProfiles.js    # User data management\n‚îÇ   ‚îî‚îÄ‚îÄ currencyConverter.js\n‚îú‚îÄ‚îÄ data/              # JSON data storage\n‚îÇ   ‚îú‚îÄ‚îÄ user_profiles.json\n‚îÇ   ‚îî‚îÄ‚îÄ address_mapping.json\n‚îú‚îÄ‚îÄ discord-bot.js     # Main Discord bot file\n‚îú‚îÄ‚îÄ litecoin-casino-bot.js # Litecoin wallet system\n‚îú‚îÄ‚îÄ deploy-commands.js # Command deployment script\n‚îî‚îÄ‚îÄ addresses.json     # Generated LTC addresses\n```\n\n## üîß Core Systems\n\n### Litecoin Wallet System\n- **Address Generation**: Uses `litecore-lib` for secure key generation\n- **UTXO Management**: Automatic unspent output tracking\n- **Transaction Broadcasting**: Direct blockchain submission\n- **Balance Monitoring**: Real-time balance updates\n\n### User Profile System\n- **Persistent Storage**: JSON-based user data\n- **Transaction History**: Complete deposit/withdrawal logs\n- **Balance Tracking**: Real-time balance updates\n- **Address Linking**: Maps LTC addresses to Discord users\n\n### Deposit Detection\n- **Automatic Monitoring**: 30-second interval checks\n- **Real-time Notifications**: Instant Discord DMs\n- **Balance Updates**: Automatic profile updates\n- **Transaction Logging**: Complete audit trail\n\n## üéÆ Adding Casino Games\n\nThe bot is designed for easy game integration. Example blackjack implementation:\n\n```javascript\n// commands/blackjack.js\nconst { SlashCommandBuilder, EmbedBuilder } = require('discord.js');\nconst userProfiles = require('../utils/userProfiles.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('blackjack')\n        .setDescription('Play blackjack')\n        .addNumberOption(option =>\n            option.setName('bet')\n                .setDescription('Bet amount in LTC')\n                .setRequired(true)\n                .setMinValue(0.001)\n        ),\n    \n    async execute(interaction) {\n        // Game implementation here\n        // Deduct bet from user balance\n        // Play game logic\n        // Update balance based on result\n    }\n};\n```\n\n## üîí Security Features\n\n### Private Key Management\n- **Local Generation**: Keys never leave your server\n- **Secure Storage**: JSON file storage with proper permissions\n- **No Exposure**: Private keys never logged or transmitted\n\n### API Security\n- **Token Authentication**: All API calls authenticated\n- **Rate Limiting**: Respects API limits (3 req/sec BlockCypher)\n- **Error Handling**: Graceful degradation on API failures\n\n### Discord Security\n- **Permission Validation**: Proper permission checks\n- **Ephemeral Responses**: Sensitive data hidden from others\n- **DM Notifications**: Private transaction notifications\n\n## üìä Monitoring & Analytics\n\n### Real-time Statistics\n- **Active Users**: Track user engagement\n- **Transaction Volume**: Monitor LTC flow\n- **Deposit Success Rate**: API reliability metrics\n- **Game Performance**: Win/loss statistics (when games added)\n\n### Logging\n- **Comprehensive Logs**: All transactions logged\n- **Error Tracking**: Detailed error information\n- **Performance Metrics**: API response times\n\n## üîß Configuration Options\n\n### Environment Variables\n```env\n# Required\nDISCORD_TOKEN=              # Discord bot token\nDISCORD_CLIENT_ID=          # Discord application ID\nBLOCKCYPHER_TOKEN=          # BlockCypher API token\n\n# Optional\nDISCORD_GUILD_ID=           # For development commands\nBITQUERY_API_KEY=           # Alternative API\n```\n\n### Customization\n- **Check Intervals**: Modify deposit checking frequency\n- **Fee Rates**: Adjust transaction fees\n- **Currencies**: Add more currency pairs\n- **Permissions**: Customize channel permissions\n\n## üöÄ Deployment\n\n### Local Development\n```bash\nnpm install\nnpm run deploy\nnpm start\n```\n\n### Production Deployment\n1. Set up environment variables\n2. Deploy to your preferred hosting service\n3. Ensure persistent file storage for JSON data\n4. Set up monitoring and alerts\n\n### Replit Deployment\n1. Import this project to Replit\n2. Add secrets in the Secrets tab\n3. Run the bot using the Run button\n\n## ü§ù Contributing\n\n1. Fork the repository\n2. Create a feature branch\n3. Add your casino game or feature\n4. Test thoroughly\n5. Submit a pull request\n\n## üìù License\n\nThis project is licensed under the ISC License.\n\n## ‚ö†Ô∏è Disclaimer\n\nThis software is for educational and development purposes. Please ensure compliance with local gambling and cryptocurrency regulations before deploying in production.\n\n## üÜò Support\n\n- **Documentation**: Check this README for common issues\n- **Issues**: Report bugs on GitHub\n- **Discord**: Join our support server (link in bio)\n\n---\n\n**Built with ‚ù§Ô∏è for the crypto casino community**","size_bytes":8181},"attached_assets/casino/SETUP.md":{"content":"# üöÄ Quick Setup Guide\n\n## 1. Get Your API Keys\n\n### Discord Bot Setup\n1. Go to https://discord.com/developers/applications\n2. Click \"New Application\" and give it a name\n3. Go to \"Bot\" section ‚Üí \"Add Bot\"\n4. Copy the **Token** (this is your `DISCORD_TOKEN`)\n5. Go back to \"General Information\" ‚Üí Copy the **Application ID** (this is your `DISCORD_CLIENT_ID`)\n6. Go to \"Bot\" ‚Üí Enable these permissions:\n   - Send Messages\n   - Use Slash Commands\n   - Manage Channels\n   - Read Message History\n\n### BlockCypher API (Free)\n1. Sign up at https://www.blockcypher.com/\n2. Get your free API token (allows 3 requests/second)\n3. This is your `BLOCKCYPHER_TOKEN`\n\n## 2. Configure Environment\n\nAdd these secrets in Replit:\n- `DISCORD_TOKEN` - Your Discord bot token\n- `DISCORD_CLIENT_ID` - Your Discord application ID\n- `BLOCKCYPHER_TOKEN` - Your BlockCypher API token\n\n## 3. Invite Bot to Server\n\nUse this URL (replace YOUR_CLIENT_ID):\n```\nhttps://discord.com/api/oauth2/authorize?client_id=YOUR_CLIENT_ID&permissions=268528640&scope=bot%20applications.commands\n```\n\n## 4. Deploy Commands\n\nRun this once to register slash commands:\n```bash\nnpm run deploy\n```\n\n## 5. Start the Bot\n\n```bash\nnpm start\n```\n\n## üéØ Quick Test\n\n1. In Discord, type `/casino` to open the main panel\n2. Click \"üí∞ Add Balance\" to generate a Litecoin address\n3. Send a small amount of LTC to test deposit detection\n4. Use `/profile` to view your balance\n\n## üîß Troubleshooting\n\n- **\"DISCORD_TOKEN is required\"**: Add your Discord token to secrets\n- **Commands not showing**: Run `npm run deploy` first\n- **No deposit detection**: Check if `BLOCKCYPHER_TOKEN` is set correctly\n- **Permission errors**: Make sure bot has required permissions in your server\n\n## üéÆ Ready Features\n\n### üîí Security System\n- ‚úÖ Password-protected accounts (`/setpassword`)\n- ‚úÖ Recovery key system (`/recoverykey`)\n- ‚úÖ Timed gambling sessions (`/enable`)\n- ‚úÖ 100% wagering requirement before cashout\n\n### üí∞ Financial System  \n- ‚úÖ Smart deposit monitoring (only when needed)\n- ‚úÖ Unique addresses for each deposit\n- ‚úÖ Secure password-protected withdrawals (`/cashout`)\n- ‚úÖ Balance management and transfers\n- ‚úÖ Currency conversion (EUR/USD)\n\n### üé∞ Casino Features\n- ‚úÖ User profiles and statistics\n- ‚úÖ Private channel creation\n- ‚úÖ Test gambling system (`/testgamble`)\n- üöß Games (blackjack, roulette) - Ready for implementation\n\n## üì± Example Usage\n\n### Initial Setup\n```\nUser: /setpassword mypassword123\nBot: ‚úÖ Password set! Recovery key: A1B2C3D4E5F6...\n\nUser: /casino\nBot: [Shows casino panel with Add Balance button]\n```\n\n### Adding Balance\n```\nUser: [Clicks Add Balance]\nBot: Send LTC to: LxxxxxxxxxxxxxxxxxxxxxxxxxxxX\n     [NEW unique address generated]\n\nUser: [Sends 0.01 LTC]\nBot: ‚úÖ Deposit confirmed! 0.01 LTC added\n     Note: Must wager 100% before cashout\n```\n\n### Gambling Session\n```\nUser: /enable 30 mypassword123\nBot: ‚úÖ Gambling session active for 30 minutes\n\nUser: /testgamble 0.005\nBot: üéâ You won! +0.009 LTC\n     Cashout progress: 50% complete\n```\n\n### Secure Cashout\n```\nUser: /cashout LxxxDestinationxxx 0.015 mypassword123\nBot: ‚úÖ Withdrawal successful! TXID: abc123...\n```\n\nYour casino bot is now ready! üé∞","size_bytes":3227},"attached_assets/casino/attached_assets/casino/README.md":{"content":"# üé∞ Litecoin Casino Discord Bot\n\nA complete, production-ready Discord bot for running a Litecoin-based casino with automatic deposit detection, balance management, withdrawal functionality, and real-time currency conversion.\n\n## ‚ú® Features\n\n### üéØ Core Casino Features\n- **Automatic Deposit Detection**: Real-time monitoring of Litecoin deposits (30-second intervals)\n- **Balance Management**: Complete user profile system with transaction history\n- **Secure Withdrawals**: Cryptographically secure transaction broadcasting\n- **Address Generation**: Unique Litecoin addresses for each user deposit\n\n### üí¨ Discord Integration\n- **Slash Commands**: Modern Discord slash command interface\n- **Interactive Panels**: Button-based casino interface\n- **Private Channels**: Auto-created private casino sessions\n- **Real-time Notifications**: Instant deposit confirmations via DM\n\n### üí± Currency Features\n- **EUR ‚áÑ USD Conversion**: Real-time exchange rates\n- **LTC Price Display**: Current Litecoin prices in USD/EUR\n- **Multi-currency Support**: Formatted currency displays\n\n### üéÆ Gaming Ready\n- **Modular Architecture**: Easy to add games (blackjack, roulette, slots)\n- **Balance Transfers**: Users can send LTC to each other\n- **Leaderboards**: Top players by balance\n- **Transaction History**: Complete audit trail\n\n## üöÄ Quick Start\n\n### 1. Environment Setup\n\n1. Copy the environment template:\n   ```bash\n   cp .env.example .env\n   ```\n\n2. Fill in your configuration:\n   ```env\n   DISCORD_TOKEN=your_discord_bot_token_here\n   DISCORD_CLIENT_ID=your_discord_application_id_here\n   ```\n\n### 2. Discord Bot Setup\n\n1. Go to [Discord Developer Portal](https://discord.com/developers/applications)\n2. Create a new application\n3. Go to \"Bot\" section and create a bot\n4. Copy the token to your `.env` file\n5. Go to \"General Information\" and copy the Application ID\n6. Enable required bot permissions:\n   - Send Messages\n   - Use Slash Commands\n   - Manage Channels\n   - Read Message History\n\n### 3. API Keys\n\n#### Plus d'API externe requise !\nLe bot utilise maintenant une connexion directe aux explorateurs Litecoin publics.\nAucune cl√© API n'est n√©cessaire pour les op√©rations blockchain.\n\n#### Alternative: Bitquery\n1. Sign up at [Bitquery](https://bitquery.io/)\n2. Get your API key\n3. Add to `.env` as `BITQUERY_API_KEY`\n\n### 4. Deploy Commands\n\n```bash\nnpm run deploy\n```\n\n### 5. Start the Bot\n\n```bash\nnpm start\n```\n\n## üìã Available Commands\n\n### User Commands\n- `/casino` - Open the main casino panel\n- `/profile` - View your casino profile and stats\n- `/balance [@user]` - Check balance (yours or another user's)\n- `/givebal @user amount` - Transfer LTC to another user\n- `/convert-eur-usd amount` - Convert EUR to USD\n- `/convert-usd-eur amount` - Convert USD to EUR\n\n### Interactive Features\n- **Add Balance Button**: Generates unique LTC deposit address\n- **Create Channel Button**: Creates private casino session\n- **Leaderboard**: View top players by balance\n\n## üèóÔ∏è Project Structure\n\n```\n‚îú‚îÄ‚îÄ commands/           # Slash commands\n‚îÇ   ‚îú‚îÄ‚îÄ casino.js      # Main casino panel\n‚îÇ   ‚îú‚îÄ‚îÄ profile.js     # User profile display\n‚îÇ   ‚îú‚îÄ‚îÄ balance.js     # Balance checking\n‚îÇ   ‚îú‚îÄ‚îÄ givebal.js     # Balance transfers\n‚îÇ   ‚îú‚îÄ‚îÄ convert-eur-usd.js\n‚îÇ   ‚îî‚îÄ‚îÄ convert-usd-eur.js\n‚îú‚îÄ‚îÄ events/            # Discord event handlers\n‚îÇ   ‚îú‚îÄ‚îÄ ready.js       # Bot startup & deposit monitoring\n‚îÇ   ‚îî‚îÄ‚îÄ interactionCreate.js\n‚îú‚îÄ‚îÄ utils/             # Utility modules\n‚îÇ   ‚îú‚îÄ‚îÄ userProfiles.js    # User data management\n‚îÇ   ‚îî‚îÄ‚îÄ currencyConverter.js\n‚îú‚îÄ‚îÄ data/              # JSON data storage\n‚îÇ   ‚îú‚îÄ‚îÄ user_profiles.json\n‚îÇ   ‚îî‚îÄ‚îÄ address_mapping.json\n‚îú‚îÄ‚îÄ discord-bot.js     # Main Discord bot file\n‚îú‚îÄ‚îÄ litecoin-casino-bot.js # Litecoin wallet system\n‚îú‚îÄ‚îÄ deploy-commands.js # Command deployment script\n‚îî‚îÄ‚îÄ addresses.json     # Generated LTC addresses\n```\n\n## üîß Core Systems\n\n### Litecoin Wallet System\n- **Address Generation**: Uses `litecore-lib` for secure key generation\n- **UTXO Management**: Automatic unspent output tracking\n- **Transaction Broadcasting**: Direct blockchain submission\n- **Balance Monitoring**: Real-time balance updates\n\n### User Profile System\n- **Persistent Storage**: JSON-based user data\n- **Transaction History**: Complete deposit/withdrawal logs\n- **Balance Tracking**: Real-time balance updates\n- **Address Linking**: Maps LTC addresses to Discord users\n\n### Deposit Detection\n- **Automatic Monitoring**: 30-second interval checks\n- **Real-time Notifications**: Instant Discord DMs\n- **Balance Updates**: Automatic profile updates\n- **Transaction Logging**: Complete audit trail\n\n## üéÆ Adding Casino Games\n\nThe bot is designed for easy game integration. Example blackjack implementation:\n\n```javascript\n// commands/blackjack.js\nconst { SlashCommandBuilder, EmbedBuilder } = require('discord.js');\nconst userProfiles = require('../utils/userProfiles.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('blackjack')\n        .setDescription('Play blackjack')\n        .addNumberOption(option =>\n            option.setName('bet')\n                .setDescription('Bet amount in LTC')\n                .setRequired(true)\n                .setMinValue(0.001)\n        ),\n    \n    async execute(interaction) {\n        // Game implementation here\n        // Deduct bet from user balance\n        // Play game logic\n        // Update balance based on result\n    }\n};\n```\n\n## üîí Security Features\n\n### Private Key Management\n- **Local Generation**: Keys never leave your server\n- **Secure Storage**: JSON file storage with proper permissions\n- **No Exposure**: Private keys never logged or transmitted\n\n### API Security\n- **Token Authentication**: All API calls authenticated\n- **Rate Limiting**: Respects API limits (3 req/sec BlockCypher)\n- **Error Handling**: Graceful degradation on API failures\n\n### Discord Security\n- **Permission Validation**: Proper permission checks\n- **Ephemeral Responses**: Sensitive data hidden from others\n- **DM Notifications**: Private transaction notifications\n\n## üìä Monitoring & Analytics\n\n### Real-time Statistics\n- **Active Users**: Track user engagement\n- **Transaction Volume**: Monitor LTC flow\n- **Deposit Success Rate**: API reliability metrics\n- **Game Performance**: Win/loss statistics (when games added)\n\n### Logging\n- **Comprehensive Logs**: All transactions logged\n- **Error Tracking**: Detailed error information\n- **Performance Metrics**: API response times\n\n## üîß Configuration Options\n\n### Environment Variables\n```env\n# Required\nDISCORD_TOKEN=              # Discord bot token\nDISCORD_CLIENT_ID=          # Discord application ID\nBLOCKCYPHER_TOKEN=          # BlockCypher API token\n\n# Optional\nDISCORD_GUILD_ID=           # For development commands\nBITQUERY_API_KEY=           # Alternative API\n```\n\n### Customization\n- **Check Intervals**: Modify deposit checking frequency\n- **Fee Rates**: Adjust transaction fees\n- **Currencies**: Add more currency pairs\n- **Permissions**: Customize channel permissions\n\n## üöÄ Deployment\n\n### Local Development\n```bash\nnpm install\nnpm run deploy\nnpm start\n```\n\n### Production Deployment\n1. Set up environment variables\n2. Deploy to your preferred hosting service\n3. Ensure persistent file storage for JSON data\n4. Set up monitoring and alerts\n\n### Replit Deployment\n1. Import this project to Replit\n2. Add secrets in the Secrets tab\n3. Run the bot using the Run button\n\n## ü§ù Contributing\n\n1. Fork the repository\n2. Create a feature branch\n3. Add your casino game or feature\n4. Test thoroughly\n5. Submit a pull request\n\n## üìù License\n\nThis project is licensed under the ISC License.\n\n## ‚ö†Ô∏è Disclaimer\n\nThis software is for educational and development purposes. Please ensure compliance with local gambling and cryptocurrency regulations before deploying in production.\n\n## üÜò Support\n\n- **Documentation**: Check this README for common issues\n- **Issues**: Report bugs on GitHub\n- **Discord**: Join our support server (link in bio)\n\n---\n\n**Built with ‚ù§Ô∏è for the crypto casino community**","size_bytes":8181},"attached_assets/casino/attached_assets/casino/SETUP.md":{"content":"# üöÄ Quick Setup Guide\n\n## 1. Get Your API Keys\n\n### Discord Bot Setup\n1. Go to https://discord.com/developers/applications\n2. Click \"New Application\" and give it a name\n3. Go to \"Bot\" section ‚Üí \"Add Bot\"\n4. Copy the **Token** (this is your `DISCORD_TOKEN`)\n5. Go back to \"General Information\" ‚Üí Copy the **Application ID** (this is your `DISCORD_CLIENT_ID`)\n6. Go to \"Bot\" ‚Üí Enable these permissions:\n   - Send Messages\n   - Use Slash Commands\n   - Manage Channels\n   - Read Message History\n\n### BlockCypher API (Free)\n1. Sign up at https://www.blockcypher.com/\n2. Get your free API token (allows 3 requests/second)\n3. This is your `BLOCKCYPHER_TOKEN`\n\n## 2. Configure Environment\n\nAdd these secrets in Replit:\n- `DISCORD_TOKEN` - Your Discord bot token\n- `DISCORD_CLIENT_ID` - Your Discord application ID\n- `BLOCKCYPHER_TOKEN` - Your BlockCypher API token\n\n## 3. Invite Bot to Server\n\nUse this URL (replace YOUR_CLIENT_ID):\n```\nhttps://discord.com/api/oauth2/authorize?client_id=YOUR_CLIENT_ID&permissions=268528640&scope=bot%20applications.commands\n```\n\n## 4. Deploy Commands\n\nRun this once to register slash commands:\n```bash\nnpm run deploy\n```\n\n## 5. Start the Bot\n\n```bash\nnpm start\n```\n\n## üéØ Quick Test\n\n1. In Discord, type `/casino` to open the main panel\n2. Click \"üí∞ Add Balance\" to generate a Litecoin address\n3. Send a small amount of LTC to test deposit detection\n4. Use `/profile` to view your balance\n\n## üîß Troubleshooting\n\n- **\"DISCORD_TOKEN is required\"**: Add your Discord token to secrets\n- **Commands not showing**: Run `npm run deploy` first\n- **No deposit detection**: Check if `BLOCKCYPHER_TOKEN` is set correctly\n- **Permission errors**: Make sure bot has required permissions in your server\n\n## üéÆ Ready Features\n\n### üîí Security System\n- ‚úÖ Password-protected accounts (`/setpassword`)\n- ‚úÖ Recovery key system (`/recoverykey`)\n- ‚úÖ Timed gambling sessions (`/enable`)\n- ‚úÖ 100% wagering requirement before cashout\n\n### üí∞ Financial System  \n- ‚úÖ Smart deposit monitoring (only when needed)\n- ‚úÖ Unique addresses for each deposit\n- ‚úÖ Secure password-protected withdrawals (`/cashout`)\n- ‚úÖ Balance management and transfers\n- ‚úÖ Currency conversion (EUR/USD)\n\n### üé∞ Casino Features\n- ‚úÖ User profiles and statistics\n- ‚úÖ Private channel creation\n- ‚úÖ Test gambling system (`/testgamble`)\n- üöß Games (blackjack, roulette) - Ready for implementation\n\n## üì± Example Usage\n\n### Initial Setup\n```\nUser: /setpassword mypassword123\nBot: ‚úÖ Password set! Recovery key: A1B2C3D4E5F6...\n\nUser: /casino\nBot: [Shows casino panel with Add Balance button]\n```\n\n### Adding Balance\n```\nUser: [Clicks Add Balance]\nBot: Send LTC to: LxxxxxxxxxxxxxxxxxxxxxxxxxxxX\n     [NEW unique address generated]\n\nUser: [Sends 0.01 LTC]\nBot: ‚úÖ Deposit confirmed! 0.01 LTC added\n     Note: Must wager 100% before cashout\n```\n\n### Gambling Session\n```\nUser: /enable 30 mypassword123\nBot: ‚úÖ Gambling session active for 30 minutes\n\nUser: /testgamble 0.005\nBot: üéâ You won! +0.009 LTC\n     Cashout progress: 50% complete\n```\n\n### Secure Cashout\n```\nUser: /cashout LxxxDestinationxxx 0.015 mypassword123\nBot: ‚úÖ Withdrawal successful! TXID: abc123...\n```\n\nYour casino bot is now ready! üé∞","size_bytes":3227},"attached_assets/casino/attached_assets/casino/commands/addwhitelist.js":{"content":"const { SlashCommandBuilder, EmbedBuilder, PermissionFlagsBits } = require('discord.js');\nconst panelManager = require('../utils/panelManager.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('addwhitelist')\n        .setDescription('Add this server to panel management whitelist (Bot Owner only)')\n        .addRoleOption(option =>\n            option.setName('admin_role')\n                .setDescription('Role that can manage panels (optional)')\n                .setRequired(false)\n        ),\n    \n    async execute(interaction) {\n        // Check if interaction is too old\n        const interactionAge = Date.now() - interaction.createdTimestamp;\n        if (interactionAge > 10 * 60 * 1000) {\n            console.log('Interaction trop ancienne, ignor√©e');\n            return;\n        }\n        \n        // Check if user is bot owner (you can change this logic)\n        const botOwnerIds = ['1409315903937449994']; // Add your user ID here\n        \n        if (!botOwnerIds.includes(interaction.user.id)) {\n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Access Denied')\n                .setDescription('Only the bot owner can manage the whitelist.')\n                .setTimestamp();\n            \n            await interaction.reply({ embeds: [errorEmbed], ephemeral: true });\n            return;\n        }\n        \n        await interaction.deferReply({ ephemeral: true });\n        \n        try {\n            const adminRole = interaction.options.getRole('admin_role');\n            const serverId = interaction.guild.id;\n            \n            // Add to whitelist\n            const success = panelManager.addToWhitelist(serverId, adminRole?.id);\n            \n            if (success) {\n                const successEmbed = new EmbedBuilder()\n                    .setColor('#00ff00')\n                    .setTitle('‚úÖ Server Whitelisted')\n                    .setDescription(`Server **${interaction.guild.name}** has been added to the whitelist.`)\n                    .addFields(\n                        {\n                            name: 'üèõÔ∏è Server',\n                            value: interaction.guild.name,\n                            inline: true\n                        },\n                        {\n                            name: 'üëë Admin Role',\n                            value: adminRole ? adminRole.name : 'None (all members can manage)',\n                            inline: true\n                        },\n                        {\n                            name: 'üìã Available Commands',\n                            value: '‚Ä¢ `/setpanel` - Configure casino panels\\n‚Ä¢ `/stopallactives` - Stop active deposits',\n                            inline: false\n                        }\n                    )\n                    .setFooter({ text: `Server ID: ${serverId}` })\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [successEmbed] });\n                \n                console.log(`‚úÖ Serveur ${interaction.guild.name} ajout√© √† la whitelist par ${interaction.user.username}`);\n                \n            } else {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Whitelist Failed')\n                    .setDescription('Failed to add server to whitelist.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n            }\n            \n        } catch (error) {\n            console.error('Erreur addwhitelist:', error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Error')\n                .setDescription('An error occurred while adding server to whitelist.')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};","size_bytes":4028},"attached_assets/casino/attached_assets/casino/commands/balance.js":{"content":"const { SlashCommandBuilder, EmbedBuilder } = require('discord.js');\nconst userProfiles = require('../utils/userProfiles.js');\nconst currencyConverter = require('../utils/currencyConverter.js');\nconst { formatLTC, formatUSD } = require('../utils/formatters.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('balance')\n        .setDescription('Check your current balance')\n        .addUserOption(option =>\n            option.setName('user')\n                .setDescription('User to check balance for (optional)')\n                .setRequired(false)\n        ),\n    \n    async execute(interaction) {\n        // Check if interaction is too old\n        const interactionAge = Date.now() - interaction.createdTimestamp;\n        if (interactionAge > 10 * 60 * 1000) {\n            console.log('Interaction trop ancienne, ignor√©e');\n            return;\n        }\n        \n        await interaction.deferReply();\n        \n        try {\n            const targetUser = interaction.options.getUser('user') || interaction.user;\n            const profile = userProfiles.getUserProfile(targetUser.id);\n            \n            // Get LTC price for USD conversion\n            let ltcPrice = null;\n            let eurPrice = null;\n            \n            try {\n                const [usdData, eurData] = await Promise.all([\n                    currencyConverter.getLitecoinPrice('USD'),\n                    currencyConverter.getLitecoinPrice('EUR')\n                ]);\n                ltcPrice = usdData.price;\n                eurPrice = eurData.price;\n            } catch (error) {\n                console.log('Could not fetch crypto prices:', error.message);\n            }\n            \n            const balanceEmbed = new EmbedBuilder()\n                .setColor('#f7931a')\n                .setTitle('üí∞ Balance Information')\n                .setAuthor({ \n                    name: targetUser.username, \n                    iconURL: targetUser.displayAvatarURL() \n                })\n                .addFields({\n                    name: 'ü™ô Litecoin Balance',\n                    value: `**${formatLTC(profile.balance)} LTC**`,\n                    inline: false\n                })\n                .setThumbnail('https://cryptologos.cc/logos/litecoin-ltc-logo.png')\n                .setTimestamp();\n            \n            // Add USD and EUR conversions if available\n            if (ltcPrice && eurPrice) {\n                const usdValue = profile.balance * ltcPrice;\n                const eurValue = profile.balance * eurPrice;\n                \n                balanceEmbed.addFields(\n                    {\n                        name: 'üíµ USD Equivalent',\n                        value: `$${formatUSD(usdValue)}`,\n                        inline: true\n                    },\n                    {\n                        name: 'üí∂ EUR Equivalent',\n                        value: `‚Ç¨${formatUSD(eurValue)}`,\n                        inline: true\n                    }\n                );\n            }\n            \n            // Add quick stats\n            if (profile.depositHistory.length > 0 || profile.withdrawalHistory.length > 0) {\n                balanceEmbed.addFields({\n                    name: 'üìä Quick Stats',\n                    value: `**Total Deposited:** ${formatLTC(profile.totalDeposited)} LTC\\n**Total Withdrawn:** ${formatLTC(profile.totalWithdrawn)} LTC\\n**Net Gain/Loss:** ${formatLTC(profile.totalDeposited - profile.totalWithdrawn - profile.balance)} LTC`,\n                    inline: false\n                });\n            }\n            \n            // Check if viewing someone else's balance\n            if (targetUser.id !== interaction.user.id) {\n                balanceEmbed.setFooter({ text: `Balance requested by ${interaction.user.username}` });\n            }\n            \n            await interaction.editReply({ embeds: [balanceEmbed] });\n            \n        } catch (error) {\n            console.error('Balance command error:', error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Error')\n                .setDescription('Failed to fetch balance information. Please try again.')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};","size_bytes":4361},"attached_assets/casino/attached_assets/casino/commands/blackjack.js":{"content":"const { SlashCommandBuilder, EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle } = require('discord.js');\nconst userProfiles = require('../utils/userProfiles.js');\nconst securityManager = require('../utils/securityManager.js');\nconst logManager = require('../utils/logManager.js');\nconst { formatLTC } = require('../utils/formatters.js');\n\n// Card deck\nconst suits = ['‚ô†Ô∏è', '‚ô•Ô∏è', '‚ô¶Ô∏è', '‚ô£Ô∏è'];\nconst ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];\n\n// Active games storage\nconst activeGames = new Map();\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('blackjack')\n        .setDescription('Play Blackjack against the dealer')\n        .addNumberOption(option =>\n            option.setName('bet')\n                .setDescription('Amount to bet in LTC')\n                .setRequired(true)\n                .setMinValue(0.001)\n        ),\n    \n    async execute(interaction) {\n        // Check if interaction is too old\n        const interactionAge = Date.now() - interaction.createdTimestamp;\n        if (interactionAge > 10 * 60 * 1000) {\n            console.log('Interaction trop ancienne, ignor√©e');\n            return;\n        }\n        \n        await interaction.deferReply({ ephemeral: false });\n        \n        try {\n            const bet = interaction.options.getNumber('bet');\n            const userId = interaction.user.id;\n            \n            // Check if user has active game\n            if (activeGames.has(userId)) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Game Already Active')\n                    .setDescription('You already have an active blackjack game. Finish it first!')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Get user profile and verify balance\n            const profile = userProfiles.getUserProfile(userId);\n            \n            if (profile.balance < bet) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Insufficient Balance')\n                    .setDescription(`You need **${formatLTC(bet)} LTC** to play but only have **${formatLTC(profile.balance)} LTC**.`)\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Check password protection\n            const userSec = securityManager.getUserSecurity(userId);\n            if (!userSec.hasPassword) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ffaa00')\n                    .setTitle('üîí Password Required')\n                    .setDescription('You need to set a password before gambling. Use `/setpassword` first.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Deduct bet from balance\n            userProfiles.updateUserProfile(userId, { \n                balance: profile.balance - bet \n            });\n            \n            // Add wagered amount\n            securityManager.addWageredAmount(userId, bet);\n            \n            // Create new game\n            const game = createNewGame(bet, userId);\n            activeGames.set(userId, game);\n            \n            // Deal initial cards\n            dealInitialCards(game);\n            \n            // Create game embed\n            const gameEmbed = createGameEmbed(game, interaction.user);\n            const gameButtons = createGameButtons(game);\n            \n            await interaction.editReply({ \n                embeds: [gameEmbed],\n                components: [gameButtons]\n            });\n            \n            // Auto-timeout after 2 minutes\n            setTimeout(() => {\n                if (activeGames.has(userId)) {\n                    const timeoutGame = activeGames.get(userId);\n                    if (timeoutGame.status === 'playing') {\n                        timeoutGame.status = 'timeout';\n                        activeGames.delete(userId);\n                        console.log(`üïê Blackjack game timed out for ${interaction.user.username}`);\n                    }\n                }\n            }, 120000); // 2 minutes\n            \n        } catch (error) {\n            console.error('Erreur blackjack:', error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Error')\n                .setDescription('An error occurred while starting the blackjack game.')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};\n\nfunction createNewGame(bet, userId) {\n    return {\n        userId: userId,\n        bet: bet,\n        deck: createDeck(),\n        playerHand: [],\n        dealerHand: [],\n        playerValue: 0,\n        dealerValue: 0,\n        status: 'playing', // playing, won, lost, push, timeout\n        canDoubleDown: true,\n        startTime: Date.now()\n    };\n}\n\nfunction createDeck() {\n    const deck = [];\n    for (const suit of suits) {\n        for (const rank of ranks) {\n            deck.push({ suit, rank });\n        }\n    }\n    return shuffleDeck(deck);\n}\n\nfunction shuffleDeck(deck) {\n    for (let i = deck.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        [deck[i], deck[j]] = [deck[j], deck[i]];\n    }\n    return deck;\n}\n\nfunction dealCard(game) {\n    return game.deck.pop();\n}\n\nfunction dealInitialCards(game) {\n    // Deal 2 cards to player and dealer\n    game.playerHand.push(dealCard(game));\n    game.dealerHand.push(dealCard(game));\n    game.playerHand.push(dealCard(game));\n    game.dealerHand.push(dealCard(game));\n    \n    game.playerValue = calculateHandValue(game.playerHand);\n    game.dealerValue = calculateHandValue(game.dealerHand);\n    \n    // Check for natural blackjack\n    if (game.playerValue === 21) {\n        if (game.dealerValue === 21) {\n            game.status = 'push'; // Tie\n        } else {\n            game.status = 'blackjack'; // Player blackjack\n        }\n    }\n}\n\nfunction calculateHandValue(hand) {\n    let value = 0;\n    let aces = 0;\n    \n    for (const card of hand) {\n        if (card.rank === 'A') {\n            aces++;\n            value += 11;\n        } else if (['J', 'Q', 'K'].includes(card.rank)) {\n            value += 10;\n        } else {\n            value += parseInt(card.rank);\n        }\n    }\n    \n    // Handle aces\n    while (value > 21 && aces > 0) {\n        value -= 10;\n        aces--;\n    }\n    \n    return value;\n}\n\nfunction formatHand(hand, hideFirst = false) {\n    return hand.map((card, index) => {\n        if (hideFirst && index === 0) {\n            return 'üÉè';\n        }\n        return `${card.rank}${card.suit}`;\n    }).join(' ');\n}\n\nfunction createGameEmbed(game, user) {\n    const playerHandStr = formatHand(game.playerHand);\n    const dealerHandStr = formatHand(game.dealerHand, game.status === 'playing');\n    \n    let title = 'üÉè Blackjack Game';\n    let color = '#f7931a';\n    let description = `Bet: **${formatLTC(game.bet)} LTC**`;\n    \n    if (game.status === 'won') {\n        title = 'üéâ You Win!';\n        color = '#00ff00';\n        description = `You won **${formatLTC(game.bet * 2)} LTC**!`;\n    } else if (game.status === 'lost') {\n        title = 'üí∏ You Lost';\n        color = '#ff0000';\n        description = `You lost **${formatLTC(game.bet)} LTC**`;\n    } else if (game.status === 'push') {\n        title = 'ü§ù Push (Tie)';\n        color = '#ffaa00';\n        description = `Your bet of **${formatLTC(game.bet)} LTC** has been returned`;\n    } else if (game.status === 'blackjack') {\n        title = 'üéØ BLACKJACK!';\n        color = '#ffd700';\n        description = `You won **${formatLTC(game.bet * 2.5)} LTC** with Blackjack!`;\n    }\n    \n    const embed = new EmbedBuilder()\n        .setColor(color)\n        .setTitle(title)\n        .setDescription(description)\n        .addFields(\n            {\n                name: `üë§ ${user.username}'s Hand (${game.playerValue})`,\n                value: playerHandStr,\n                inline: false\n            },\n            {\n                name: `üé∞ Dealer's Hand ${game.status === 'playing' ? '(?)' : `(${game.dealerValue})`}`,\n                value: dealerHandStr,\n                inline: false\n            }\n        )\n        .setFooter({ text: 'Good luck!' })\n        .setTimestamp();\n    \n    if (game.status !== 'playing') {\n        const profile = userProfiles.getUserProfile(game.userId);\n        embed.addFields({\n            name: 'üí∞ New Balance',\n            value: `${formatLTC(profile.balance)} LTC`,\n            inline: true\n        });\n    }\n    \n    return embed;\n}\n\nfunction createGameButtons(game) {\n    const row = new ActionRowBuilder();\n    \n    if (game.status === 'playing') {\n        row.addComponents(\n            new ButtonBuilder()\n                .setCustomId('blackjack_hit')\n                .setLabel('Hit')\n                .setStyle(ButtonStyle.Primary)\n                .setEmoji('üéØ'),\n            new ButtonBuilder()\n                .setCustomId('blackjack_stand')\n                .setLabel('Stand')\n                .setStyle(ButtonStyle.Secondary)\n                .setEmoji('‚úã')\n        );\n        \n        if (game.canDoubleDown && game.playerHand.length === 2) {\n            const profile = userProfiles.getUserProfile(game.userId);\n            if (profile.balance >= game.bet) {\n                row.addComponents(\n                    new ButtonBuilder()\n                        .setCustomId('blackjack_double')\n                        .setLabel('Double Down')\n                        .setStyle(ButtonStyle.Success)\n                        .setEmoji('üí∞')\n                );\n            }\n        }\n    }\n    \n    return row;\n}\n\n// Export game functions for button handlers\nmodule.exports.activeGames = activeGames;\nmodule.exports.calculateHandValue = calculateHandValue;\nmodule.exports.dealCard = dealCard;\nmodule.exports.createGameEmbed = createGameEmbed;\nmodule.exports.createGameButtons = createGameButtons;\nmodule.exports.formatHand = formatHand;","size_bytes":10444},"attached_assets/casino/attached_assets/casino/commands/cashout.js":{"content":"const { SlashCommandBuilder, EmbedBuilder } = require('discord.js');\nconst securityManager = require('../utils/securityManager.js');\nconst userProfiles = require('../utils/userProfiles.js');\nconst ltcWallet = require('../litecoin-casino-bot.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('cashout')\n        .setDescription('Withdraw your LTC balance (requires password and 100% wagering)')\n        .addStringOption(option =>\n            option.setName('address')\n                .setDescription('Your LTC address to withdraw to')\n                .setRequired(true)\n        )\n        .addNumberOption(option =>\n            option.setName('amount')\n                .setDescription('Amount to withdraw in LTC')\n                .setRequired(true)\n                .setMinValue(0.001)\n        )\n        .addStringOption(option =>\n            option.setName('password')\n                .setDescription('Your account password')\n                .setRequired(true)\n        ),\n    \n    async execute(interaction) {\n        await interaction.deferReply({ ephemeral: true });\n        \n        try {\n            const toAddress = interaction.options.getString('address');\n            const amount = interaction.options.getNumber('amount');\n            const password = interaction.options.getString('password');\n            const userId = interaction.user.id;\n            \n            // Check if user has a password set\n            const userSec = securityManager.getUserSecurity(userId);\n            if (!userSec.hasPassword) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå No Password Set')\n                    .setDescription('You need to set a password first using `/setpassword` to cashout.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Verify password\n            if (!securityManager.verifyUserPassword(userId, password)) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Wrong Password')\n                    .setDescription('The password you entered is incorrect.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Check cashout eligibility (100% wagering requirement)\n            const cashoutStatus = securityManager.canUserCashout(userId);\n            \n            if (!cashoutStatus.canCashout) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Cashout Not Allowed')\n                    .setDescription('You must wager at least 100% of your deposited amount before cashing out.')\n                    .addFields(\n                        {\n                            name: 'üìä Wagering Status',\n                            value: `**Deposited:** ${cashoutStatus.depositedAmount.toFixed(8)} LTC\\n**Wagered:** ${cashoutStatus.wageredAmount.toFixed(8)} LTC\\n**Progress:** ${cashoutStatus.wageredPercent.toFixed(1)}%`,\n                            inline: true\n                        },\n                        {\n                            name: 'üéØ Remaining to Wager',\n                            value: `${cashoutStatus.remainingToWager.toFixed(8)} LTC`,\n                            inline: true\n                        },\n                        {\n                            name: 'üí° How to Unlock Cashout',\n                            value: 'Play casino games to increase your wagered amount to 100% of deposits.',\n                            inline: false\n                        }\n                    )\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Check user balance\n            const profile = userProfiles.getUserProfile(userId);\n            \n            if (profile.balance < amount) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Insufficient Balance')\n                    .setDescription(`You don't have enough balance to withdraw.`)\n                    .addFields({\n                        name: 'üí∞ Available Balance',\n                        value: `${profile.balance.toFixed(8)} LTC`,\n                        inline: true\n                    })\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Find a source address with sufficient balance\n            const addresses = ltcWallet.loadAddresses();\n            let fromAddress = null;\n            \n            for (const addr of addresses) {\n                if (addr.balance >= amount) {\n                    fromAddress = addr.address;\n                    break;\n                }\n            }\n            \n            if (!fromAddress) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå No Suitable Address')\n                    .setDescription('No address found with sufficient balance for withdrawal.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Process withdrawal\n            const processingEmbed = new EmbedBuilder()\n                .setColor('#ffaa00')\n                .setTitle('‚è≥ Processing Withdrawal')\n                .setDescription('Your withdrawal is being processed...')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [processingEmbed] });\n            \n            // Execute withdrawal\n            const txid = await ltcWallet.withdraw(fromAddress, toAddress, amount);\n            \n            if (!txid) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Withdrawal Failed')\n                    .setDescription('Failed to process withdrawal. Please try again or contact support.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Update user profile\n            userProfiles.addWithdrawal(userId, amount, toAddress, txid);\n            \n            const successEmbed = new EmbedBuilder()\n                .setColor('#00ff00')\n                .setTitle('‚úÖ Withdrawal Successful')\n                .setDescription('Your withdrawal has been processed and broadcasted to the Litecoin network.')\n                .addFields(\n                    {\n                        name: 'üí∞ Amount',\n                        value: `${amount.toFixed(8)} LTC`,\n                        inline: true\n                    },\n                    {\n                        name: 'üìç Destination',\n                        value: `\\`${toAddress}\\``,\n                        inline: false\n                    },\n                    {\n                        name: 'üîó Transaction ID',\n                        value: `\\`${txid}\\``,\n                        inline: false\n                    },\n                    {\n                        name: '‚è∞ Status',\n                        value: 'Transaction broadcasted - confirmations pending',\n                        inline: false\n                    }\n                )\n                .setThumbnail('https://cryptologos.cc/logos/litecoin-ltc-logo.png')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [successEmbed] });\n            \n            console.log(`üí∏ Processed withdrawal: ${amount} LTC for user ${interaction.user.username} - TXID: ${txid}`);\n            \n        } catch (error) {\n            console.error('Cashout error:', error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Cashout Error')\n                .setDescription('An error occurred while processing your withdrawal. Please try again.')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};","size_bytes":8639},"attached_assets/casino/attached_assets/casino/commands/casino.js":{"content":"const { SlashCommandBuilder, EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle } = require('discord.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('casino')\n        .setDescription('Open the casino main panel'),\n    \n    async execute(interaction) {\n        // Check if interaction is too old\n        const interactionAge = Date.now() - interaction.createdTimestamp;\n        if (interactionAge > 10 * 60 * 1000) {\n            console.log('Interaction trop ancienne, ignor√©e');\n            return;\n        }\n        \n        try {\n            const casinoEmbed = new EmbedBuilder()\n                .setColor('#f7931a')\n                .setTitle('üé∞ Litecoin Casino')\n                .setDescription('Welcome to the Litecoin Casino! Choose an option below to get started.')\n                .addFields(\n                    {\n                        name: 'üí∞ Add Balance',\n                        value: 'Generate a unique Litecoin address to deposit funds',\n                        inline: true\n                    },\n                    {\n                        name: 'üéÆ Games Available',\n                        value: 'Blackjack, Roulette - Start playing now!',\n                        inline: true\n                    },\n                    {\n                        name: 'üìä Profile',\n                        value: 'View your balance and transaction history',\n                        inline: true\n                    }\n                )\n                .setThumbnail('https://cryptologos.cc/logos/litecoin-ltc-logo.png')\n                .setImage('https://i.imgur.com/9KpZK8h.png') // Casino banner (optional)\n                .setFooter({ text: 'Secure ‚Ä¢ Fast ‚Ä¢ Transparent' })\n                .setTimestamp();\n            \n            const actionRow = new ActionRowBuilder()\n                .addComponents(\n                    new ButtonBuilder()\n                        .setCustomId('add_balance')\n                        .setLabel('üí∞ Add Balance')\n                        .setStyle(ButtonStyle.Success)\n                        .setEmoji('üí∞'),\n                    new ButtonBuilder()\n                        .setCustomId('view_profile')\n                        .setLabel('üë§ Profile')\n                        .setStyle(ButtonStyle.Primary)\n                        .setEmoji('üë§'),\n                    new ButtonBuilder()\n                        .setCustomId('leaderboard')\n                        .setLabel('üèÜ Leaderboard')\n                        .setStyle(ButtonStyle.Secondary)\n                        .setEmoji('üèÜ')\n                );\n            \n            // Games row (now functional!)\n            const gamesRow = new ActionRowBuilder()\n                .addComponents(\n                    new ButtonBuilder()\n                        .setCustomId('casino_blackjack')\n                        .setLabel('üÉè Blackjack')\n                        .setStyle(ButtonStyle.Primary)\n                        .setEmoji('üÉè'),\n                    new ButtonBuilder()\n                        .setCustomId('casino_roulette')\n                        .setLabel('üé∞ Roulette')\n                        .setStyle(ButtonStyle.Primary)\n                        .setEmoji('üé∞'),\n                    new ButtonBuilder()\n                        .setCustomId('casino_slots')\n                        .setLabel('üé≤ Slots')\n                        .setStyle(ButtonStyle.Secondary)\n                        .setEmoji('üé≤')\n                        .setDisabled(true) // Coming soon\n                );\n            \n            await interaction.reply({ \n                embeds: [casinoEmbed], \n                components: [actionRow, gamesRow]\n            });\n            \n        } catch (error) {\n            console.error('Casino command error:', error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Error')\n                .setDescription('Failed to load casino panel. Please try again.')\n                .setTimestamp();\n            \n            try {\n                if (interaction.replied || interaction.deferred) {\n                    await interaction.followUp({ embeds: [errorEmbed], ephemeral: true });\n                } else {\n                    await interaction.reply({ embeds: [errorEmbed], ephemeral: true });\n                }\n            } catch (replyError) {\n                console.error('Impossible de r√©pondre √† l\\'erreur casino:', replyError.message);\n            }\n        }\n    }\n};","size_bytes":4564},"attached_assets/casino/attached_assets/casino/commands/changepassword.js":{"content":"const { SlashCommandBuilder, EmbedBuilder } = require('discord.js');\nconst securityManager = require('../utils/securityManager.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('changepassword')\n        .setDescription('Change your account password')\n        .addStringOption(option =>\n            option.setName('oldpassword')\n                .setDescription('Your current password')\n                .setRequired(true)\n        )\n        .addStringOption(option =>\n            option.setName('newpassword')\n                .setDescription('Your new password (minimum 6 characters)')\n                .setRequired(true)\n        ),\n    \n    async execute(interaction) {\n        await interaction.deferReply({ ephemeral: true });\n        \n        try {\n            const oldPassword = interaction.options.getString('oldpassword');\n            const newPassword = interaction.options.getString('newpassword');\n            \n            // Validate new password\n            if (newPassword.length < 6) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Invalid Password')\n                    .setDescription('New password must be at least 6 characters long.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Check if user has a password set\n            const userSec = securityManager.getUserSecurity(interaction.user.id);\n            if (!userSec.hasPassword) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå No Password Set')\n                    .setDescription('You need to set a password first using `/setpassword`.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Try to change password\n            const success = securityManager.changeUserPassword(interaction.user.id, oldPassword, newPassword);\n            \n            if (!success) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Wrong Password')\n                    .setDescription('Your current password is incorrect.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            const successEmbed = new EmbedBuilder()\n                .setColor('#00ff00')\n                .setTitle('‚úÖ Password Changed')\n                .setDescription('Your password has been successfully changed.')\n                .addFields({\n                    name: 'üîí Security',\n                    value: 'Your recovery key remains the same and is still valid.',\n                    inline: false\n                })\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [successEmbed] });\n            \n        } catch (error) {\n            console.error('Change password error:', error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Error')\n                .setDescription('Failed to change password. Please try again.')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};","size_bytes":3608},"attached_assets/casino/attached_assets/casino/commands/convert-eur-usd.js":{"content":"const { SlashCommandBuilder, EmbedBuilder } = require('discord.js');\nconst currencyConverter = require('../utils/currencyConverter.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('convert-eur-usd')\n        .setDescription('Convert EUR to USD')\n        .addNumberOption(option =>\n            option.setName('amount')\n                .setDescription('Amount in EUR to convert')\n                .setRequired(true)\n                .setMinValue(0.01)\n        ),\n    \n    async execute(interaction) {\n        await interaction.deferReply();\n        \n        try {\n            const amount = interaction.options.getNumber('amount');\n            \n            // Perform currency conversion\n            const conversion = await currencyConverter.convertCurrency(amount, 'EUR', 'USD');\n            \n            const conversionEmbed = new EmbedBuilder()\n                .setColor('#4CAF50')\n                .setTitle('üí± Currency Conversion')\n                .setDescription('**EUR ‚Üí USD**')\n                .addFields(\n                    {\n                        name: 'üá™üá∫ Euro Amount',\n                        value: `‚Ç¨${conversion.originalAmount.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`,\n                        inline: true\n                    },\n                    {\n                        name: 'üá∫üá∏ US Dollar Equivalent',\n                        value: `$${conversion.convertedAmount.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`,\n                        inline: true\n                    },\n                    {\n                        name: 'üìä Exchange Rate',\n                        value: `1 EUR = $${conversion.exchangeRate.toFixed(4)} USD`,\n                        inline: false\n                    }\n                )\n                .setFooter({ \n                    text: 'Exchange rates are updated in real-time' \n                })\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [conversionEmbed] });\n            \n        } catch (error) {\n            console.error('EUR to USD conversion error:', error);\n            \n            let errorMessage = 'Failed to convert currency. Please try again later.';\n            \n            if (error.message.includes('Amount must be greater than 0')) {\n                errorMessage = 'Please enter a valid amount greater than 0.';\n            } else if (error.message.includes('Failed to fetch exchange rate')) {\n                errorMessage = 'Currency conversion service is temporarily unavailable.';\n            }\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Conversion Failed')\n                .setDescription(errorMessage)\n                .addFields({\n                    name: 'üí° Tip',\n                    value: 'Exchange rates are fetched from external APIs. Please try again in a few moments.',\n                    inline: false\n                })\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};","size_bytes":3206},"attached_assets/casino/attached_assets/casino/commands/convert-usd-eur.js":{"content":"const { SlashCommandBuilder, EmbedBuilder } = require('discord.js');\nconst currencyConverter = require('../utils/currencyConverter.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('convert-usd-eur')\n        .setDescription('Convert USD to EUR')\n        .addNumberOption(option =>\n            option.setName('amount')\n                .setDescription('Amount in USD to convert')\n                .setRequired(true)\n                .setMinValue(0.01)\n        ),\n    \n    async execute(interaction) {\n        await interaction.deferReply();\n        \n        try {\n            const amount = interaction.options.getNumber('amount');\n            \n            // Perform currency conversion\n            const conversion = await currencyConverter.convertCurrency(amount, 'USD', 'EUR');\n            \n            const conversionEmbed = new EmbedBuilder()\n                .setColor('#4CAF50')\n                .setTitle('üí± Currency Conversion')\n                .setDescription('**USD ‚Üí EUR**')\n                .addFields(\n                    {\n                        name: 'üá∫üá∏ US Dollar Amount',\n                        value: `$${conversion.originalAmount.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`,\n                        inline: true\n                    },\n                    {\n                        name: 'üá™üá∫ Euro Equivalent',\n                        value: `‚Ç¨${conversion.convertedAmount.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`,\n                        inline: true\n                    },\n                    {\n                        name: 'üìä Exchange Rate',\n                        value: `1 USD = ‚Ç¨${conversion.exchangeRate.toFixed(4)} EUR`,\n                        inline: false\n                    }\n                )\n                .setFooter({ \n                    text: 'Exchange rates are updated in real-time' \n                })\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [conversionEmbed] });\n            \n        } catch (error) {\n            console.error('USD to EUR conversion error:', error);\n            \n            let errorMessage = 'Failed to convert currency. Please try again later.';\n            \n            if (error.message.includes('Amount must be greater than 0')) {\n                errorMessage = 'Please enter a valid amount greater than 0.';\n            } else if (error.message.includes('Failed to fetch exchange rate')) {\n                errorMessage = 'Currency conversion service is temporarily unavailable.';\n            }\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Conversion Failed')\n                .setDescription(errorMessage)\n                .addFields({\n                    name: 'üí° Tip',\n                    value: 'Exchange rates are fetched from external APIs. Please try again in a few moments.',\n                    inline: false\n                })\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};","size_bytes":3208},"attached_assets/casino/attached_assets/casino/commands/enable.js":{"content":"const { SlashCommandBuilder, EmbedBuilder } = require('discord.js');\nconst securityManager = require('../utils/securityManager.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('enable')\n        .setDescription('Enable gambling session with time limit (requires password)')\n        .addIntegerOption(option =>\n            option.setName('minutes')\n                .setDescription('Session duration in minutes (1-60)')\n                .setRequired(true)\n                .setMinValue(1)\n                .setMaxValue(60)\n        )\n        .addStringOption(option =>\n            option.setName('password')\n                .setDescription('Your account password')\n                .setRequired(true)\n        ),\n    \n    async execute(interaction) {\n        await interaction.deferReply({ ephemeral: true });\n        \n        try {\n            const minutes = interaction.options.getInteger('minutes');\n            const password = interaction.options.getString('password');\n            \n            // Check if user has a password set\n            const userSec = securityManager.getUserSecurity(interaction.user.id);\n            if (!userSec.hasPassword) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå No Password Set')\n                    .setDescription('You need to set a password first using `/setpassword` to enable gambling sessions.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Verify password\n            if (!securityManager.verifyUserPassword(interaction.user.id, password)) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Wrong Password')\n                    .setDescription('The password you entered is incorrect.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Check if user already has an active session\n            if (securityManager.hasActiveGamblingSession(interaction.user.id)) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ffaa00')\n                    .setTitle('‚ö†Ô∏è Session Already Active')\n                    .setDescription('You already have an active gambling session. Wait for it to expire before starting a new one.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Start gambling session\n            const endTime = securityManager.startGamblingSession(interaction.user.id, minutes);\n            \n            const successEmbed = new EmbedBuilder()\n                .setColor('#00ff00')\n                .setTitle('üé∞ Gambling Session Enabled')\n                .setDescription(`Your gambling session is now active for **${minutes} minute${minutes > 1 ? 's' : ''}**.`)\n                .addFields(\n                    {\n                        name: '‚è∞ Session Details',\n                        value: `**Started:** <t:${Math.floor(Date.now()/1000)}:T>\\n**Ends:** <t:${Math.floor(endTime.getTime()/1000)}:T>\\n**Duration:** ${minutes} minute${minutes > 1 ? 's' : ''}`,\n                        inline: false\n                    },\n                    {\n                        name: 'üéÆ What you can do now',\n                        value: '‚Ä¢ Play casino games\\n‚Ä¢ Place bets\\n‚Ä¢ Use gambling features\\n‚Ä¢ All protected by your session',\n                        inline: true\n                    },\n                    {\n                        name: 'üîí Security',\n                        value: '‚Ä¢ Session auto-expires\\n‚Ä¢ Password protected\\n‚Ä¢ Secure gambling environment',\n                        inline: true\n                    }\n                )\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [successEmbed] });\n            \n        } catch (error) {\n            console.error('Enable gambling session error:', error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Error')\n                .setDescription('Failed to enable gambling session. Please try again.')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};","size_bytes":4646},"attached_assets/casino/attached_assets/casino/commands/givebal.js":{"content":"const { SlashCommandBuilder, EmbedBuilder } = require('discord.js');\nconst userProfiles = require('../utils/userProfiles.js');\nconst { formatLTC } = require('../utils/formatters.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('givebal')\n        .setDescription('Transfer balance to another user')\n        .addUserOption(option =>\n            option.setName('user')\n                .setDescription('User to transfer balance to')\n                .setRequired(true)\n        )\n        .addNumberOption(option =>\n            option.setName('amount')\n                .setDescription('Amount to transfer (in LTC)')\n                .setRequired(true)\n                .setMinValue(0.00000001)\n        ),\n    \n    async execute(interaction) {\n        await interaction.deferReply();\n        \n        try {\n            const targetUser = interaction.options.getUser('user');\n            const amount = interaction.options.getNumber('amount');\n            const fromUserId = interaction.user.id;\n            const toUserId = targetUser.id;\n            \n            // Validation checks\n            if (fromUserId === toUserId) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Invalid Transfer')\n                    .setDescription('You cannot transfer balance to yourself!')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            if (amount <= 0) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Invalid Amount')\n                    .setDescription('Amount must be greater than 0!')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Check sender's balance\n            const senderProfile = userProfiles.getUserProfile(fromUserId);\n            \n            if (senderProfile.balance < amount) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Insufficient Balance')\n                    .setDescription(`You don't have enough balance!\\n\\n**Your Balance:** ${formatLTC(senderProfile.balance)} LTC\\n**Required:** ${formatLTC(amount)} LTC`)\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Perform the transfer\n            const transfer = userProfiles.transferBalance(fromUserId, toUserId, amount);\n            \n            // Get updated profiles\n            const updatedSenderProfile = userProfiles.getUserProfile(fromUserId);\n            const updatedReceiverProfile = userProfiles.getUserProfile(toUserId);\n            \n            const successEmbed = new EmbedBuilder()\n                .setColor('#00ff00')\n                .setTitle('‚úÖ Transfer Successful')\n                .setDescription(`Successfully transferred **${formatLTC(amount)} LTC** to ${targetUser}`)\n                .addFields(\n                    {\n                        name: 'üë§ From',\n                        value: `${interaction.user}\\n**New Balance:** ${formatLTC(updatedSenderProfile.balance)} LTC`,\n                        inline: true\n                    },\n                    {\n                        name: 'üë§ To',\n                        value: `${targetUser}\\n**New Balance:** ${formatLTC(updatedReceiverProfile.balance)} LTC`,\n                        inline: true\n                    },\n                    {\n                        name: 'üìã Transaction Details',\n                        value: `**Amount:** ${formatLTC(amount)} LTC\\n**Date:** ${new Date(transfer.timestamp).toLocaleString()}\\n**ID:** ${transfer.timestamp}`,\n                        inline: false\n                    }\n                )\n                .setThumbnail('https://cryptologos.cc/logos/litecoin-ltc-logo.png')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [successEmbed] });\n            \n            // Try to notify the receiver (if they share a server)\n            try {\n                const receiverDM = await targetUser.createDM();\n                \n                const notificationEmbed = new EmbedBuilder()\n                    .setColor('#00ff00')\n                    .setTitle('üí∞ Balance Received')\n                    .setDescription(`You received **${amount.toFixed(8)} LTC** from ${interaction.user.username}!`)\n                    .addFields({\n                        name: 'üí≥ Your New Balance',\n                        value: `${updatedReceiverProfile.balance.toFixed(8)} LTC`,\n                        inline: true\n                    })\n                    .setThumbnail('https://cryptologos.cc/logos/litecoin-ltc-logo.png')\n                    .setTimestamp();\n                \n                await receiverDM.send({ embeds: [notificationEmbed] });\n            } catch (dmError) {\n                console.log('Could not send DM notification:', dmError.message);\n                // This is not critical, so we don't show error to user\n            }\n            \n        } catch (error) {\n            console.error('Transfer command error:', error);\n            \n            let errorMessage = 'Failed to process transfer. Please try again.';\n            \n            if (error.message === 'Insufficient balance') {\n                errorMessage = 'Insufficient balance for this transfer.';\n            }\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Transfer Failed')\n                .setDescription(errorMessage)\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};","size_bytes":6057},"attached_assets/casino/attached_assets/casino/commands/profile.js":{"content":"const { SlashCommandBuilder, EmbedBuilder } = require('discord.js');\nconst userProfiles = require('../utils/userProfiles.js');\nconst currencyConverter = require('../utils/currencyConverter.js');\nconst { formatLTC, formatUSD } = require('../utils/formatters.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('profile')\n        .setDescription('View your casino profile and balance'),\n    \n    async execute(interaction) {\n        // Check if interaction is too old (Discord timeout is 15 minutes)\n        const interactionAge = Date.now() - interaction.createdTimestamp;\n        if (interactionAge > 10 * 60 * 1000) { // 10 minutes safety margin\n            console.log('Interaction trop ancienne, ignor√©e');\n            return;\n        }\n        \n        await interaction.deferReply();\n        \n        try {\n            const profile = userProfiles.getUserProfile(interaction.user.id);\n            \n            // Get recent deposit and withdrawal\n            const recentDeposit = profile.depositHistory.slice(-1)[0];\n            const recentWithdrawal = profile.withdrawalHistory.slice(-1)[0];\n            \n            // Try to get LTC price for reference\n            let ltcPrice = null;\n            try {\n                const priceData = await currencyConverter.getLitecoinPrice('USD');\n                ltcPrice = priceData.price;\n            } catch (error) {\n                console.log('Could not fetch LTC price:', error.message);\n            }\n            \n            const profileEmbed = new EmbedBuilder()\n                .setColor('#f7931a')\n                .setTitle('üé∞ Casino Profile')\n                .setAuthor({ \n                    name: interaction.user.username, \n                    iconURL: interaction.user.displayAvatarURL() \n                })\n                .addFields(\n                    { \n                        name: 'üí∞ Current Balance', \n                        value: `**${formatLTC(profile.balance)} LTC**${ltcPrice ? `\\n‚âà $${formatUSD(profile.balance * ltcPrice)} USD` : ''}`, \n                        inline: true \n                    },\n                    { \n                        name: 'üìä Statistics', \n                        value: `**Deposited:** ${formatLTC(profile.totalDeposited)} LTC\\n**Withdrawn:** ${formatLTC(profile.totalWithdrawn)} LTC\\n**Net:** ${formatLTC(profile.totalDeposited - profile.totalWithdrawn)} LTC`, \n                        inline: true \n                    },\n                    { \n                        name: 'üéÆ Activity', \n                        value: `**Deposits:** ${profile.depositHistory.length}\\n**Withdrawals:** ${profile.withdrawalHistory.length}\\n**Games Played:** ${profile.gameHistory.length}`, \n                        inline: true \n                    }\n                )\n                .setThumbnail('https://cryptologos.cc/logos/litecoin-ltc-logo.png')\n                .setFooter({ \n                    text: `Member since ${new Date(profile.createdAt).toLocaleDateString()}` \n                })\n                .setTimestamp();\n            \n            // Add recent activity if available\n            if (recentDeposit || recentWithdrawal) {\n                let recentActivity = '';\n                \n                if (recentDeposit) {\n                    const depositDate = new Date(recentDeposit.timestamp).toLocaleDateString();\n                    recentActivity += `üì• **Last Deposit:** ${formatLTC(recentDeposit.amount)} LTC (${depositDate})\\n`;\n                }\n                \n                if (recentWithdrawal) {\n                    const withdrawalDate = new Date(recentWithdrawal.timestamp).toLocaleDateString();\n                    recentActivity += `üì§ **Last Withdrawal:** ${formatLTC(recentWithdrawal.amount)} LTC (${withdrawalDate})`;\n                }\n                \n                profileEmbed.addFields({\n                    name: 'üìà Recent Activity',\n                    value: recentActivity,\n                    inline: false\n                });\n            }\n            \n            // Add addresses count if any\n            if (profile.addresses.length > 0) {\n                profileEmbed.addFields({\n                    name: 'üìç Linked Addresses',\n                    value: `${profile.addresses.length} Litecoin address(es)`,\n                    inline: true\n                });\n            }\n            \n            await interaction.editReply({ embeds: [profileEmbed] });\n            \n        } catch (error) {\n            console.error('Profile command error:', error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Error')\n                .setDescription('Failed to load your profile. Please try again.')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};","size_bytes":4915},"attached_assets/casino/attached_assets/casino/commands/recoverykey.js":{"content":"const { SlashCommandBuilder, EmbedBuilder } = require('discord.js');\nconst securityManager = require('../utils/securityManager.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('recoverykey')\n        .setDescription('View your recovery key (requires password)')\n        .addStringOption(option =>\n            option.setName('password')\n                .setDescription('Your account password')\n                .setRequired(true)\n        ),\n    \n    async execute(interaction) {\n        await interaction.deferReply({ ephemeral: true });\n        \n        try {\n            const password = interaction.options.getString('password');\n            \n            // Check if user has a password set\n            const userSec = securityManager.getUserSecurity(interaction.user.id);\n            if (!userSec.hasPassword) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå No Password Set')\n                    .setDescription('You need to set a password first using `/setpassword`.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Verify password\n            if (!securityManager.verifyUserPassword(interaction.user.id, password)) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Wrong Password')\n                    .setDescription('The password you entered is incorrect.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            const recoveryKeyEmbed = new EmbedBuilder()\n                .setColor('#f7931a')\n                .setTitle('üîë Your Recovery Key')\n                .setDescription('**Keep this key safe!** You need it to recover your account.')\n                .addFields(\n                    {\n                        name: 'üîê Recovery Key',\n                        value: `\\`${userSec.recoveryKey}\\``,\n                        inline: false\n                    },\n                    {\n                        name: '‚ö†Ô∏è Security Warning',\n                        value: 'Never share this key with anyone. Store it in a secure location offline.',\n                        inline: false\n                    },\n                    {\n                        name: 'üîÑ Reset Key',\n                        value: 'Use `/resetrecovery` if you want to generate a new recovery key.',\n                        inline: false\n                    }\n                )\n                .setFooter({ text: 'This message will delete automatically for security' })\n                .setTimestamp();\n            \n            const message = await interaction.editReply({ embeds: [recoveryKeyEmbed] });\n            \n            // Auto-delete the message after 30 seconds for security\n            setTimeout(async () => {\n                try {\n                    await message.delete();\n                } catch (error) {\n                    console.log('Could not delete recovery key message:', error.message);\n                }\n            }, 30000);\n            \n        } catch (error) {\n            console.error('Recovery key error:', error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Error')\n                .setDescription('Failed to retrieve recovery key. Please try again.')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};","size_bytes":3766},"attached_assets/casino/attached_assets/casino/commands/resetpassworduser.js":{"content":"const { SlashCommandBuilder, EmbedBuilder } = require('discord.js');\nconst userProfiles = require('../utils/userProfiles.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('resetpassworduser')\n        .setDescription('Reset password for any user (Bot Owner only)')\n        .addUserOption(option =>\n            option.setName('user')\n                .setDescription('User whose password to reset')\n                .setRequired(true)\n        ),\n    \n    async execute(interaction) {\n        // Check if interaction is too old\n        const interactionAge = Date.now() - interaction.createdTimestamp;\n        if (interactionAge > 10 * 60 * 1000) {\n            console.log('Interaction trop ancienne, ignor√©e');\n            return;\n        }\n        \n        // Check if user is bot owner\n        const ownerId = process.env.OWNER_ID;\n        \n        if (!ownerId || interaction.user.id !== ownerId) {\n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Access Denied')\n                .setDescription('Only the bot owner can reset user passwords.')\n                .setTimestamp();\n            \n            await interaction.reply({ embeds: [errorEmbed], ephemeral: true });\n            return;\n        }\n        \n        await interaction.deferReply({ ephemeral: true });\n        \n        try {\n            const targetUser = interaction.options.getUser('user');\n            \n            // Check if user has a profile\n            const profile = userProfiles.getUserProfile(targetUser.id);\n            if (!profile) {\n                const noProfileEmbed = new EmbedBuilder()\n                    .setColor('#ffaa00')\n                    .setTitle('‚ö†Ô∏è User Not Found')\n                    .setDescription(`User ${targetUser.username} doesn't have a casino profile yet.`)\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [noProfileEmbed] });\n                return;\n            }\n            \n            // Reset password and recovery key\n            const resetResult = userProfiles.resetUserSecurity(targetUser.id);\n            \n            if (resetResult.success) {\n                const successEmbed = new EmbedBuilder()\n                    .setColor('#00ff00')\n                    .setTitle('‚úÖ Password Reset Complete')\n                    .setDescription(`Successfully reset security settings for ${targetUser.username}`)\n                    .addFields(\n                        {\n                            name: 'üë§ Target User',\n                            value: `${targetUser.username} (${targetUser.id})`,\n                            inline: false\n                        },\n                        {\n                            name: 'üîê Actions Taken',\n                            value: '‚Ä¢ Password cleared\\n‚Ä¢ Recovery key regenerated\\n‚Ä¢ User can now set new password with `/setpassword`',\n                            inline: false\n                        },\n                        {\n                            name: 'üîë New Recovery Key',\n                            value: `\\`${resetResult.newRecoveryKey}\\``,\n                            inline: false\n                        }\n                    )\n                    .setFooter({ text: 'Owner command executed' })\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [successEmbed] });\n                \n                console.log(`üîê Owner ${interaction.user.username} reset password for user ${targetUser.username} (${targetUser.id})`);\n                \n                // Try to notify the user via DM (optional)\n                try {\n                    const dmEmbed = new EmbedBuilder()\n                        .setColor('#0099ff')\n                        .setTitle('üîê Password Reset by Admin')\n                        .setDescription('Your casino password has been reset by an administrator.')\n                        .addFields(\n                            {\n                                name: 'üìù What to do next',\n                                value: '‚Ä¢ Use `/setpassword` to set a new password\\n‚Ä¢ Your balance and profile are safe',\n                                inline: false\n                            },\n                            {\n                                name: 'üîë Your New Recovery Key',\n                                value: `\\`${resetResult.newRecoveryKey}\\`\\n*Save this somewhere safe!*`,\n                                inline: false\n                            }\n                        )\n                        .setTimestamp();\n                    \n                    await targetUser.send({ embeds: [dmEmbed] });\n                    console.log(`üì© Notification DM envoy√©e √† ${targetUser.username}`);\n                } catch (dmError) {\n                    console.log(`‚ö†Ô∏è Impossible d'envoyer DM √† ${targetUser.username}: ${dmError.message}`);\n                }\n                \n            } else {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Reset Failed')\n                    .setDescription('Failed to reset user password. Please try again.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n            }\n            \n        } catch (error) {\n            console.error('Erreur resetpassworduser:', error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Error')\n                .setDescription('An error occurred while resetting the password.')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};","size_bytes":5893},"attached_assets/casino/attached_assets/casino/commands/resetrecovery.js":{"content":"const { SlashCommandBuilder, EmbedBuilder } = require('discord.js');\nconst securityManager = require('../utils/securityManager.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('resetrecovery')\n        .setDescription('Reset your recovery key (requires old key + password)')\n        .addStringOption(option =>\n            option.setName('oldkey')\n                .setDescription('Your current recovery key')\n                .setRequired(true)\n        )\n        .addStringOption(option =>\n            option.setName('password')\n                .setDescription('Your account password')\n                .setRequired(true)\n        ),\n    \n    async execute(interaction) {\n        await interaction.deferReply({ ephemeral: true });\n        \n        try {\n            const oldKey = interaction.options.getString('oldkey');\n            const password = interaction.options.getString('password');\n            \n            // Check if user has a password set\n            const userSec = securityManager.getUserSecurity(interaction.user.id);\n            if (!userSec.hasPassword) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå No Password Set')\n                    .setDescription('You need to set a password first using `/setpassword`.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Try to reset recovery key\n            const newRecoveryKey = securityManager.resetRecoveryKey(interaction.user.id, oldKey, password);\n            \n            if (!newRecoveryKey) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Reset Failed')\n                    .setDescription('Invalid recovery key or password. Both must be correct to reset.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            const successEmbed = new EmbedBuilder()\n                .setColor('#00ff00')\n                .setTitle('üîÑ Recovery Key Reset')\n                .setDescription('Your recovery key has been successfully reset.')\n                .addFields(\n                    {\n                        name: 'üîë New Recovery Key',\n                        value: `\\`${newRecoveryKey}\\``,\n                        inline: false\n                    },\n                    {\n                        name: '‚ö†Ô∏è IMPORTANT',\n                        value: '**Save this new recovery key immediately!** Your old key is no longer valid.',\n                        inline: false\n                    },\n                    {\n                        name: 'üîí Security',\n                        value: 'Store your new recovery key in a safe place. You will need it to recover your account.',\n                        inline: false\n                    }\n                )\n                .setFooter({ text: 'This message will delete automatically for security' })\n                .setTimestamp();\n            \n            const message = await interaction.editReply({ embeds: [successEmbed] });\n            \n            // Auto-delete the message after 45 seconds for security\n            setTimeout(async () => {\n                try {\n                    await message.delete();\n                } catch (error) {\n                    console.log('Could not delete reset recovery message:', error.message);\n                }\n            }, 45000);\n            \n        } catch (error) {\n            console.error('Reset recovery error:', error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Error')\n                .setDescription('Failed to reset recovery key. Please try again.')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};","size_bytes":4126},"attached_assets/casino/attached_assets/casino/commands/roulette.js":{"content":"const { SlashCommandBuilder, EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle, StringSelectMenuBuilder } = require('discord.js');\nconst userProfiles = require('../utils/userProfiles.js');\nconst securityManager = require('../utils/securityManager.js');\nconst logManager = require('../utils/logManager.js');\nconst { formatLTC } = require('../utils/formatters.js');\n\n// Roulette wheel numbers and colors\nconst wheel = {\n    0: 'green',\n    1: 'red', 2: 'black', 3: 'red', 4: 'black', 5: 'red', 6: 'black',\n    7: 'red', 8: 'black', 9: 'red', 10: 'black', 11: 'black', 12: 'red',\n    13: 'black', 14: 'red', 15: 'black', 16: 'red', 17: 'black', 18: 'red',\n    19: 'red', 20: 'black', 21: 'red', 22: 'black', 23: 'red', 24: 'black',\n    25: 'red', 26: 'black', 27: 'red', 28: 'black', 29: 'black', 30: 'red',\n    31: 'black', 32: 'red', 33: 'black', 34: 'red', 35: 'black', 36: 'red'\n};\n\n// Active spins storage\nconst activeSpins = new Map();\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('roulette')\n        .setDescription('Play Roulette - place your bets!')\n        .addNumberOption(option =>\n            option.setName('bet')\n                .setDescription('Amount to bet in LTC')\n                .setRequired(true)\n                .setMinValue(0.001)\n        ),\n    \n    async execute(interaction) {\n        // Check if interaction is too old\n        const interactionAge = Date.now() - interaction.createdTimestamp;\n        if (interactionAge > 10 * 60 * 1000) {\n            console.log('Interaction trop ancienne, ignor√©e');\n            return;\n        }\n        \n        await interaction.deferReply({ ephemeral: false });\n        \n        try {\n            const bet = interaction.options.getNumber('bet');\n            const userId = interaction.user.id;\n            \n            // Check if user has active spin\n            if (activeSpins.has(userId)) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Spin Already Active')\n                    .setDescription('You already have an active roulette spin. Wait for it to finish!')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Get user profile and verify balance\n            const profile = userProfiles.getUserProfile(userId);\n            \n            if (profile.balance < bet) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Insufficient Balance')\n                    .setDescription(`You need **${formatLTC(bet)} LTC** to play but only have **${formatLTC(profile.balance)} LTC**.`)\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Check password protection\n            const userSec = securityManager.getUserSecurity(userId);\n            if (!userSec.hasPassword) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ffaa00')\n                    .setTitle('üîí Password Required')\n                    .setDescription('You need to set a password before gambling. Use `/setpassword` first.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Create new spin\n            const spin = {\n                userId: userId,\n                bet: bet,\n                bets: new Map(),\n                status: 'betting',\n                result: null,\n                totalPayout: 0,\n                startTime: Date.now()\n            };\n            \n            activeSpins.set(userId, spin);\n            \n            // Show betting interface\n            const bettingEmbed = createBettingEmbed(spin, interaction.user);\n            const bettingComponents = createBettingComponents();\n            \n            await interaction.editReply({ \n                embeds: [bettingEmbed],\n                components: bettingComponents\n            });\n            \n            // Auto-timeout after 2 minutes\n            setTimeout(() => {\n                if (activeSpins.has(userId)) {\n                    const timeoutSpin = activeSpins.get(userId);\n                    if (timeoutSpin.status === 'betting') {\n                        timeoutSpin.status = 'timeout';\n                        activeSpins.delete(userId);\n                        console.log(`üïê Roulette spin timed out for ${interaction.user.username}`);\n                    }\n                }\n            }, 120000);\n            \n        } catch (error) {\n            console.error('Erreur roulette:', error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Error')\n                .setDescription('An error occurred while starting the roulette game.')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};\n\nfunction createBettingEmbed(spin, user) {\n    const embed = new EmbedBuilder()\n        .setColor('#9932cc')\n        .setTitle('üé∞ Roulette - Place Your Bets!')\n        .setDescription(`**Available to bet:** ${formatLTC(spin.bet)} LTC`)\n        .addFields(\n            {\n                name: 'üéØ How to Play',\n                value: '‚Ä¢ Choose your betting options below\\n‚Ä¢ Numbers pay 35:1\\n‚Ä¢ Colors (Red/Black) pay 1:1\\n‚Ä¢ Even/Odd pay 1:1\\n‚Ä¢ High/Low pay 1:1',\n                inline: false\n            },\n            {\n                name: 'üí∞ Current Bets',\n                value: spin.bets.size > 0 ? formatBets(spin.bets) : 'No bets placed yet',\n                inline: false\n            }\n        )\n        .setFooter({ text: 'Select your bets below, then click Spin!' })\n        .setTimestamp();\n    \n    return embed;\n}\n\nfunction createBettingComponents() {\n    const colorRow = new ActionRowBuilder()\n        .addComponents(\n            new ButtonBuilder()\n                .setCustomId('roulette_bet_red')\n                .setLabel('Red (1:1)')\n                .setStyle(ButtonStyle.Danger)\n                .setEmoji('üî¥'),\n            new ButtonBuilder()\n                .setCustomId('roulette_bet_black')\n                .setLabel('Black (1:1)')\n                .setStyle(ButtonStyle.Secondary)\n                .setEmoji('‚ö´'),\n            new ButtonBuilder()\n                .setCustomId('roulette_bet_green')\n                .setLabel('Green (35:1)')\n                .setStyle(ButtonStyle.Success)\n                .setEmoji('üü¢')\n        );\n    \n    const oddEvenRow = new ActionRowBuilder()\n        .addComponents(\n            new ButtonBuilder()\n                .setCustomId('roulette_bet_even')\n                .setLabel('Even (1:1)')\n                .setStyle(ButtonStyle.Primary)\n                .setEmoji('2Ô∏è‚É£'),\n            new ButtonBuilder()\n                .setCustomId('roulette_bet_odd')\n                .setLabel('Odd (1:1)')\n                .setStyle(ButtonStyle.Primary)\n                .setEmoji('1Ô∏è‚É£'),\n            new ButtonBuilder()\n                .setCustomId('roulette_bet_low')\n                .setLabel('Low 1-18 (1:1)')\n                .setStyle(ButtonStyle.Primary)\n                .setEmoji('üîΩ'),\n            new ButtonBuilder()\n                .setCustomId('roulette_bet_high')\n                .setLabel('High 19-36 (1:1)')\n                .setStyle(ButtonStyle.Primary)\n                .setEmoji('üîº')\n        );\n    \n    const numberSelect = new ActionRowBuilder()\n        .addComponents(\n            new StringSelectMenuBuilder()\n                .setCustomId('roulette_bet_number')\n                .setPlaceholder('Choose a number (0-36) for 35:1 payout')\n                .addOptions(\n                    Array.from({ length: 37 }, (_, i) => ({\n                        label: `Number ${i}`,\n                        value: `number_${i}`,\n                        description: `Bet on ${i} (35:1 payout)`,\n                        emoji: i === 0 ? 'üü¢' : (wheel[i] === 'red' ? 'üî¥' : '‚ö´')\n                    }))\n                )\n        );\n    \n    const actionRow = new ActionRowBuilder()\n        .addComponents(\n            new ButtonBuilder()\n                .setCustomId('roulette_spin')\n                .setLabel('üé∞ SPIN!')\n                .setStyle(ButtonStyle.Success)\n                .setEmoji('üé∞'),\n            new ButtonBuilder()\n                .setCustomId('roulette_clear')\n                .setLabel('Clear Bets')\n                .setStyle(ButtonStyle.Secondary)\n                .setEmoji('üóëÔ∏è'),\n            new ButtonBuilder()\n                .setCustomId('roulette_cancel')\n                .setLabel('Cancel')\n                .setStyle(ButtonStyle.Danger)\n                .setEmoji('‚ùå')\n        );\n    \n    return [colorRow, oddEvenRow, numberSelect, actionRow];\n}\n\nfunction formatBets(bets) {\n    let betString = '';\n    let totalBet = 0;\n    \n    for (const [betType, amount] of bets) {\n        betString += `‚Ä¢ **${betType}**: ${formatLTC(amount)} LTC\\n`;\n        totalBet += amount;\n    }\n    \n    betString += `\\n**Total Bet**: ${formatLTC(totalBet)} LTC`;\n    return betString;\n}\n\nfunction spinWheel() {\n    return Math.floor(Math.random() * 37);\n}\n\nfunction calculatePayout(bets, result) {\n    let totalPayout = 0;\n    const winningBets = [];\n    \n    for (const [betType, amount] of bets) {\n        let won = false;\n        let multiplier = 0;\n        \n        if (betType.startsWith('number_')) {\n            const number = parseInt(betType.split('_')[1]);\n            if (number === result) {\n                won = true;\n                multiplier = 35;\n            }\n        } else if (betType === 'red' && wheel[result] === 'red') {\n            won = true;\n            multiplier = 1;\n        } else if (betType === 'black' && wheel[result] === 'black') {\n            won = true;\n            multiplier = 1;\n        } else if (betType === 'green' && wheel[result] === 'green') {\n            won = true;\n            multiplier = 35;\n        } else if (betType === 'even' && result !== 0 && result % 2 === 0) {\n            won = true;\n            multiplier = 1;\n        } else if (betType === 'odd' && result % 2 === 1) {\n            won = true;\n            multiplier = 1;\n        } else if (betType === 'low' && result >= 1 && result <= 18) {\n            won = true;\n            multiplier = 1;\n        } else if (betType === 'high' && result >= 19 && result <= 36) {\n            won = true;\n            multiplier = 1;\n        }\n        \n        if (won) {\n            const payout = amount * (multiplier + 1);\n            totalPayout += payout;\n            winningBets.push({ betType, amount, payout, multiplier });\n        }\n    }\n    \n    return { totalPayout, winningBets };\n}\n\nfunction createResultEmbed(spin, result, payout, winningBets, user) {\n    const resultColor = wheel[result];\n    const colorEmoji = resultColor === 'red' ? 'üî¥' : resultColor === 'black' ? '‚ö´' : 'üü¢';\n    \n    let title = 'üé∞ Roulette Result';\n    let color = '#9932cc';\n    let description = `The ball landed on **${result}** ${colorEmoji}`;\n    \n    if (payout > 0) {\n        title = 'üéâ You Win!';\n        color = '#00ff00';\n        description += `\\n\\nYou won **${formatLTC(payout)} LTC**!`;\n    } else {\n        title = 'üí∏ House Wins';\n        color = '#ff0000';\n        description += `\\n\\nBetter luck next time!`;\n    }\n    \n    const embed = new EmbedBuilder()\n        .setColor(color)\n        .setTitle(title)\n        .setDescription(description)\n        .addFields(\n            {\n                name: 'üéØ Winning Number',\n                value: `**${result}** ${colorEmoji} (${resultColor})`,\n                inline: true\n            }\n        );\n    \n    if (winningBets.length > 0) {\n        const winningBetsStr = winningBets.map(bet => \n            `‚Ä¢ **${bet.betType}**: ${formatLTC(bet.amount)} LTC ‚Üí ${formatLTC(bet.payout)} LTC (${bet.multiplier + 1}x)`\n        ).join('\\n');\n        \n        embed.addFields({\n            name: 'üèÜ Winning Bets',\n            value: winningBetsStr,\n            inline: false\n        });\n    }\n    \n    const profile = userProfiles.getUserProfile(spin.userId);\n    embed.addFields({\n        name: 'üí∞ New Balance',\n        value: `${formatLTC(profile.balance)} LTC`,\n        inline: true\n    });\n    \n    return embed;\n}\n\nmodule.exports.activeSpins = activeSpins;\nmodule.exports.spinWheel = spinWheel;\nmodule.exports.calculatePayout = calculatePayout;\nmodule.exports.createResultEmbed = createResultEmbed;\nmodule.exports.createBettingEmbed = createBettingEmbed;\nmodule.exports.createBettingComponents = createBettingComponents;\nmodule.exports.wheel = wheel;","size_bytes":12983},"attached_assets/casino/attached_assets/casino/commands/setlogbal.js":{"content":"const { SlashCommandBuilder, EmbedBuilder, PermissionFlagsBits, ChannelType } = require('discord.js');\nconst fs = require('fs');\nconst path = require('path');\n\nconst CONFIG_FILE = path.join(__dirname, '../data/log_config.json');\n\n// Ensure data directory exists\nconst dataDir = path.join(__dirname, '../data');\nif (!fs.existsSync(dataDir)) {\n    fs.mkdirSync(dataDir, { recursive: true });\n}\n\nfunction loadLogConfig() {\n    try {\n        if (fs.existsSync(CONFIG_FILE)) {\n            const data = fs.readFileSync(CONFIG_FILE, 'utf8');\n            return JSON.parse(data);\n        }\n    } catch (error) {\n        console.error('Error loading log config:', error.message);\n    }\n    return {};\n}\n\nfunction saveLogConfig(config) {\n    try {\n        fs.writeFileSync(CONFIG_FILE, JSON.stringify(config, null, 2));\n        console.log('‚úÖ Log config saved');\n    } catch (error) {\n        console.error('Error saving log config:', error.message);\n    }\n}\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('setlogbal')\n        .setDescription('Configure balance log channel (Admin only)')\n        .addChannelOption(option =>\n            option.setName('channel')\n                .setDescription('Channel to send balance logs to')\n                .setRequired(true)\n                .addChannelTypes(ChannelType.GuildText)\n        )\n        .setDefaultMemberPermissions(PermissionFlagsBits.Administrator),\n    \n    async execute(interaction) {\n        // Check if interaction is too old\n        const interactionAge = Date.now() - interaction.createdTimestamp;\n        if (interactionAge > 10 * 60 * 1000) {\n            console.log('Interaction trop ancienne, ignor√©e');\n            return;\n        }\n        \n        await interaction.deferReply({ ephemeral: true });\n        \n        try {\n            const channel = interaction.options.getChannel('channel');\n            const serverId = interaction.guild.id;\n            \n            // Load config\n            const config = loadLogConfig();\n            \n            if (!config[serverId]) {\n                config[serverId] = {};\n            }\n            \n            config[serverId].balanceLogChannel = channel.id;\n            \n            // Save config\n            saveLogConfig(config);\n            \n            const successEmbed = new EmbedBuilder()\n                .setColor('#00ff00')\n                .setTitle('‚úÖ Balance Log Channel Set')\n                .setDescription(`Balance logs will now be sent to ${channel}`)\n                .addFields(\n                    {\n                        name: 'üìã Configuration Details',\n                        value: `**Channel:** ${channel}\\n**Channel ID:** \\`${channel.id}\\`\\n**Server:** ${interaction.guild.name}`,\n                        inline: false\n                    },\n                    {\n                        name: 'üìù What gets logged',\n                        value: '‚Ä¢ Deposit confirmations\\n‚Ä¢ Balance additions\\n‚Ä¢ Deposit channel closures\\n‚Ä¢ Address generations',\n                        inline: false\n                    }\n                )\n                .setFooter({ text: `Configured by ${interaction.user.username}` })\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [successEmbed] });\n            \n            // Send test message to the log channel\n            try {\n                const testEmbed = new EmbedBuilder()\n                    .setColor('#0099ff')\n                    .setTitle('üîß Balance Log Channel Configured')\n                    .setDescription('This channel has been set up to receive balance logs from the casino bot.')\n                    .addFields(\n                        {\n                            name: '‚öôÔ∏è Configured by',\n                            value: `${interaction.user} (${interaction.user.username})`,\n                            inline: false\n                        }\n                    )\n                    .setTimestamp();\n                \n                await channel.send({ embeds: [testEmbed] });\n            } catch (channelError) {\n                console.log('Could not send test message to log channel:', channelError.message);\n            }\n            \n            console.log(`üìù Balance log channel set to ${channel.name} for server ${interaction.guild.name}`);\n            \n        } catch (error) {\n            console.error('Erreur setlogbal:', error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Error')\n                .setDescription('An error occurred while setting the log channel.')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};","size_bytes":4791},"attached_assets/casino/attached_assets/casino/commands/setloggamble.js":{"content":"const { SlashCommandBuilder, EmbedBuilder, PermissionFlagsBits, ChannelType } = require('discord.js');\nconst fs = require('fs');\nconst path = require('path');\n\nconst CONFIG_FILE = path.join(__dirname, '../data/log_config.json');\n\n// Ensure data directory exists\nconst dataDir = path.join(__dirname, '../data');\nif (!fs.existsSync(dataDir)) {\n    fs.mkdirSync(dataDir, { recursive: true });\n}\n\nfunction loadLogConfig() {\n    try {\n        if (fs.existsSync(CONFIG_FILE)) {\n            const data = fs.readFileSync(CONFIG_FILE, 'utf8');\n            return JSON.parse(data);\n        }\n    } catch (error) {\n        console.error('Error loading log config:', error.message);\n    }\n    return {};\n}\n\nfunction saveLogConfig(config) {\n    try {\n        fs.writeFileSync(CONFIG_FILE, JSON.stringify(config, null, 2));\n        console.log('‚úÖ Log config saved');\n    } catch (error) {\n        console.error('Error saving log config:', error.message);\n    }\n}\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('setloggamble')\n        .setDescription('Configure gambling log channel (Admin only)')\n        .addChannelOption(option =>\n            option.setName('channel')\n                .setDescription('Channel to send gambling logs to')\n                .setRequired(true)\n                .addChannelTypes(ChannelType.GuildText)\n        )\n        .setDefaultMemberPermissions(PermissionFlagsBits.Administrator),\n    \n    async execute(interaction) {\n        // Check if interaction is too old\n        const interactionAge = Date.now() - interaction.createdTimestamp;\n        if (interactionAge > 10 * 60 * 1000) {\n            console.log('Interaction trop ancienne, ignor√©e');\n            return;\n        }\n        \n        await interaction.deferReply({ ephemeral: true });\n        \n        try {\n            const channel = interaction.options.getChannel('channel');\n            const serverId = interaction.guild.id;\n            \n            // Load config\n            const config = loadLogConfig();\n            \n            if (!config[serverId]) {\n                config[serverId] = {};\n            }\n            \n            config[serverId].gamblingLogChannel = channel.id;\n            \n            // Save config\n            saveLogConfig(config);\n            \n            const successEmbed = new EmbedBuilder()\n                .setColor('#00ff00')\n                .setTitle('‚úÖ Gambling Log Channel Set')\n                .setDescription(`Gambling logs will now be sent to ${channel}`)\n                .addFields(\n                    {\n                        name: 'üìã Configuration Details',\n                        value: `**Channel:** ${channel}\\n**Channel ID:** \\`${channel.id}\\`\\n**Server:** ${interaction.guild.name}`,\n                        inline: false\n                    },\n                    {\n                        name: 'üé∞ What gets logged',\n                        value: '‚Ä¢ Blackjack games and results\\n‚Ä¢ Roulette spins and payouts\\n‚Ä¢ Big wins and losses\\n‚Ä¢ Suspicious gambling patterns',\n                        inline: false\n                    }\n                )\n                .setFooter({ text: `Configured by ${interaction.user.username}` })\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [successEmbed] });\n            \n            // Send test message to the log channel\n            try {\n                const testEmbed = new EmbedBuilder()\n                    .setColor('#9932cc')\n                    .setTitle('üé∞ Gambling Log Channel Configured')\n                    .setDescription('This channel has been set up to receive gambling logs from the casino bot.')\n                    .addFields(\n                        {\n                            name: '‚öôÔ∏è Configured by',\n                            value: `${interaction.user} (${interaction.user.username})`,\n                            inline: false\n                        }\n                    )\n                    .setTimestamp();\n                \n                await channel.send({ embeds: [testEmbed] });\n            } catch (channelError) {\n                console.log('Could not send test message to gambling log channel:', channelError.message);\n            }\n            \n            console.log(`üé∞ Gambling log channel set to ${channel.name} for server ${interaction.guild.name}`);\n            \n        } catch (error) {\n            console.error('Erreur setloggamble:', error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Error')\n                .setDescription('An error occurred while setting the gambling log channel.')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};","size_bytes":4842},"attached_assets/casino/attached_assets/casino/commands/setpanel.js":{"content":"const { SlashCommandBuilder, EmbedBuilder, PermissionFlagsBits } = require('discord.js');\nconst panelManager = require('../utils/panelManager.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('setpanel')\n        .setDescription('Configure a casino panel in a channel')\n        .addStringOption(option =>\n            option.setName('type')\n                .setDescription('Type of panel to create')\n                .setRequired(true)\n                .addChoices(\n                    { name: 'üé∞ Casino Main Panel', value: 'casinoPanel' },\n                    { name: 'üí∞ Add Balance Panel', value: 'addBalancePanel' }\n                )\n        )\n        .addChannelOption(option =>\n            option.setName('channel')\n                .setDescription('Channel to send the panel to')\n                .setRequired(true)\n        )\n        .addChannelOption(option =>\n            option.setName('ticket_category')\n                .setDescription('Category for creating ticket channels')\n                .setRequired(false)\n        )\n        .addRoleOption(option =>\n            option.setName('staff_role')\n                .setDescription('Staff role that can see tickets')\n                .setRequired(false)\n        )\n        .setDefaultMemberPermissions(PermissionFlagsBits.Administrator),\n    \n    async execute(interaction) {\n        // Check if interaction is too old\n        const interactionAge = Date.now() - interaction.createdTimestamp;\n        if (interactionAge > 10 * 60 * 1000) {\n            console.log('Interaction trop ancienne, ignor√©e');\n            return;\n        }\n        \n        await interaction.deferReply({ ephemeral: true });\n        \n        try {\n            const panelType = interaction.options.getString('type');\n            const channel = interaction.options.getChannel('channel');\n            const ticketCategory = interaction.options.getChannel('ticket_category');\n            const staffRole = interaction.options.getRole('staff_role');\n            \n            // Validate channel type\n            if (channel.type !== 0) { // Not a text channel\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Invalid Channel')\n                    .setDescription('Please select a text channel for the panel.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Validate category if provided\n            if (ticketCategory && ticketCategory.type !== 4) { // Not a category\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Invalid Category')\n                    .setDescription('Please select a channel category for tickets.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Save configuration\n            const success = panelManager.setPanelChannel(\n                panelType,\n                channel.id,\n                ticketCategory?.id,\n                staffRole?.id\n            );\n            \n            if (!success) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Configuration Failed')\n                    .setDescription('Failed to save panel configuration.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Create and send the panel\n            const panelEmbed = await createPanelEmbed(panelType, interaction.guild);\n            const components = await createPanelComponents(panelType);\n            \n            try {\n                const message = await channel.send({ \n                    embeds: [panelEmbed], \n                    components: components \n                });\n                \n                // Save message ID\n                panelManager.setPanelMessageId(panelType, message.id);\n                \n                const successEmbed = new EmbedBuilder()\n                    .setColor('#00ff00')\n                    .setTitle('‚úÖ Panel Created')\n                    .setDescription(`${getPanelName(panelType)} has been sent to ${channel}`)\n                    .addFields(\n                        {\n                            name: 'üìã Configuration',\n                            value: `**Channel:** ${channel}\\n**Ticket Category:** ${ticketCategory || 'Not set'}\\n**Staff Role:** ${staffRole || 'Not set'}`,\n                            inline: false\n                        }\n                    )\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [successEmbed] });\n                \n            } catch (sendError) {\n                console.error('Erreur envoi panel:', sendError);\n                \n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Send Failed')\n                    .setDescription('Failed to send panel to channel. Check bot permissions.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n            }\n            \n        } catch (error) {\n            console.error('Erreur setpanel:', error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Error')\n                .setDescription('Failed to configure panel.')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};\n\n/**\n * Create panel embed based on type\n */\nasync function createPanelEmbed(panelType, guild) {\n    const { EmbedBuilder } = require('discord.js');\n    \n    if (panelType === 'casinoPanel') {\n        return new EmbedBuilder()\n            .setColor('#f7931a')\n            .setTitle('üé∞ Welcome to the Casino!')\n            .setDescription('Click the buttons below to start your casino experience.')\n            .addFields(\n                {\n                    name: 'üí∞ Add Balance',\n                    value: 'Generate a unique Litecoin address for deposits',\n                    inline: true\n                },\n                {\n                    name: 'üë§ View Profile',\n                    value: 'Check your balance and casino statistics',\n                    inline: true\n                },\n                {\n                    name: 'üèÜ Leaderboard',\n                    value: 'See the top players and rankings',\n                    inline: true\n                },\n                {\n                    name: 'üéÆ Games Available Soon',\n                    value: '‚Ä¢ üÉè Blackjack\\n‚Ä¢ üé≤ Roulette\\n‚Ä¢ üé∞ Slots',\n                    inline: false\n                }\n            )\n            .setThumbnail('https://cryptologos.cc/logos/litecoin-ltc-logo.png')\n            .setFooter({ \n                text: `${guild.name} Casino ‚Ä¢ Powered by Litecoin`,\n                iconURL: guild.iconURL() \n            })\n            .setTimestamp();\n    }\n    \n    if (panelType === 'addBalancePanel') {\n        return new EmbedBuilder()\n            .setColor('#00ff00')\n            .setTitle('üí∞ Add Balance to Your Casino Account')\n            .setDescription('Click the button below to get a unique deposit address and start playing!')\n            .addFields(\n                {\n                    name: '‚ö° Instant Detection',\n                    value: 'Deposits are detected within 30 seconds',\n                    inline: true\n                },\n                {\n                    name: 'üîí Secure',\n                    value: 'Each deposit gets a unique address',\n                    inline: true\n                },\n                {\n                    name: 'üìà Minimum Deposit',\n                    value: '0.001 LTC',\n                    inline: true\n                }\n            )\n            .setThumbnail('https://cryptologos.cc/logos/litecoin-ltc-logo.png')\n            .setFooter({ \n                text: `${guild.name} Casino ‚Ä¢ Safe & Secure`,\n                iconURL: guild.iconURL() \n            })\n            .setTimestamp();\n    }\n}\n\n/**\n * Create panel components based on type\n */\nasync function createPanelComponents(panelType) {\n    const { ActionRowBuilder, ButtonBuilder, ButtonStyle } = require('discord.js');\n    \n    if (panelType === 'casinoPanel') {\n        return [\n            new ActionRowBuilder()\n                .addComponents(\n                    new ButtonBuilder()\n                        .setCustomId('panel_add_balance')\n                        .setLabel('üí∞ Add Balance')\n                        .setStyle(ButtonStyle.Success)\n                        .setEmoji('üí∞'),\n                    new ButtonBuilder()\n                        .setCustomId('panel_view_profile')\n                        .setLabel('üë§ View Profile')\n                        .setStyle(ButtonStyle.Primary)\n                        .setEmoji('üë§'),\n                    new ButtonBuilder()\n                        .setCustomId('panel_leaderboard')\n                        .setLabel('üèÜ Leaderboard')\n                        .setStyle(ButtonStyle.Secondary)\n                        .setEmoji('üèÜ')\n                ),\n            new ActionRowBuilder()\n                .addComponents(\n                    new ButtonBuilder()\n                        .setCustomId('panel_games_blackjack')\n                        .setLabel('üÉè Blackjack')\n                        .setStyle(ButtonStyle.Secondary)\n                        .setEmoji('üÉè')\n                        .setDisabled(true),\n                    new ButtonBuilder()\n                        .setCustomId('panel_games_roulette')\n                        .setLabel('üé≤ Roulette')\n                        .setStyle(ButtonStyle.Secondary)\n                        .setEmoji('üé≤')\n                        .setDisabled(true),\n                    new ButtonBuilder()\n                        .setCustomId('panel_games_slots')\n                        .setLabel('üé∞ Slots')\n                        .setStyle(ButtonStyle.Secondary)\n                        .setEmoji('üé∞')\n                        .setDisabled(true)\n                )\n        ];\n    }\n    \n    if (panelType === 'addBalancePanel') {\n        return [\n            new ActionRowBuilder()\n                .addComponents(\n                    new ButtonBuilder()\n                        .setCustomId('panel_add_balance')\n                        .setLabel('üí∞ Get Deposit Address')\n                        .setStyle(ButtonStyle.Success)\n                        .setEmoji('üí∞')\n                )\n        ];\n    }\n    \n    return [];\n}\n\n/**\n * Get friendly panel name\n */\nfunction getPanelName(panelType) {\n    const names = {\n        'casinoPanel': 'üé∞ Casino Main Panel',\n        'addBalancePanel': 'üí∞ Add Balance Panel'\n    };\n    return names[panelType] || panelType;\n}","size_bytes":11275},"attached_assets/casino/attached_assets/casino/commands/setpassword.js":{"content":"const { SlashCommandBuilder, EmbedBuilder } = require('discord.js');\nconst securityManager = require('../utils/securityManager.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('setpassword')\n        .setDescription('Set your account password (required for security features)')\n        .addStringOption(option =>\n            option.setName('password')\n                .setDescription('Your new password (minimum 6 characters)')\n                .setRequired(true)\n        ),\n    \n    async execute(interaction) {\n        await interaction.deferReply({ ephemeral: true });\n        \n        try {\n            const password = interaction.options.getString('password');\n            \n            // Validate password\n            if (password.length < 6) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Invalid Password')\n                    .setDescription('Password must be at least 6 characters long.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Check if user already has a password\n            const userSec = securityManager.getUserSecurity(interaction.user.id);\n            if (userSec.hasPassword) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Password Already Set')\n                    .setDescription('You already have a password set. Use `/changepassword` to change it.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Set password and generate recovery key\n            const recoveryKey = securityManager.setUserPassword(interaction.user.id, password);\n            \n            const successEmbed = new EmbedBuilder()\n                .setColor('#00ff00')\n                .setTitle('üîí Password Set Successfully')\n                .setDescription('Your password has been set and your recovery key has been generated.')\n                .addFields(\n                    {\n                        name: 'üîë Recovery Key',\n                        value: `\\`${recoveryKey}\\``,\n                        inline: false\n                    },\n                    {\n                        name: '‚ö†Ô∏è IMPORTANT',\n                        value: '**Save this recovery key immediately!** You need it to recover your account if you lose access. Store it in a safe place.',\n                        inline: false\n                    },\n                    {\n                        name: 'üõ°Ô∏è Security Features Unlocked',\n                        value: '‚Ä¢ View recovery key with password\\n‚Ä¢ Enable gambling sessions\\n‚Ä¢ Secure cashout protection\\n‚Ä¢ Account recovery',\n                        inline: false\n                    }\n                )\n                .setThumbnail('https://em-content.zobj.net/thumbs/120/twitter/351/locked_1f512.png')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [successEmbed] });\n            \n        } catch (error) {\n            console.error('Set password error:', error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Error')\n                .setDescription('Failed to set password. Please try again.')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};","size_bytes":3699},"attached_assets/casino/attached_assets/casino/commands/stopallactives.js":{"content":"const { SlashCommandBuilder, EmbedBuilder, PermissionFlagsBits } = require('discord.js');\nconst securityManager = require('../utils/securityManager.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('stopallactives')\n        .setDescription('Stop all active deposits monitoring (Admin only)')\n        .setDefaultMemberPermissions(PermissionFlagsBits.Administrator),\n    \n    async execute(interaction) {\n        // Check if interaction is too old\n        const interactionAge = Date.now() - interaction.createdTimestamp;\n        if (interactionAge > 10 * 60 * 1000) {\n            console.log('Interaction trop ancienne, ignor√©e');\n            return;\n        }\n        \n        await interaction.deferReply({ ephemeral: true });\n        \n        try {\n            // Get all active deposits before clearing\n            const activeDeposits = securityManager.getAllActiveDeposits();\n            const activeCount = activeDeposits.length;\n            \n            if (activeCount === 0) {\n                const noActiveEmbed = new EmbedBuilder()\n                    .setColor('#ffaa00')\n                    .setTitle('‚ÑπÔ∏è No Active Deposits')\n                    .setDescription('There are no active deposits to stop.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [noActiveEmbed] });\n                return;\n            }\n            \n            // Clear all active deposits\n            const success = securityManager.clearAllActiveDeposits();\n            \n            if (success) {\n                // Stop monitoring\n                const { stopSmartMonitoring } = require('../discord-bot.js');\n                stopSmartMonitoring();\n                \n                const successEmbed = new EmbedBuilder()\n                    .setColor('#00ff00')\n                    .setTitle('‚úÖ All Active Deposits Stopped')\n                    .setDescription(`Successfully stopped monitoring for **${activeCount}** active deposit(s).`)\n                    .addFields(\n                        {\n                            name: 'üõë Actions Taken',\n                            value: '‚Ä¢ All active deposits cleared\\n‚Ä¢ Smart monitoring stopped\\n‚Ä¢ Users will need to generate new addresses',\n                            inline: false\n                        },\n                        {\n                            name: '‚ö†Ô∏è Note',\n                            value: 'Users with pending deposits will need to use `/casino` again to generate new addresses.',\n                            inline: false\n                        }\n                    )\n                    .setFooter({ text: `Executed by ${interaction.user.username}` })\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [successEmbed] });\n                \n                console.log(`üõë Admin ${interaction.user.username} stopped ${activeCount} active deposits`);\n                \n            } else {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Failed to Stop')\n                    .setDescription('Failed to clear active deposits. Please try again.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n            }\n            \n        } catch (error) {\n            console.error('Erreur stopallactives:', error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Error')\n                .setDescription('An error occurred while stopping active deposits.')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};","size_bytes":3853},"attached_assets/casino/attached_assets/casino/commands/testgamble.js":{"content":"const { SlashCommandBuilder, EmbedBuilder } = require('discord.js');\nconst securityManager = require('../utils/securityManager.js');\nconst userProfiles = require('../utils/userProfiles.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('testgamble')\n        .setDescription('Test gambling command to simulate wagering (requires active session)')\n        .addNumberOption(option =>\n            option.setName('amount')\n                .setDescription('Amount to wager in LTC')\n                .setRequired(true)\n                .setMinValue(0.001)\n        ),\n    \n    async execute(interaction) {\n        await interaction.deferReply({ ephemeral: true });\n        \n        try {\n            const amount = interaction.options.getNumber('amount');\n            const userId = interaction.user.id;\n            \n            // Check if user has active gambling session\n            if (!securityManager.hasActiveGamblingSession(userId)) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå No Active Session')\n                    .setDescription('You need to enable a gambling session first using `/enable`.')\n                    .addFields({\n                        name: 'üîí How to Start',\n                        value: 'Use `/enable [minutes] [password]` to start a gambling session.',\n                        inline: false\n                    })\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Check user balance\n            const profile = userProfiles.getUserProfile(userId);\n            \n            if (profile.balance < amount) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Insufficient Balance')\n                    .setDescription('You don\\'t have enough balance to wager this amount.')\n                    .addFields({\n                        name: 'üí∞ Available Balance',\n                        value: `${profile.balance.toFixed(8)} LTC`,\n                        inline: true\n                    })\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Simulate gambling result (50/50 chance for testing)\n            const won = Math.random() > 0.5;\n            const resultAmount = won ? amount * 1.8 : 0; // 1.8x payout if win\n            \n            // Update balance\n            const newBalance = profile.balance - amount + resultAmount;\n            userProfiles.updateUserProfile(userId, { balance: newBalance });\n            \n            // Add wagered amount (for cashout protection)\n            securityManager.addWageredAmount(userId, amount);\n            \n            // Check new cashout status\n            const cashoutStatus = securityManager.canUserCashout(userId);\n            \n            const resultEmbed = new EmbedBuilder()\n                .setColor(won ? '#00ff00' : '#ff0000')\n                .setTitle(won ? 'üéâ You Won!' : 'üíî You Lost!')\n                .setDescription(`Test gambling result: ${won ? 'WIN' : 'LOSS'}`)\n                .addFields(\n                    {\n                        name: 'üé≤ Game Result',\n                        value: `**Wagered:** ${amount.toFixed(8)} LTC\\n**${won ? 'Won' : 'Lost'}:** ${resultAmount.toFixed(8)} LTC\\n**Net:** ${(resultAmount - amount).toFixed(8)} LTC`,\n                        inline: true\n                    },\n                    {\n                        name: 'üí∞ Balance Update',\n                        value: `**Previous:** ${profile.balance.toFixed(8)} LTC\\n**Current:** ${newBalance.toFixed(8)} LTC`,\n                        inline: true\n                    },\n                    {\n                        name: 'üìä Cashout Status',\n                        value: `**Progress:** ${cashoutStatus.wageredPercent.toFixed(1)}%\\n**Can Cashout:** ${cashoutStatus.canCashout ? '‚úÖ Yes' : '‚ùå No'}\\n**Remaining:** ${cashoutStatus.remainingToWager.toFixed(8)} LTC`,\n                        inline: false\n                    }\n                )\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [resultEmbed] });\n            \n            console.log(`üé≤ ${interaction.user.username} ${won ? 'won' : 'lost'} ${amount} LTC - Balance: ${newBalance.toFixed(8)} LTC`);\n            \n        } catch (error) {\n            console.error('Test gamble error:', error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Game Error')\n                .setDescription('An error occurred during the game. Please try again.')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};","size_bytes":5045},"attached_assets/casino/attached_assets/casino/deploy-commands.js":{"content":"const { REST, Routes } = require('discord.js');\nconst fs = require('fs');\nconst path = require('path');\n\n// Load environment variables\nrequire('dotenv').config();\n\nconst commands = [];\n\n// Load all command files\nconst commandsPath = path.join(__dirname, 'commands');\nconst commandFiles = fs.readdirSync(commandsPath).filter(file => file.endsWith('.js'));\n\nfor (const file of commandFiles) {\n    const filePath = path.join(commandsPath, file);\n    const command = require(filePath);\n    \n    if ('data' in command && 'execute' in command) {\n        commands.push(command.data.toJSON());\n        console.log(`‚úÖ Loaded command: ${command.data.name}`);\n    } else {\n        console.log(`‚ö†Ô∏è  Command ${file} is missing required properties`);\n    }\n}\n\n// Deploy commands\nasync function deployCommands() {\n    const token = process.env.DISCORD_TOKEN;\n    const clientId = process.env.DISCORD_CLIENT_ID;\n    const guildId = process.env.DISCORD_GUILD_ID; // Optional: for guild-specific commands\n    \n    if (!token) {\n        console.error('‚ùå DISCORD_TOKEN is required!');\n        process.exit(1);\n    }\n    \n    if (!clientId) {\n        console.error('‚ùå DISCORD_CLIENT_ID is required!');\n        process.exit(1);\n    }\n    \n    const rest = new REST().setToken(token);\n    \n    try {\n        console.log(`üîÑ Started refreshing ${commands.length} application (/) commands.`);\n        \n        let data;\n        \n        if (guildId) {\n            // Deploy to specific guild (faster for development)\n            data = await rest.put(\n                Routes.applicationGuildCommands(clientId, guildId),\n                { body: commands },\n            );\n            console.log(`‚úÖ Successfully reloaded ${data.length} guild commands for guild ${guildId}.`);\n        } else {\n            // Deploy globally (takes up to 1 hour to propagate)\n            data = await rest.put(\n                Routes.applicationCommands(clientId),\n                { body: commands },\n            );\n            console.log(`‚úÖ Successfully reloaded ${data.length} global application commands.`);\n        }\n        \n    } catch (error) {\n        console.error('‚ùå Error deploying commands:', error);\n    }\n}\n\n// Run deployment if this file is executed directly\nif (require.main === module) {\n    deployCommands();\n}\n\nmodule.exports = { deployCommands };","size_bytes":2341},"attached_assets/casino/attached_assets/casino/discord-bot.js":{"content":"const { Client, GatewayIntentBits, Collection, EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle, Events } = require('discord.js');\nconst fs = require('fs');\nconst path = require('path');\n\n// Import Litecoin wallet system\nconst ltcWallet = require('./litecoin-casino-bot.js');\n\n// Create Discord client\nconst client = new Client({\n    intents: [\n        GatewayIntentBits.Guilds,\n        GatewayIntentBits.GuildMessages,\n        GatewayIntentBits.MessageContent,\n        GatewayIntentBits.GuildMembers\n    ]\n});\n\n// Commands collection\nclient.commands = new Collection();\n\n// Load commands\nconst commandsPath = path.join(__dirname, 'commands');\nif (fs.existsSync(commandsPath)) {\n    const commandFiles = fs.readdirSync(commandsPath).filter(file => file.endsWith('.js'));\n    \n    for (const file of commandFiles) {\n        const filePath = path.join(commandsPath, file);\n        const command = require(filePath);\n        \n        if ('data' in command && 'execute' in command) {\n            client.commands.set(command.data.name, command);\n            console.log(`‚úÖ Commande charg√©e: ${command.data.name}`);\n        } else {\n            console.log(`‚ö†Ô∏è  Commande ${file} manque des propri√©t√©s requises`);\n        }\n    }\n}\n\n// Load events\nconst eventsPath = path.join(__dirname, 'events');\nif (fs.existsSync(eventsPath)) {\n    const eventFiles = fs.readdirSync(eventsPath).filter(file => file.endsWith('.js'));\n    \n    for (const file of eventFiles) {\n        const filePath = path.join(eventsPath, file);\n        const event = require(filePath);\n        \n        if (event.once) {\n            client.once(event.name, (...args) => event.execute(...args));\n        } else {\n            client.on(event.name, (...args) => event.execute(...args));\n        }\n        console.log(`‚úÖ √âv√©nement charg√©: ${event.name}`);\n    }\n}\n\n\n// Interaction handling\nclient.on(Events.InteractionCreate, async interaction => {\n    // Handle slash commands\n    if (interaction.isChatInputCommand()) {\n        const command = client.commands.get(interaction.commandName);\n        \n        if (!command) {\n            console.error(`‚ùå Aucune commande correspondant √† ${interaction.commandName} trouv√©e.`);\n            return;\n        }\n        \n        try {\n            await command.execute(interaction);\n        } catch (error) {\n            console.error(`‚ùå Erreur lors de l'ex√©cution de ${interaction.commandName}:`, error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Error')\n                .setDescription('There was an error while executing this command!')\n                .setTimestamp();\n            \n            if (interaction.replied || interaction.deferred) {\n                await interaction.followUp({ embeds: [errorEmbed], ephemeral: true });\n            } else {\n                await interaction.reply({ embeds: [errorEmbed], ephemeral: true });\n            }\n        }\n    }\n    \n    // Handle button interactions\n    if (interaction.isButton()) {\n        console.log(`üîò Button interaction: ${interaction.customId}`);\n        try {\n            // Add Balance button\n            if (interaction.customId === 'add_balance') {\n                await handleAddBalance(interaction);\n            }\n            // Create channel button\n            else if (interaction.customId === 'create_channel') {\n                await handleCreateChannel(interaction);\n            }\n            // Re-add balance button\n            else if (interaction.customId === 'readd_balance') {\n                await handleAddBalance(interaction);\n            }\n            // Close channel button\n            else if (interaction.customId === 'close_channel') {\n                await handleCloseChannel(interaction);\n            }\n            // Blackjack game buttons\n            else if (interaction.customId.startsWith('blackjack_')) {\n                await handleBlackjackInteraction(interaction);\n            }\n            // Roulette game buttons\n            else if (interaction.customId.startsWith('roulette_')) {\n                await handleRouletteInteraction(interaction);\n            }\n            // Casino game quick start buttons\n            else if (interaction.customId === 'casino_blackjack') {\n                console.log('üÉè Casino blackjack button clicked');\n                await handleCasinoBlackjack(interaction);\n            }\n            else if (interaction.customId === 'casino_roulette') {\n                console.log('üé∞ Casino roulette button clicked');\n                await handleCasinoRoulette(interaction);\n            }\n            // Other button handlers can be added here\n            else {\n                console.log(`‚ùì Interaction bouton inconnue: ${interaction.customId}`);\n            }\n        } catch (error) {\n            console.error('‚ùå Erreur d\\'interaction bouton:', error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Error')\n                .setDescription('There was an error processing your request!')\n                .setTimestamp();\n            \n            if (interaction.replied || interaction.deferred) {\n                await interaction.followUp({ embeds: [errorEmbed], ephemeral: true });\n            } else {\n                await interaction.reply({ embeds: [errorEmbed], ephemeral: true });\n            }\n        }\n    }\n    \n    // Handle select menu interactions\n    if (interaction.isStringSelectMenu()) {\n        try {\n            // Roulette number selection\n            if (interaction.customId === 'roulette_bet_number') {\n                await handleRouletteNumberBet(interaction);\n            }\n        } catch (error) {\n            console.error('‚ùå Erreur d\\'interaction menu:', error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Error')\n                .setDescription('There was an error processing your selection!')\n                .setTimestamp();\n            \n            if (interaction.replied || interaction.deferred) {\n                await interaction.followUp({ embeds: [errorEmbed], ephemeral: true });\n            } else {\n                await interaction.reply({ embeds: [errorEmbed], ephemeral: true });\n            }\n        }\n    }\n});\n\n// Add Balance handler\nasync function handleAddBalance(interaction) {\n    await interaction.deferReply({ ephemeral: false });\n    \n    try {\n        // Generate new LTC address for each deposit request (always new address)\n        const newAddress = ltcWallet.generateAddress();\n        \n        if (!newAddress) {\n            throw new Error('Failed to generate Litecoin address');\n        }\n        \n        // Link address to user and add to active deposits monitoring\n        const userProfiles = require('./utils/userProfiles.js');\n        const securityManager = require('./utils/securityManager.js');\n        const logManager = require('./utils/logManager.js');\n        \n        await userProfiles.linkAddressToUser(interaction.user.id, newAddress.address);\n        securityManager.addActiveDeposit(interaction.user.id, newAddress.address, 0);\n        \n        // Log address generation\n        await logManager.sendBalanceLog(client, interaction.guild.id, {\n            type: 'address_generated',\n            user: interaction.user,\n            address: newAddress.address\n        });\n        \n        // Start smart monitoring for this deposit\n        startSmartMonitoring();\n        \n        const depositEmbed = new EmbedBuilder()\n            .setColor('#f7931a')\n            .setTitle('üí∞ Add Balance - New Litecoin Address')\n            .setDescription('Send the amount you want to deposit to the **new unique address** below:')\n            .addFields(\n                { name: 'üìç Deposit Address (NEW)', value: `\\`${newAddress.address}\\``, inline: false },\n                { name: '‚è±Ô∏è Smart Detection', value: 'Monitoring active - deposits detected within 30 seconds', inline: true },\n                { name: 'üîÑ Status', value: 'Waiting for deposit...', inline: true },\n                { name: 'üîí Security', value: 'This address is unique to this deposit request', inline: false }\n            )\n            .setThumbnail('https://cryptologos.cc/logos/litecoin-ltc-logo.png')\n            .setFooter({ text: 'Casino Bot ‚Ä¢ Smart Monitoring Active' })\n            .setTimestamp();\n        \n        await interaction.editReply({ \n            embeds: [depositEmbed]\n        });\n        \n        // Send address as plain text in a separate message\n        await interaction.followUp({\n            content: `**Adresse de d√©p√¥t:** \\`${newAddress.address}\\`\\n\\n‚ö†Ô∏è **Important:**\\n‚Ä¢ Votre balance sera ajout√©e une fois le paiement confirm√© √† **100%**\\n‚Ä¢ Si apr√®s **20 minutes** votre balance n'a toujours pas √©t√© ajout√©e ou qu'il y a un souci, veuillez ping un staff`,\n            ephemeral: false\n        });\n        \n        console.log(`üîç Surveillance d√©marr√©e pour l'adresse ${newAddress.address} (utilisateur ${interaction.user.username})`);\n        \n    } catch (error) {\n        console.error('‚ùå Add balance error:', error);\n        \n        const errorEmbed = new EmbedBuilder()\n            .setColor('#ff0000')\n            .setTitle('‚ùå Error')\n            .setDescription('Failed to generate deposit address. Please try again.')\n            .setTimestamp();\n        \n        await interaction.editReply({ embeds: [errorEmbed] });\n    }\n}\n\n// Create Channel handler\nasync function handleCreateChannel(interaction) {\n    await interaction.deferReply({ ephemeral: false });\n    \n    try {\n        const guild = interaction.guild;\n        const user = interaction.user;\n        \n        // Check if user already has a channel\n        const existingChannel = guild.channels.cache.find(channel => \n            channel.name === `casino-${user.username.toLowerCase()}` && \n            channel.type === 0 // Text channel\n        );\n        \n        if (existingChannel) {\n            const alreadyExistsEmbed = new EmbedBuilder()\n                .setColor('#ffaa00')\n                .setTitle('‚ö†Ô∏è Channel Already Exists')\n                .setDescription(`You already have a private channel: ${existingChannel}`)\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [alreadyExistsEmbed] });\n            return;\n        }\n        \n        // Create private channel\n        const channel = await guild.channels.create({\n            name: `casino-${user.username.toLowerCase()}`,\n            type: 0, // Text channel\n            topic: `Private casino session for ${user.username}`,\n            permissionOverwrites: [\n                {\n                    id: guild.id,\n                    deny: ['ViewChannel', 'SendMessages']\n                },\n                {\n                    id: user.id,\n                    allow: ['ViewChannel', 'SendMessages', 'ReadMessageHistory']\n                }\n                // Add staff role permissions here if needed\n                // {\n                //     id: 'STAFF_ROLE_ID',\n                //     allow: ['ViewChannel', 'SendMessages', 'ReadMessageHistory']\n                // }\n            ]\n        });\n        \n        const successEmbed = new EmbedBuilder()\n            .setColor('#00ff00')\n            .setTitle('‚úÖ Private Channel Created')\n            .setDescription(`Your private casino channel has been created: ${channel}`)\n            .addFields(\n                { name: 'üé∞ Features Available', value: '‚Ä¢ Check balance\\n‚Ä¢ Play casino games\\n‚Ä¢ Withdraw funds\\n‚Ä¢ Get support', inline: false },\n                { name: '‚è∞ Auto-Delete', value: 'Channel will be deleted after 24 hours of inactivity', inline: false }\n            )\n            .setTimestamp();\n        \n        await interaction.editReply({ embeds: [successEmbed] });\n        \n        // Send welcome message in the new channel\n        const welcomeEmbed = new EmbedBuilder()\n            .setColor('#f7931a')\n            .setTitle('üé∞ Welcome to Your Private Casino!')\n            .setDescription(`Hello ${user}! This is your private casino session.`)\n            .addFields(\n                { name: 'üí∞ Available Commands', value: '‚Ä¢ `/profile` - View your profile\\n‚Ä¢ `/balance` - Check balance\\n‚Ä¢ `/givebal` - Transfer balance\\n‚Ä¢ `/convert-eur-usd` - Currency converter', inline: false },\n                { name: 'üéÆ Coming Soon', value: '‚Ä¢ Blackjack\\n‚Ä¢ Roulette\\n‚Ä¢ Slots', inline: true },\n                { name: 'üîß Support', value: 'Need help? Staff can access this channel.', inline: true }\n            )\n            .setThumbnail(user.displayAvatarURL())\n            .setTimestamp();\n        \n        await channel.send({ embeds: [welcomeEmbed] });\n        \n        console.log(`üè† Private channel created: ${channel.name} for ${user.username}`);\n        \n        // Auto-close channel after 20 minutes\n        setTimeout(async () => {\n            try {\n                const logManager = require('./utils/logManager.js');\n                await logManager.sendBalanceLog(client, interaction.guild.id, {\n                    type: 'channel_closed',\n                    user: interaction.user,\n                    details: 'Auto-close after 20 minutes'\n                });\n                \n                await channel.delete('Auto-close after 20 minutes');\n                console.log(`üîí Auto-closed channel ${channel.name} after 20 minutes`);\n            } catch (autoCloseError) {\n                console.error('Error auto-closing channel:', autoCloseError);\n            }\n        }, 20 * 60 * 1000); // 20 minutes\n        \n    } catch (error) {\n        console.error('‚ùå Create channel error:', error);\n        \n        const errorEmbed = new EmbedBuilder()\n            .setColor('#ff0000')\n            .setTitle('‚ùå Error')\n            .setDescription('Failed to create private channel. Please contact staff.')\n            .setTimestamp();\n        \n        await interaction.editReply({ embeds: [errorEmbed] });\n    }\n}\n\n// Close Channel handler\nasync function handleCloseChannel(interaction) {\n    await interaction.deferReply({ ephemeral: false });\n    \n    try {\n        const channel = interaction.channel;\n        \n        // Log channel closure\n        const logManager = require('./utils/logManager.js');\n        await logManager.sendBalanceLog(client, interaction.guild.id, {\n            type: 'channel_closed',\n            user: interaction.user,\n            details: 'Manually closed by user'\n        });\n        \n        const confirmEmbed = new EmbedBuilder()\n            .setColor('#ff6600')\n            .setTitle('üîí Channel Closing')\n            .setDescription('This channel will be deleted in 5 seconds...')\n            .setTimestamp();\n        \n        await interaction.editReply({ embeds: [confirmEmbed] });\n        \n        // Delete channel after 5 seconds\n        setTimeout(async () => {\n            try {\n                await channel.delete('Manually closed by user');\n                console.log(`üîí Channel ${channel.name} closed by ${interaction.user.username}`);\n            } catch (deleteError) {\n                console.error('Error deleting channel:', deleteError);\n            }\n        }, 5000);\n        \n    } catch (error) {\n        console.error('‚ùå Close channel error:', error);\n        \n        const errorEmbed = new EmbedBuilder()\n            .setColor('#ff0000')\n            .setTitle('‚ùå Error')\n            .setDescription('Unable to close the channel. Please try again.')\n            .setTimestamp();\n        \n        await interaction.editReply({ embeds: [errorEmbed] });\n    }\n}\n\n// Blackjack interaction handler\nasync function handleBlackjackInteraction(interaction) {\n    const { activeGames, calculateHandValue, dealCard, createGameEmbed, createGameButtons } = require('./commands/blackjack.js');\n    const userProfiles = require('./utils/userProfiles.js');\n    const securityManager = require('./utils/securityManager.js');\n    const logManager = require('./utils/logManager.js');\n    const { formatLTC } = require('./utils/formatters.js');\n    \n    await interaction.deferUpdate();\n    \n    const userId = interaction.user.id;\n    const game = activeGames.get(userId);\n    \n    if (!game || game.status !== 'playing') {\n        return;\n    }\n    \n    try {\n        if (interaction.customId === 'blackjack_hit') {\n            // Player hits\n            game.playerHand.push(dealCard(game));\n            game.playerValue = calculateHandValue(game.playerHand);\n            game.canDoubleDown = false;\n            \n            if (game.playerValue > 21) {\n                game.status = 'lost';\n                activeGames.delete(userId);\n                \n                // Log the game\n                await logManager.sendGamblingLog(client, interaction.guild.id, {\n                    type: 'blackjack',\n                    user: interaction.user,\n                    game: 'blackjack',\n                    bet: game.bet,\n                    result: 'lose',\n                    payout: 0,\n                    details: `Player busted with ${game.playerValue}`\n                });\n            }\n            \n        } else if (interaction.customId === 'blackjack_stand') {\n            // Player stands - dealer plays\n            while (game.dealerValue < 17) {\n                game.dealerHand.push(dealCard(game));\n                game.dealerValue = calculateHandValue(game.dealerHand);\n            }\n            \n            // Determine winner\n            let payout = 0;\n            if (game.dealerValue > 21) {\n                game.status = 'won';\n                payout = game.bet * 2;\n            } else if (game.playerValue > game.dealerValue) {\n                game.status = 'won';\n                payout = game.bet * 2;\n            } else if (game.playerValue < game.dealerValue) {\n                game.status = 'lost';\n                payout = 0;\n            } else {\n                game.status = 'push';\n                payout = game.bet; // Return bet\n            }\n            \n            // Update balance\n            if (payout > 0) {\n                const profile = userProfiles.getUserProfile(userId);\n                userProfiles.updateUserProfile(userId, { \n                    balance: profile.balance + payout \n                });\n            }\n            \n            // Log the game\n            await logManager.sendGamblingLog(client, interaction.guild.id, {\n                type: 'blackjack',\n                user: interaction.user,\n                game: 'blackjack',\n                bet: game.bet,\n                result: game.status === 'won' ? 'win' : game.status === 'lost' ? 'lose' : 'push',\n                payout: payout,\n                details: `Player: ${game.playerValue}, Dealer: ${game.dealerValue}`\n            });\n            \n            activeGames.delete(userId);\n            \n        } else if (interaction.customId === 'blackjack_double') {\n            // Player doubles down\n            const profile = userProfiles.getUserProfile(userId);\n            if (profile.balance >= game.bet) {\n                userProfiles.updateUserProfile(userId, { \n                    balance: profile.balance - game.bet \n                });\n                securityManager.addWageredAmount(userId, game.bet);\n                \n                game.bet *= 2;\n                game.playerHand.push(dealCard(game));\n                game.playerValue = calculateHandValue(game.playerHand);\n                \n                if (game.playerValue > 21) {\n                    game.status = 'lost';\n                } else {\n                    // Dealer plays\n                    while (game.dealerValue < 17) {\n                        game.dealerHand.push(dealCard(game));\n                        game.dealerValue = calculateHandValue(game.dealerHand);\n                    }\n                    \n                    // Determine winner\n                    let payout = 0;\n                    if (game.dealerValue > 21 || game.playerValue > game.dealerValue) {\n                        game.status = 'won';\n                        payout = game.bet * 2;\n                    } else if (game.playerValue < game.dealerValue) {\n                        game.status = 'lost';\n                        payout = 0;\n                    } else {\n                        game.status = 'push';\n                        payout = game.bet;\n                    }\n                    \n                    if (payout > 0) {\n                        const updatedProfile = userProfiles.getUserProfile(userId);\n                        userProfiles.updateUserProfile(userId, { \n                            balance: updatedProfile.balance + payout \n                        });\n                    }\n                }\n                \n                // Log the game\n                await logManager.sendGamblingLog(client, interaction.guild.id, {\n                    type: 'blackjack',\n                    user: interaction.user,\n                    game: 'blackjack',\n                    bet: game.bet,\n                    result: game.status === 'won' ? 'win' : game.status === 'lost' ? 'lose' : 'push',\n                    payout: payout || 0,\n                    details: `Double Down - Player: ${game.playerValue}, Dealer: ${game.dealerValue}`\n                });\n                \n                activeGames.delete(userId);\n            }\n        }\n        \n        // Update the game display\n        const gameEmbed = createGameEmbed(game, interaction.user);\n        const gameButtons = createGameButtons(game);\n        \n        await interaction.editReply({ \n            embeds: [gameEmbed],\n            components: game.status === 'playing' ? [gameButtons] : []\n        });\n        \n    } catch (error) {\n        console.error('Erreur blackjack interaction:', error);\n    }\n}\n\n// Roulette interaction handler\nasync function handleRouletteInteraction(interaction) {\n    const { activeSpins, spinWheel, calculatePayout, createResultEmbed, createBettingEmbed, createBettingComponents } = require('./commands/roulette.js');\n    const userProfiles = require('./utils/userProfiles.js');\n    const securityManager = require('./utils/securityManager.js');\n    const logManager = require('./utils/logManager.js');\n    const { formatLTC } = require('./utils/formatters.js');\n    \n    await interaction.deferUpdate();\n    \n    const userId = interaction.user.id;\n    const spin = activeSpins.get(userId);\n    \n    if (!spin || spin.status !== 'betting') {\n        return;\n    }\n    \n    try {\n        if (interaction.customId === 'roulette_spin') {\n            if (spin.bets.size === 0) {\n                return; // No bets placed\n            }\n            \n            // Deduct total bet amount\n            let totalBet = 0;\n            for (const [, amount] of spin.bets) {\n                totalBet += amount;\n            }\n            \n            const profile = userProfiles.getUserProfile(userId);\n            userProfiles.updateUserProfile(userId, { \n                balance: profile.balance - totalBet \n            });\n            securityManager.addWageredAmount(userId, totalBet);\n            \n            // Spin the wheel\n            const result = spinWheel();\n            const { totalPayout, winningBets } = calculatePayout(spin.bets, result);\n            \n            // Add winnings to balance\n            if (totalPayout > 0) {\n                const updatedProfile = userProfiles.getUserProfile(userId);\n                userProfiles.updateUserProfile(userId, { \n                    balance: updatedProfile.balance + totalPayout \n                });\n            }\n            \n            // Log the game\n            await logManager.sendGamblingLog(client, interaction.guild.id, {\n                type: 'roulette',\n                user: interaction.user,\n                game: 'roulette',\n                bet: totalBet,\n                result: totalPayout > 0 ? 'win' : 'lose',\n                payout: totalPayout,\n                details: `Number ${result}, Total Bet: ${formatLTC(totalBet)} LTC`\n            });\n            \n            // Check for big win (5x or more)\n            if (totalPayout >= totalBet * 5) {\n                await logManager.sendGamblingLog(client, interaction.guild.id, {\n                    type: 'big_win',\n                    user: interaction.user,\n                    game: 'roulette',\n                    bet: totalBet,\n                    result: 'win',\n                    payout: totalPayout\n                });\n            }\n            \n            spin.status = 'finished';\n            spin.result = result;\n            spin.totalPayout = totalPayout;\n            \n            const resultEmbed = createResultEmbed(spin, result, totalPayout, winningBets, interaction.user);\n            \n            await interaction.editReply({ \n                embeds: [resultEmbed],\n                components: []\n            });\n            \n            activeSpins.delete(userId);\n            \n        } else if (interaction.customId === 'roulette_clear') {\n            spin.bets.clear();\n            const bettingEmbed = createBettingEmbed(spin, interaction.user);\n            const bettingComponents = createBettingComponents();\n            \n            await interaction.editReply({ \n                embeds: [bettingEmbed],\n                components: bettingComponents\n            });\n            \n        } else if (interaction.customId === 'roulette_cancel') {\n            activeSpins.delete(userId);\n            \n            const cancelEmbed = new EmbedBuilder()\n                .setColor('#ff6600')\n                .setTitle('üö´ Roulette Cancelled')\n                .setDescription('Your roulette game has been cancelled.')\n                .setTimestamp();\n            \n            await interaction.editReply({ \n                embeds: [cancelEmbed],\n                components: []\n            });\n            \n        } else {\n            // Handle bet buttons\n            const betType = interaction.customId.replace('roulette_bet_', '');\n            const betAmount = spin.bet / 4; // Split bet into quarters\n            \n            if (spin.bets.has(betType)) {\n                spin.bets.set(betType, spin.bets.get(betType) + betAmount);\n            } else {\n                spin.bets.set(betType, betAmount);\n            }\n            \n            const bettingEmbed = createBettingEmbed(spin, interaction.user);\n            const bettingComponents = createBettingComponents();\n            \n            await interaction.editReply({ \n                embeds: [bettingEmbed],\n                components: bettingComponents\n            });\n        }\n        \n    } catch (error) {\n        console.error('Erreur roulette interaction:', error);\n    }\n}\n\n// Roulette number bet handler\nasync function handleRouletteNumberBet(interaction) {\n    const { activeSpins, createBettingEmbed, createBettingComponents } = require('./commands/roulette.js');\n    \n    await interaction.deferUpdate();\n    \n    const userId = interaction.user.id;\n    const spin = activeSpins.get(userId);\n    \n    if (!spin || spin.status !== 'betting') {\n        return;\n    }\n    \n    try {\n        const selectedValue = interaction.values[0];\n        const betAmount = spin.bet / 4; // Split bet into quarters\n        \n        if (spin.bets.has(selectedValue)) {\n            spin.bets.set(selectedValue, spin.bets.get(selectedValue) + betAmount);\n        } else {\n            spin.bets.set(selectedValue, betAmount);\n        }\n        \n        const bettingEmbed = createBettingEmbed(spin, interaction.user);\n        const bettingComponents = createBettingComponents();\n        \n        await interaction.editReply({ \n            embeds: [bettingEmbed],\n            components: bettingComponents\n        });\n        \n    } catch (error) {\n        console.error('Erreur roulette number bet:', error);\n    }\n}\n\n// Casino game quick start handlers\nasync function handleCasinoBlackjack(interaction) {\n    await interaction.deferUpdate();\n    \n    const quickPlayEmbed = new EmbedBuilder()\n        .setColor('#9932cc')\n        .setTitle('üÉè Quick Play Blackjack')\n        .setDescription('Ready to play Blackjack? Use the command `/blackjack <bet>` to start!')\n        .addFields(\n            {\n                name: 'üéØ How to Play',\n                value: '‚Ä¢ Beat the dealer by getting closer to 21 without going over\\n‚Ä¢ Face cards are worth 10, Aces are 1 or 11\\n‚Ä¢ You can Hit, Stand, or Double Down',\n                inline: false\n            },\n            {\n                name: 'üí∞ Example Commands',\n                value: '‚Ä¢ `/blackjack bet:0.01` - Play with 0.01 LTC\\n‚Ä¢ `/blackjack bet:0.1` - Play with 0.1 LTC',\n                inline: false\n            }\n        )\n        .setFooter({ text: 'Good luck at the tables!' })\n        .setTimestamp();\n    \n    await interaction.editReply({ embeds: [quickPlayEmbed] });\n}\n\nasync function handleCasinoRoulette(interaction) {\n    await interaction.deferUpdate();\n    \n    const quickPlayEmbed = new EmbedBuilder()\n        .setColor('#9932cc')\n        .setTitle('üé∞ Quick Play Roulette')\n        .setDescription('Ready to spin the wheel? Use the command `/roulette <bet>` to start!')\n        .addFields(\n            {\n                name: 'üéØ How to Play',\n                value: '‚Ä¢ Choose your bets: numbers (35:1), colors (1:1), even/odd (1:1)\\n‚Ä¢ The ball will land on a number from 0-36\\n‚Ä¢ Multiple bets allowed per spin',\n                inline: false\n            },\n            {\n                name: 'üí∞ Example Commands',\n                value: '‚Ä¢ `/roulette bet:0.01` - Play with 0.01 LTC\\n‚Ä¢ `/roulette bet:0.1` - Play with 0.1 LTC',\n                inline: false\n            }\n        )\n        .setFooter({ text: 'Place your bets!' })\n        .setTimestamp();\n    \n    await interaction.editReply({ embeds: [quickPlayEmbed] });\n}\n\n// Smart monitoring system\nlet monitoringInterval = null;\n\n/**\n * Start smart monitoring for active deposits\n */\nfunction startSmartMonitoring() {\n    // Don't start if already running\n    if (monitoringInterval) return;\n    \n    console.log('üîç D√©marrage de la surveillance des d√©p√¥ts...');\n    \n    // Surveillance automatique toutes les 2 minutes pour respecter les limites API gratuites\n    monitoringInterval = setInterval(async () => {\n        try {\n            const securityManager = require('./utils/securityManager.js');\n            const userProfiles = require('./utils/userProfiles.js');\n            \n            // Get all active deposits\n            const activeDeposits = securityManager.getAllActiveDeposits();\n            \n            if (activeDeposits.length === 0) {\n                console.log('‚ÑπÔ∏è  Aucun d√©p√¥t actif - arr√™t de la surveillance');\n                stopSmartMonitoring();\n                return;\n            }\n            \n            // Check for new deposits\n            const detectedDeposits = await ltcWallet.smartDepositCheck(activeDeposits);\n            \n            // Process detected deposits\n            for (const deposit of detectedDeposits) {\n                try {\n                    // Add deposit to user profile\n                    userProfiles.addDeposit(deposit.userId, deposit.amount, deposit.address);\n                    \n                    // Add to deposited amount for cashout protection\n                    securityManager.addDepositedAmount(deposit.userId, deposit.amount);\n                    \n                    // Mark deposit as completed\n                    securityManager.completeDepositRequest(deposit.userId, deposit.address);\n                    \n                    // Notify user\n                    await notifyUserOfDeposit(deposit);\n                    \n                } catch (error) {\n                    console.error('Erreur traitement d√©p√¥t:', error);\n                }\n            }\n            \n        } catch (error) {\n            console.error('Erreur surveillance intelligente:', error);\n        }\n    }, 120000); // Check every 2 minutes pour respecter les limites BlockCypher gratuit\n}\n\n/**\n * Stop smart monitoring\n */\nfunction stopSmartMonitoring() {\n    if (monitoringInterval) {\n        clearInterval(monitoringInterval);\n        monitoringInterval = null;\n        console.log('üõë Surveillance intelligente arr√™t√©e');\n    }\n}\n\n/**\n * Notify user of detected deposit\n */\nasync function notifyUserOfDeposit(deposit) {\n    try {\n        const user = await client.users.fetch(deposit.userId);\n        \n        if (user) {\n            const depositEmbed = new EmbedBuilder()\n                .setColor('#00ff00')\n                .setTitle('‚úÖ Deposit Confirmed!')\n                .setDescription('Your Litecoin deposit has been confirmed and added to your balance.')\n                .addFields(\n                    {\n                        name: 'üí∞ Deposit Amount',\n                        value: `**${deposit.amount.toFixed(8)} LTC**`,\n                        inline: true\n                    },\n                    {\n                        name: 'üìç Address',\n                        value: `\\`${deposit.address}\\``,\n                        inline: false\n                    },\n                    {\n                        name: 'üé∞ Ready to Play',\n                        value: 'Use `/casino` to start playing!\\n**Note:** You must wager 100% of deposited amount before cashout.',\n                        inline: false\n                    }\n                )\n                .setThumbnail('https://cryptologos.cc/logos/litecoin-ltc-logo.png')\n                .setTimestamp();\n            \n            // Try to send DM\n            try {\n                await user.send({ embeds: [depositEmbed] });\n                console.log(`üí∞ Utilisateur ${user.username} notifi√© du d√©p√¥t de ${deposit.amount} LTC`);\n            } catch (dmError) {\n                console.log(`Impossible d'envoyer un MP √† ${user.username}:`, dmError.message);\n            }\n        }\n    } catch (error) {\n        console.log('Impossible de notifier l\\'utilisateur du d√©p√¥t:', error.message);\n    }\n}\n\n// Export for external use\nmodule.exports = {\n    client,\n    handleAddBalance,\n    handleCreateChannel,\n    startSmartMonitoring,\n    stopSmartMonitoring\n};\n\n// Gestion d'erreurs globales pour √©viter les d√©connexions\nprocess.on('uncaughtException', (error) => {\n    console.error('‚ö†Ô∏è Erreur non g√©r√©e captur√©e:', error);\n    console.log('üîÑ Le bot continue de fonctionner...');\n});\n\nprocess.on('unhandledRejection', (reason, promise) => {\n    console.error('‚ö†Ô∏è Promesse rejet√©e non g√©r√©e:', reason);\n    console.log('üîÑ Le bot continue de fonctionner...');\n});\n\n// Gestion des erreurs Discord\nclient.on('error', (error) => {\n    console.error('‚ö†Ô∏è Erreur client Discord:', error);\n    console.log('üîÑ Tentative de reconnexion...');\n});\n\nclient.on('warn', (info) => {\n    console.warn('‚ö†Ô∏è Avertissement Discord:', info);\n});\n\nclient.on('disconnect', () => {\n    console.log('‚ö†Ô∏è Bot d√©connect√©, tentative de reconnexion...');\n});\n\nclient.on('reconnecting', () => {\n    console.log('üîÑ Reconnexion en cours...');\n});\n\n// Fonction de reconnexion automatique\nasync function startBotWithRetry() {\n    const token = process.env.DISCORD_TOKEN;\n    \n    if (!token) {\n        console.error('‚ùå DISCORD_TOKEN environment variable is required!');\n        process.exit(1);\n    }\n    \n    let retryCount = 0;\n    const maxRetries = 5;\n    \n    while (retryCount < maxRetries) {\n        try {\n            await client.login(token);\n            console.log('‚úÖ Bot connect√© avec succ√®s!');\n            break;\n        } catch (error) {\n            retryCount++;\n            console.error(`‚ùå √âchec de connexion (tentative ${retryCount}/${maxRetries}):`, error.message);\n            \n            if (retryCount < maxRetries) {\n                const delay = retryCount * 5000; // D√©lai croissant: 5s, 10s, 15s...\n                console.log(`‚è≥ Nouvelle tentative dans ${delay/1000}s...`);\n                await new Promise(resolve => setTimeout(resolve, delay));\n            } else {\n                console.error('‚ùå Impossible de se connecter apr√®s plusieurs tentatives');\n                process.exit(1);\n            }\n        }\n    }\n}\n\n// Start the bot if this file is run directly\nif (require.main === module) {\n    startBotWithRetry();\n}","size_bytes":36563},"attached_assets/casino/attached_assets/casino/events/interactionCreate.js":{"content":"const { Events, EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle } = require('discord.js');\n\nmodule.exports = {\n    name: Events.InteractionCreate,\n    async execute(interaction) {\n        // Handle slash commands\n        if (interaction.isChatInputCommand()) {\n            const command = interaction.client.commands.get(interaction.commandName);\n\n            if (!command) {\n                console.error(`‚ùå No command matching ${interaction.commandName} was found.`);\n                return;\n            }\n\n            try {\n                await command.execute(interaction);\n                console.log(`‚úÖ ${interaction.user.username} a utilis√© /${interaction.commandName}`);\n            } catch (error) {\n                console.error(`‚ùå Erreur lors de l'ex√©cution de ${interaction.commandName}:`, error);\n\n                try {\n                    const errorEmbed = new EmbedBuilder()\n                        .setColor('#ff0000')\n                        .setTitle('‚ùå Command Error')\n                        .setDescription('There was an error while executing this command!')\n                        .setTimestamp();\n\n                    if (interaction.replied || interaction.deferred) {\n                        await interaction.followUp({ embeds: [errorEmbed], ephemeral: true });\n                    } else {\n                        await interaction.reply({ embeds: [errorEmbed], ephemeral: true });\n                    }\n                } catch (replyError) {\n                    console.error('‚ö†Ô∏è Impossible de r√©pondre √† l\\'interaction:', replyError.message);\n                }\n            }\n        }\n\n        // Handle button interactions\n        if (interaction.isButton()) {\n            try {\n                // Check for panel interactions\n                if (interaction.customId.startsWith('panel_')) {\n                    await handlePanelInteraction(interaction);\n                } else {\n                    await handleButtonInteraction(interaction);\n                }\n            } catch (error) {\n                console.error('‚ùå Erreur d\\'interaction bouton:', error);\n\n                try {\n                    const errorEmbed = new EmbedBuilder()\n                        .setColor('#ff0000')\n                        .setTitle('‚ùå Error')\n                        .setDescription('There was an error processing your request!')\n                        .setTimestamp();\n\n                    if (interaction.replied || interaction.deferred) {\n                        await interaction.followUp({ embeds: [errorEmbed], ephemeral: true });\n                    } else {\n                        await interaction.reply({ embeds: [errorEmbed], ephemeral: true });\n                    }\n                } catch (replyError) {\n                    console.error('‚ö†Ô∏è Impossible de r√©pondre √† l\\'interaction bouton:', replyError.message);\n                }\n            }\n        }\n    },\n};\n\n/**\n * Handle button interactions\n */\nasync function handleButtonInteraction(interaction) {\n    const { customId } = interaction;\n    \n    switch (customId) {\n        case 'add_balance':\n            await handleAddBalance(interaction);\n            break;\n        case 'view_profile':\n            await handleViewProfile(interaction);\n            break;\n        case 'leaderboard':\n            await handleLeaderboard(interaction);\n            break;\n        case 'create_channel':\n            await handleCreateChannel(interaction);\n            break;\n        case 'blackjack':\n        case 'roulette':\n        case 'slots':\n            await handleGameNotAvailable(interaction);\n            break;\n        default:\n            console.log(`Interaction bouton inconnue: ${customId}`);\n    }\n}\n\n/**\n * Handle Add Balance button\n */\nasync function handleAddBalance(interaction) {\n    // Avoid duplicate calls from panel interactions\n    if (interaction.customId === 'panel_add_balance') {\n        return; // This is handled by handlePanelInteraction\n    }\n    \n    const { handleAddBalance } = require('../discord-bot.js');\n    await handleAddBalance(interaction);\n}\n\n/**\n * Handle View Profile button\n */\nasync function handleViewProfile(interaction) {\n    // Avoid duplicate calls from panel interactions\n    if (interaction.customId === 'panel_view_profile') {\n        return; // This is handled by handlePanelInteraction\n    }\n    \n    await interaction.deferReply({ ephemeral: true });\n    \n    const profileCommand = require('../commands/profile.js');\n    await profileCommand.execute(interaction);\n}\n\n/**\n * Handle Leaderboard button\n */\nasync function handleLeaderboard(interaction) {\n    await interaction.deferReply({ ephemeral: true });\n    \n    try {\n        const userProfiles = require('../utils/userProfiles.js');\n        const { formatLTC } = require('../utils/formatters.js');\n        const leaderboard = userProfiles.getLeaderboard('balance', 10);\n        \n        if (leaderboard.length === 0) {\n            const emptyEmbed = new EmbedBuilder()\n                .setColor('#ffaa00')\n                .setTitle('üèÜ Casino Leaderboard')\n                .setDescription('No players yet! Be the first to add balance.')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [emptyEmbed] });\n            return;\n        }\n        \n        let leaderboardText = '';\n        const medals = ['ü•á', 'ü•à', 'ü•â'];\n        \n        for (let i = 0; i < leaderboard.length; i++) {\n            const user = leaderboard[i];\n            const medal = i < 3 ? medals[i] : `${i + 1}.`;\n            \n            try {\n                const discordUser = await interaction.client.users.fetch(user.userId);\n                leaderboardText += `${medal} **${discordUser.username}** - ${formatLTC(user.value)} LTC\\n`;\n            } catch (error) {\n                leaderboardText += `${medal} **Unknown User** - ${formatLTC(user.value)} LTC\\n`;\n            }\n        }\n        \n        const leaderboardEmbed = new EmbedBuilder()\n            .setColor('#ffd700')\n            .setTitle('üèÜ Casino Leaderboard')\n            .setDescription('**Top Players by Balance**\\n\\n' + leaderboardText)\n            .setThumbnail('https://cryptologos.cc/logos/litecoin-ltc-logo.png')\n            .setFooter({ text: 'Rankings update in real-time' })\n            .setTimestamp();\n        \n        await interaction.editReply({ embeds: [leaderboardEmbed] });\n        \n    } catch (error) {\n        console.error('Leaderboard error:', error);\n        \n        const errorEmbed = new EmbedBuilder()\n            .setColor('#ff0000')\n            .setTitle('‚ùå Error')\n            .setDescription('Failed to load leaderboard. Please try again.')\n            .setTimestamp();\n        \n        await interaction.editReply({ embeds: [errorEmbed] });\n    }\n}\n\n/**\n * Handle Create Channel button\n */\nasync function handleCreateChannel(interaction) {\n    const { handleCreateChannel } = require('../discord-bot.js');\n    await handleCreateChannel(interaction);\n}\n\n/**\n * Handle panel interactions (creates tickets)\n */\nasync function handlePanelInteraction(interaction) {\n    // Check if interaction is too old\n    const interactionAge = Date.now() - interaction.createdTimestamp;\n    if (interactionAge > 10 * 60 * 1000) {\n        console.log('Interaction trop ancienne, ignor√©e');\n        return;\n    }\n    \n    const ticketManager = require('../utils/ticketManager.js');\n    const panelManager = require('../utils/panelManager.js');\n    \n    const { customId } = interaction;\n    \n    // Determine ticket type based on button\n    let ticketType = 'general';\n    let actionName = 'Casino';\n    \n    if (customId === 'panel_add_balance') {\n        ticketType = 'balance';\n        actionName = 'Add Balance';\n    } else if (customId === 'panel_view_profile') {\n        ticketType = 'profile';\n        actionName = 'Profile';\n    }\n    \n    await interaction.deferReply({ ephemeral: true });\n    \n    try {\n        // Get panel configuration for ticket category\n        const panelConfig = panelManager.getPanelConfig('casinoPanel');\n        const categoryId = panelConfig?.ticketCategory;\n        const staffRoleId = panelConfig?.staffRole;\n        \n        // Create ticket\n        const result = await ticketManager.createTicket(\n            interaction.guild,\n            interaction.user,\n            categoryId,\n            staffRoleId,\n            ticketType\n        );\n        \n        if (result.success) {\n            const successEmbed = new EmbedBuilder()\n                .setColor('#00ff00')\n                .setTitle('‚úÖ Private Channel Created')\n                .setDescription(`Your private ${actionName.toLowerCase()} channel has been created!`)\n                .addFields({\n                    name: 'üé´ Your Channel',\n                    value: `${result.channel}`,\n                    inline: false\n                })\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [successEmbed] });\n            \n            // Send welcome message in ticket\n            await sendTicketWelcome(result.channel, interaction.user, ticketType);\n            \n        } else if (result.error === 'existing') {\n            const existingEmbed = new EmbedBuilder()\n                .setColor('#ffaa00')\n                .setTitle('‚ö†Ô∏è Channel Already Exists')\n                .setDescription(`You already have a private ${actionName.toLowerCase()} channel!`)\n                .addFields({\n                    name: 'üé´ Your Existing Channel',\n                    value: `${result.channel}`,\n                    inline: false\n                })\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [existingEmbed] });\n            \n        } else {\n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Failed to Create Channel')\n                .setDescription('Unable to create your private channel. Please contact staff.')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n        \n    } catch (error) {\n        console.error('Erreur panel interaction:', error);\n        \n        const errorEmbed = new EmbedBuilder()\n            .setColor('#ff0000')\n            .setTitle('‚ùå Error')\n            .setDescription('An error occurred while processing your request.')\n            .setTimestamp();\n        \n        await interaction.editReply({ embeds: [errorEmbed] });\n    }\n}\n\n/**\n * Send welcome message in ticket channel\n */\nasync function sendTicketWelcome(channel, user, ticketType) {\n    try {\n        let welcomeEmbed;\n        \n        if (ticketType === 'balance') {\n            const { handleAddBalance } = require('../discord-bot.js');\n            \n            welcomeEmbed = new EmbedBuilder()\n                .setColor('#00ff00')\n                .setTitle('üí∞ Private Balance Channel')\n                .setDescription(`Welcome ${user}! This is your private channel for balance operations.`)\n                .addFields(\n                    {\n                        name: 'üìã Available Actions',\n                        value: '‚Ä¢ Click the button below to generate a deposit address\\n‚Ä¢ Check your balance with commands\\n‚Ä¢ Safe and private environment',\n                        inline: false\n                    }\n                )\n                .setThumbnail(user.displayAvatarURL())\n                .setTimestamp();\n            \n            const balanceButton = new ActionRowBuilder()\n                .addComponents(\n                    new ButtonBuilder()\n                        .setCustomId('add_balance')\n                        .setLabel('üí∞ Generate Deposit Address')\n                        .setStyle(ButtonStyle.Success)\n                        .setEmoji('üí∞')\n                );\n            \n            await channel.send({ \n                embeds: [welcomeEmbed],\n                components: [balanceButton]\n            });\n            \n        } else if (ticketType === 'profile') {\n            welcomeEmbed = new EmbedBuilder()\n                .setColor('#0099ff')\n                .setTitle('üë§ Private Profile Channel')\n                .setDescription(`Welcome ${user}! This is your private channel for profile management.`)\n                .addFields(\n                    {\n                        name: 'üìã Available Actions',\n                        value: '‚Ä¢ Use `/profile` to view your statistics\\n‚Ä¢ Use `/balance` to check your funds\\n‚Ä¢ Use `/givebal` to transfer to other users',\n                        inline: false\n                    }\n                )\n                .setThumbnail(user.displayAvatarURL())\n                .setTimestamp();\n            \n            await channel.send({ embeds: [welcomeEmbed] });\n            \n        } else {\n            welcomeEmbed = new EmbedBuilder()\n                .setColor('#f7931a')\n                .setTitle('üé∞ Private Casino Channel')\n                .setDescription(`Welcome ${user}! This is your private casino session.`)\n                .addFields(\n                    {\n                        name: 'üéÆ Available Commands',\n                        value: '‚Ä¢ `/profile` - View your profile\\n‚Ä¢ `/balance` - Check balance\\n‚Ä¢ `/casino` - Access main panel\\n‚Ä¢ `/convert-eur-usd` - Currency converter',\n                        inline: false\n                    }\n                )\n                .setThumbnail(user.displayAvatarURL())\n                .setTimestamp();\n            \n            await channel.send({ embeds: [welcomeEmbed] });\n        }\n        \n    } catch (error) {\n        console.error('Erreur envoi welcome message:', error);\n    }\n}\n\n/**\n * Handle game buttons (not yet implemented)\n */\nasync function handleGameNotAvailable(interaction) {\n    const gameNames = {\n        'blackjack': 'üÉè Blackjack',\n        'roulette': 'üé≤ Roulette',\n        'slots': 'üé∞ Slots'\n    };\n    \n    const gameName = gameNames[interaction.customId] || 'Game';\n    \n    const comingSoonEmbed = new EmbedBuilder()\n        .setColor('#ffaa00')\n        .setTitle('üöß Coming Soon!')\n        .setDescription(`${gameName} is currently under development and will be available soon!`)\n        .addFields({\n            name: 'üéÆ Available Features',\n            value: '‚Ä¢ Balance management\\n‚Ä¢ Currency conversion\\n‚Ä¢ Deposit/withdrawal system\\n‚Ä¢ User profiles',\n            inline: false\n        })\n        .setFooter({ text: 'Stay tuned for exciting casino games!' })\n        .setTimestamp();\n    \n    await interaction.reply({ embeds: [comingSoonEmbed], ephemeral: true });\n}","size_bytes":14699},"attached_assets/casino/attached_assets/casino/events/ready.js":{"content":"const { Events } = require('discord.js');\n\nmodule.exports = {\n    name: Events.ClientReady,\n    once: true,\n    execute(client) {\n        console.log(`üé∞ Bot Casino Discord pr√™t! Connect√© en tant que ${client.user.tag}`);\n        console.log(`üîó Connect√© √† ${client.guilds.cache.size} serveur(s)`);\n        console.log(`üë• Au service de ${client.users.cache.size} utilisateur(s)`);\n        \n        // Set bot status\n        client.user.setActivity('üé∞ Litecoin Casino | /casino', { type: 'PLAYING' });\n        \n        // Initialize smart monitoring if there are active deposits\n        checkAndStartSmartMonitoring(client);\n    },\n};\n\n/**\n * Check for active deposits and start smart monitoring if needed\n */\nfunction checkAndStartSmartMonitoring(client) {\n    const securityManager = require('../utils/securityManager.js');\n    const { startSmartMonitoring } = require('../discord-bot.js');\n    \n    // Check if there are any active deposits\n    const activeDeposits = securityManager.getAllActiveDeposits();\n    \n    if (activeDeposits.length > 0) {\n        console.log(`üîç ${activeDeposits.length} d√©p√¥t(s) actif(s) trouv√©(s) - d√©marrage de la surveillance intelligente`);\n        startSmartMonitoring();\n    } else {\n        console.log('‚ÑπÔ∏è  Aucun d√©p√¥t actif trouv√© - la surveillance d√©marrera quand n√©cessaire');\n    }\n}","size_bytes":1355},"attached_assets/casino/attached_assets/casino/index.js":{"content":"","size_bytes":0},"attached_assets/casino/attached_assets/casino/litecoin-casino-bot.js":{"content":"const fs = require('fs');\nconst litecore = require('litecore-lib');\nconst litecoinDirect = require('./utils/litecoinDirect.js');\n\n// Configuration pour connexion directe (pas d'API key n√©cessaire)\nconst NETWORK = 'ltc'; // Litecoin mainnet\n\n// File to store generated addresses\nconst ADDRESSES_FILE = 'addresses.json';\n\n/**\n * Load saved addresses from JSON file\n * @returns {Array} List of addresses with their private keys\n */\nfunction loadAddresses() {\n    try {\n        if (fs.existsSync(ADDRESSES_FILE)) {\n            const data = fs.readFileSync(ADDRESSES_FILE, 'utf8');\n            return JSON.parse(data);\n        }\n    } catch (error) {\n        console.error('Error loading addresses:', error.message);\n    }\n    return [];\n}\n\n/**\n * Save addresses to JSON file\n * @param {Array} addresses - List of addresses to save\n */\nfunction saveAddresses(addresses) {\n    try {\n        fs.writeFileSync(ADDRESSES_FILE, JSON.stringify(addresses, null, 2));\n        console.log(`‚úÖ Addresses saved to ${ADDRESSES_FILE}`);\n    } catch (error) {\n        console.error('Error saving addresses:', error.message);\n    }\n}\n\n/**\n * Generate a new Litecoin address with its private key\n * This function uses litecore-lib to create a private key/public address pair\n * Perfect for later integration into a Discord bot with games like blackjack/roulette\n * @returns {Object} Object containing the address and private key\n */\nfunction generateAddress() {\n    try {\n        // Generate a new random private key\n        const privateKey = new litecore.PrivateKey();\n        \n        // Create the corresponding public address\n        const address = privateKey.toAddress();\n        \n        const newAddress = {\n            address: address.toString(),\n            privateKey: privateKey.toString(),\n            createdAt: new Date().toISOString(),\n            balance: 0 // Will be updated during checks\n        };\n        \n        // Load existing addresses\n        const addresses = loadAddresses();\n        \n        // Add the new address\n        addresses.push(newAddress);\n        \n        // Save\n        saveAddresses(addresses);\n        \n        console.log(`üîë New address generated: ${newAddress.address}`);\n        return newAddress;\n        \n    } catch (error) {\n        console.error('Error generating address:', error.message);\n        return null;\n    }\n}\n\n/**\n * V√©rifie le solde d'une adresse via connexion directe (sans API key)\n * @param {string} address - L'adresse Litecoin √† v√©rifier\n * @returns {Promise<number>} Le solde en LTC\n */\nasync function getAddressBalance(address) {\n    try {\n        return await litecoinDirect.getAddressBalance(address, false); // false = mainnet\n    } catch (error) {\n        console.error(`‚ùå Erreur v√©rification pour ${address.substring(0, 10)}...:`, error.message);\n        return 0;\n    }\n}\n\n/**\n * V√©rifie automatiquement les d√©p√¥ts sur toutes les adresses\n * Cette fonction peut √™tre appel√©e p√©riodiquement pour d√©tecter les nouveaux d√©p√¥ts\n * Id√©al pour un bot casino qui doit cr√©diter automatiquement les joueurs\n */\nasync function checkDeposits() {\n    const addresses = loadAddresses();\n    \n    if (addresses.length === 0) {\n        console.log('‚ÑπÔ∏è  Aucune adresse √† v√©rifier');\n        return;\n    }\n    \n    console.log(`üîç V√©rification de ${addresses.length} adresse(s)...`);\n    \n    for (let i = 0; i < addresses.length; i++) {\n        const addressData = addresses[i];\n        console.log(`üîç V√©rification ${i + 1}/${addresses.length}: ${addressData.address.substring(0, 10)}...`);\n        \n        const currentBalance = await getAddressBalance(addressData.address);\n        \n        // Check if there was a new deposit\n        if (currentBalance > addressData.balance) {\n            const deposit = currentBalance - addressData.balance;\n            console.log(`üí∞ Deposit detected: ${deposit} LTC on address ${addressData.address}`);\n            \n            // Update balance\n            addresses[i].balance = currentBalance;\n            addresses[i].lastChecked = new Date().toISOString();\n        } else if (currentBalance === addressData.balance) {\n            console.log(`‚ÑπÔ∏è  Aucun nouveau d√©p√¥t pour ${addressData.address.substring(0, 10)}...`);\n        }\n        \n        // D√©lai de 5 secondes pour √™tre respectueux envers les explorateurs publics\n        await new Promise(resolve => setTimeout(resolve, 5000));\n    }\n    \n    // Sauvegarde des soldes mis √† jour\n    saveAddresses(addresses);\n}\n\n/**\n * Obtient les UTXOs (unspent outputs) d'une adresse via connexion directe\n * N√©cessaire pour construire des transactions de retrait\n * @param {string} address - L'adresse Litecoin\n * @returns {Promise<Array>} Liste des UTXOs\n */\nasync function getAddressUTXOs(address) {\n    try {\n        return await litecoinDirect.getAddressUTXOs(address, false); // false = mainnet\n    } catch (error) {\n        console.error('Erreur UTXO:', error.message);\n        return [];\n    }\n}\n\n/**\n * Diffuse une transaction sur le r√©seau Litecoin via connexion directe\n * @param {string} txHex - Transaction s√©rialis√©e en hexad√©cimal\n * @returns {Promise<string|null>} L'ID de la transaction ou null en cas d'erreur\n */\nasync function broadcastTransaction(txHex) {\n    try {\n        return await litecoinDirect.broadcastTransaction(txHex, false); // false = mainnet\n    } catch (error) {\n        console.error('Erreur de diffusion:', error.message);\n        return null;\n    }\n}\n\n/**\n * Effectue un retrait depuis une adresse vers une destination\n * Fonction principale pour les retraits du casino - peut √™tre int√©gr√©e facilement\n * dans un bot Discord pour permettre aux joueurs de retirer leurs gains\n * @param {string} fromAddress - Adresse source (doit √™tre dans notre fichier)\n * @param {string} toAddress - Adresse de destination\n * @param {number} amount - Montant en LTC √† envoyer\n * @param {number} feeRate - Frais en satoshis par byte (d√©faut: 1000 sat/kb = 1 sat/byte)\n * @returns {Promise<string|null>} L'ID de la transaction ou null en cas d'erreur\n */\nasync function withdraw(fromAddress, toAddress, amount, feeRate = 1) {\n    try {\n        // Recherche de la cl√© priv√©e correspondante\n        const addresses = loadAddresses();\n        const addressData = addresses.find(addr => addr.address === fromAddress);\n        \n        if (!addressData) {\n            console.error(`‚ùå Adresse ${fromAddress} non trouv√©e dans notre portefeuille`);\n            return null;\n        }\n        \n        console.log(`üè¶ Pr√©paration du retrait de ${amount} LTC depuis ${fromAddress} vers ${toAddress}`);\n        \n        // R√©cup√©ration des UTXOs\n        const utxos = await getAddressUTXOs(fromAddress);\n        if (utxos.length === 0) {\n            console.error('‚ùå Aucun UTXO disponible pour cette adresse');\n            return null;\n        }\n        \n        // Conversion du montant en satoshis\n        const amountSatoshis = Math.round(amount * 100000000);\n        \n        // Cr√©ation de la transaction\n        const transaction = new litecore.Transaction();\n        \n        // Ajout des inputs (UTXOs) avec script P2PKH standard\n        let totalInputs = 0;\n        for (const utxo of utxos) {\n            // G√©n√©ration du script P2PKH standard pour l'adresse\n            const address = litecore.Address.fromString(fromAddress);\n            const script = litecore.Script.buildPublicKeyHashOut(address);\n            \n            transaction.from({\n                txId: utxo.txid,\n                outputIndex: utxo.outputIndex,\n                address: fromAddress,\n                script: script.toHex(),\n                satoshis: utxo.satoshis\n            });\n            totalInputs += utxo.satoshis;\n        }\n        \n        // Estimation des frais (taille approximative * fee rate)\n        const estimatedSize = 180 + (utxos.length * 180); // Estimation basique\n        const fees = estimatedSize * feeRate;\n        \n        // V√©rification que nous avons assez de fonds\n        if (totalInputs < amountSatoshis + fees) {\n            console.error(`‚ùå Fonds insuffisants. Disponible: ${totalInputs/100000000} LTC, Requis: ${(amountSatoshis + fees)/100000000} LTC`);\n            return null;\n        }\n        \n        // Ajout de l'output principal (destination)\n        transaction.to(toAddress, amountSatoshis);\n        \n        // Calcul et ajout du change (monnaie rendue)\n        const change = totalInputs - amountSatoshis - fees;\n        if (change > 5460) { // Dust limit pour Litecoin\n            transaction.to(fromAddress, change);\n        }\n        \n        // Signature de la transaction avec la cl√© priv√©e\n        const privateKey = new litecore.PrivateKey(addressData.privateKey);\n        transaction.sign(privateKey);\n        \n        // S√©rialisation de la transaction\n        const txHex = transaction.serialize();\n        console.log(`üì§ Transaction cr√©√©e (${txHex.length/2} bytes): ${txHex.substring(0, 64)}...`);\n        \n        // Diffusion sur le r√©seau\n        const txid = await broadcastTransaction(txHex);\n        \n        if (txid) {\n            // Mise √† jour du solde local (approximatif)\n            const addressIndex = addresses.findIndex(addr => addr.address === fromAddress);\n            if (addressIndex !== -1) {\n                addresses[addressIndex].balance -= amount;\n                addresses[addressIndex].lastWithdrawal = {\n                    amount: amount,\n                    to: toAddress,\n                    txid: txid,\n                    timestamp: new Date().toISOString()\n                };\n                saveAddresses(addresses);\n            }\n        }\n        \n        return txid;\n        \n    } catch (error) {\n        console.error('‚ùå Erreur lors du retrait:', error.message);\n        return null;\n    }\n}\n\n/**\n * Affiche le statut de toutes les adresses\n */\nfunction showWalletStatus() {\n    const addresses = loadAddresses();\n    \n    if (addresses.length === 0) {\n        console.log('üíº Portefeuille vide - aucune adresse g√©n√©r√©e');\n        return;\n    }\n    \n    console.log('\\nüíº === STATUT DU PORTEFEUILLE ===');\n    let totalBalance = 0;\n    \n    addresses.forEach((addr, index) => {\n        console.log(`\\n${index + 1}. Adresse: ${addr.address}`);\n        console.log(`   Solde: ${addr.balance} LTC`);\n        console.log(`   Cr√©√©e: ${new Date(addr.createdAt).toLocaleString()}`);\n        if (addr.lastChecked) {\n            console.log(`   Derni√®re v√©rif: ${new Date(addr.lastChecked).toLocaleString()}`);\n        }\n        totalBalance += addr.balance;\n    });\n    \n    console.log(`\\nüí∞ SOLDE TOTAL: ${totalBalance} LTC`);\n    console.log('===================================\\n');\n}\n\n/**\n * Smart deposit monitoring - only check active deposit requests\n * Called by Discord bot when needed\n */\nasync function smartDepositCheck(activeAddresses = []) {\n    if (activeAddresses.length === 0) {\n        console.log('‚ÑπÔ∏è  No active deposit requests to monitor');\n        return [];\n    }\n    \n    console.log(`üîç Smart monitoring ${activeAddresses.length} active deposit(s)...`);\n    const detectedDeposits = [];\n    \n    for (const addressData of activeAddresses) {\n        const currentBalance = await getAddressBalance(addressData.address);\n        \n        // Check if there was a new deposit\n        if (currentBalance > addressData.lastKnownBalance) {\n            const depositAmount = currentBalance - addressData.lastKnownBalance;\n            \n            detectedDeposits.push({\n                address: addressData.address,\n                amount: depositAmount,\n                newBalance: currentBalance,\n                userId: addressData.userId\n            });\n            \n            console.log(`üí∞ Deposit detected: ${depositAmount} LTC on address ${addressData.address}`);\n        }\n        \n        // Small delay to avoid API overload\n        await new Promise(resolve => setTimeout(resolve, 1000));\n    }\n    \n    return detectedDeposits;\n}\n\n/**\n * Initialize wallet system (no automatic monitoring)\n */\nfunction initializeWallet() {\n    console.log('üé∞ === LITECOIN CASINO WALLET SYSTEM ===');\n    console.log('‚úÖ Wallet system initialized - Smart monitoring mode');\n    console.log('üìã AVAILABLE FUNCTIONS:');\n    console.log('- generateAddress(): Create new address');\n    console.log('- smartDepositCheck(): Check active deposits only');\n    console.log('- withdraw(from, to, amount): Process withdrawal');\n    console.log('- showWalletStatus(): Display wallet status');\n}\n\n// Point d'entr√©e - initialise le syst√®me\nif (require.main === module) {\n    initializeWallet();\n}\n\n// Export des fonctions pour utilisation externe (bot Discord, etc.)\nmodule.exports = {\n    generateAddress,\n    checkDeposits,\n    smartDepositCheck,\n    withdraw,\n    showWalletStatus,\n    loadAddresses,\n    getAddressBalance,\n    initializeWallet\n};","size_bytes":12903},"attached_assets/casino/attached_assets/casino/replit.md":{"content":"# Overview\n\nThis project is a complete Litecoin casino Discord bot system built with Node.js and Discord.js v14+. The application provides full wallet management including address generation, deposit monitoring, withdrawal capabilities, and a complete Discord bot interface with slash commands, interactive panels, and real-time notifications. The system integrates BlockCypher API for fast blockchain interactions and litecore-lib for cryptographic operations. The bot features automatic deposit detection, balance management, currency conversion, user profiles, and is designed as a foundation for casino gaming features like blackjack and roulette.\n\n# User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n# System Architecture\n\n## Core Application Structure\nThe application follows a modular Discord bot architecture with separate command handlers, event listeners, and utility modules. The system includes both a standalone Litecoin wallet system and a complete Discord bot integration with slash commands, interactive panels, and real-time user notifications.\n\n## Discord Bot Architecture\n- **Main Bot File**: `discord-bot.js` - Central Discord client and interaction handling\n- **Commands System**: Modular slash commands in `/commands/` directory\n- **Events System**: Discord event handlers in `/events/` directory\n- **User Profiles**: Complete user management system with balance tracking\n- **Currency Conversion**: Real-time EUR/USD exchange rates with external APIs\n\n## Address Management System\n- **Address Generation**: Uses litecore-lib to create cryptographically secure Litecoin address pairs\n- **Data Persistence**: JSON file-based storage system for addresses and private keys\n- **Address Structure**: Each address record contains the public address, private key, creation timestamp, and balance tracking\n\n## Blockchain Integration\n- **Direct Library Integration**: Uses litecore-lib and direct blockchain explorers, eliminating API rate limits and costs\n- **Network Configuration**: Configured for Litecoin mainnet (LTC) operations\n- **Real-time Monitoring**: 2-minute interval deposit detection with Discord notifications\n- **No External API Dependencies**: Completely self-contained system without third-party API costs\n\n## File System Design\n- **Configuration Management**: Environment-based API key handling with fallback defaults\n- **Data Storage**: JSON-based persistence with error handling and data validation\n- **Modular Functions**: Clear separation between address generation, loading, and saving operations\n\n## Security Considerations\n- Private keys are generated using cryptographically secure random number generation\n- Local file storage for sensitive data (suitable for development, would need enhancement for production)\n- API key configuration system for secure third-party service integration\n\n# External Dependencies\n\n## Discord Integration\n- **discord.js**: Discord API wrapper v14+ for bot functionality, slash commands, and interactions\n- **Discord Bot Features**: Slash commands, button interactions, embed messages, and real-time notifications\n\n## Blockchain Libraries\n- **litecore-lib**: Core Litecoin cryptographic library for address generation and private key management\n- **Direct Blockchain Integration**: Direct connection to blockchain explorers without paid APIs\n- **No Rate Limits**: Unlimited transactions and monitoring without API restrictions\n\n## HTTP and Utility Libraries  \n- **axios**: HTTP client for API communications with blockchain and currency services\n- **dotenv**: Environment variable management for secure API key storage\n- **Node.js fs module**: File system operations for local data persistence\n\n## Currency APIs\n- **ExchangeRate-API**: Real-time currency conversion for EUR/USD pairs\n- **CoinGecko API**: Cryptocurrency price data for Litecoin USD/EUR prices\n\n## Development Dependencies\n- **@types/node**: TypeScript definitions for Node.js development support\n\n## Implemented Features\nThe Discord bot includes complete casino functionality with:\n\n### Core Casino System\n- User profiles with balance tracking and recovery systems\n- Complete deposit detection and monitoring with direct blockchain integration\n- Currency conversion between EUR/USD with real-time exchange rates\n- Secure password protection system with recovery keys\n- Enhanced balance display (shows \"0\" instead of \"0.00000000\" for zero balances)\n\n### Panel and Ticket Management System\n- **Panel Management**: Channel-specific casino panels that can be configured with `/setpanel`\n- **Ticket System**: Private ticket channels created when users interact with panels (similar to TicketTool)\n- **Whitelist System**: Server whitelisting with `/addwhitelist` command for panel management\n- **Smart Interactions**: Panel buttons (`panel_add_balance`, `panel_view_profile`) create private channels for users\n\n### Advanced Features\n- **Rate Limit Protection**: Smart API rate limiting with 8-second delays and proper 429 error handling\n- **French Console Logs**: Console output in French while maintaining English user interface\n- **Robust Error Handling**: Automatic reconnection system preventing bot disconnections\n- **Private Channel Management**: Automatic ticket cleanup and category organization\n- **Active Deposit Management**: `/stopallactives` command to manage monitoring\n\n### Available Slash Commands (20 total)\n- `/balance`, `/profile`, `/casino` - Core user functions\n- `/setpassword`, `/changepassword`, `/recoverykey` - Security system  \n- `/givebal`, `/cashout` - Balance management\n- `/setpanel`, `/addwhitelist` - Panel and server management\n- `/convert-eur-usd`, `/convert-usd-eur` - Currency tools\n- `/enable`, `/stopallactives` - Monitoring controls\n- `/testgamble`, `/resetrecovery` - Testing and recovery\n- `/blackjack`, `/roulette` - Casino games\n- `/setlogbal`, `/setloggamble` - Logging configuration\n\n### Casino Games System (New!)\n- **Blackjack Game**: Complete blackjack implementation with hit, stand, and double down mechanics\n- **Roulette Game**: Full European roulette with number bets (35:1), color bets (1:1), and even/odd bets (1:1)\n- **Game State Management**: Active games tracking with 2-minute auto-timeout\n- **Interactive Controls**: Button-based gameplay with real-time updates\n- **Comprehensive Logging**: All game results logged to configured channels\n\n### Enhanced Deposit System\n- **Always New Addresses**: Each deposit request generates a completely new address\n- **Enhanced Channel Management**: Private channels with auto-close after 20 minutes\n- **Non-Ephemeral Messages**: Deposit addresses sent as normal messages for easy copying\n- **Staff Ping Instructions**: Clear 20-minute timeout warnings with staff ping guidance\n- **Advanced Logging**: Comprehensive logging system for all deposit and gambling activities\n\n### Logging System (New!)\n- **Balance Log Channel**: Configure with `/setlogbal` for deposit confirmations and address generations\n- **Gambling Log Channel**: Configure with `/setloggamble` for game results and big wins\n- **Automated Big Win Detection**: Special notifications for wins 5x or larger\n- **Channel Auto-Management**: Automatic ticket cleanup and category organization\n\nThe system is now production-ready with complete casino functionality including blackjack and roulette games, enhanced user experience, and comprehensive logging systems.","size_bytes":7377},"attached_assets/casino/attached_assets/casino/utils/currencyConverter.js":{"content":"const axios = require('axios');\n\n// Free currency conversion API (you can change this to your preferred service)\nconst API_BASE_URL = 'https://api.exchangerate-api.com/v4/latest';\n\n/**\n * Get exchange rate between two currencies\n * @param {string} from - Source currency (e.g., 'EUR')\n * @param {string} to - Target currency (e.g., 'USD')\n * @returns {Promise<number>} Exchange rate\n */\nasync function getExchangeRate(from, to) {\n    try {\n        const response = await axios.get(`${API_BASE_URL}/${from}`, {\n            timeout: 5000\n        });\n        \n        if (response.data && response.data.rates && response.data.rates[to]) {\n            return response.data.rates[to];\n        } else {\n            throw new Error(`Exchange rate not found for ${from} to ${to}`);\n        }\n    } catch (error) {\n        console.error('Currency API error:', error.message);\n        throw new Error('Failed to fetch exchange rate. Please try again later.');\n    }\n}\n\n/**\n * Convert amount from one currency to another\n * @param {number} amount - Amount to convert\n * @param {string} from - Source currency\n * @param {string} to - Target currency\n * @returns {Promise<Object>} Conversion result\n */\nasync function convertCurrency(amount, from, to) {\n    if (amount <= 0) {\n        throw new Error('Amount must be greater than 0');\n    }\n    \n    const rate = await getExchangeRate(from, to);\n    const convertedAmount = amount * rate;\n    \n    return {\n        originalAmount: amount,\n        convertedAmount: parseFloat(convertedAmount.toFixed(2)),\n        fromCurrency: from.toUpperCase(),\n        toCurrency: to.toUpperCase(),\n        exchangeRate: rate,\n        timestamp: new Date().toISOString()\n    };\n}\n\n/**\n * Get multiple currency rates for display\n * @param {string} baseCurrency - Base currency (e.g., 'USD')\n * @returns {Promise<Object>} Multiple exchange rates\n */\nasync function getMultipleRates(baseCurrency = 'USD') {\n    try {\n        const response = await axios.get(`${API_BASE_URL}/${baseCurrency}`, {\n            timeout: 5000\n        });\n        \n        if (response.data && response.data.rates) {\n            return {\n                base: baseCurrency.toUpperCase(),\n                rates: response.data.rates,\n                lastUpdated: response.data.date || new Date().toISOString().split('T')[0]\n            };\n        } else {\n            throw new Error('Failed to fetch exchange rates');\n        }\n    } catch (error) {\n        console.error('Currency API error:', error.message);\n        throw new Error('Failed to fetch exchange rates. Please try again later.');\n    }\n}\n\n/**\n * Format currency amount for display\n * @param {number} amount - Amount to format\n * @param {string} currency - Currency code\n * @returns {string} Formatted currency string\n */\nfunction formatCurrency(amount, currency) {\n    const symbols = {\n        'USD': '$',\n        'EUR': '‚Ç¨',\n        'GBP': '¬£',\n        'JPY': '¬•',\n        'BTC': '‚Çø',\n        'LTC': '≈Å'\n    };\n    \n    const symbol = symbols[currency.toUpperCase()] || currency.toUpperCase();\n    \n    if (currency.toUpperCase() === 'JPY') {\n        return `${symbol}${Math.round(amount).toLocaleString()}`;\n    }\n    \n    return `${symbol}${amount.toLocaleString('en-US', { \n        minimumFractionDigits: 2, \n        maximumFractionDigits: 2 \n    })}`;\n}\n\n/**\n * Get current Litecoin price in specified currency\n * @param {string} currency - Target currency (default: USD)\n * @returns {Promise<Object>} LTC price data\n */\nasync function getLitecoinPrice(currency = 'USD') {\n    try {\n        // Using CoinGecko API for crypto prices (free tier)\n        const response = await axios.get(`https://api.coingecko.com/api/v3/simple/price?ids=litecoin&vs_currencies=${currency.toLowerCase()}`, {\n            timeout: 5000\n        });\n        \n        if (response.data && response.data.litecoin) {\n            const price = response.data.litecoin[currency.toLowerCase()];\n            return {\n                price: price,\n                currency: currency.toUpperCase(),\n                symbol: 'LTC',\n                timestamp: new Date().toISOString()\n            };\n        } else {\n            throw new Error('Litecoin price not found');\n        }\n    } catch (error) {\n        console.error('Crypto price API error:', error.message);\n        throw new Error('Failed to fetch Litecoin price. Please try again later.');\n    }\n}\n\nmodule.exports = {\n    getExchangeRate,\n    convertCurrency,\n    getMultipleRates,\n    formatCurrency,\n    getLitecoinPrice\n};","size_bytes":4527},"attached_assets/casino/attached_assets/casino/utils/formatters.js":{"content":"/**\n * Utilities for formatting numbers and currencies\n */\n\n/**\n * Format LTC amount to remove unnecessary trailing zeros\n * @param {number} amount - LTC amount\n * @returns {string} - Formatted LTC string\n */\nfunction formatLTC(amount) {\n    if (amount === 0) {\n        return '0';\n    }\n    \n    // Convert to fixed 8 decimal places first\n    const fixed = amount.toFixed(8);\n    \n    // Remove trailing zeros and unnecessary decimal point\n    const formatted = parseFloat(fixed).toString();\n    \n    // If the number is very small, show scientific notation\n    if (amount < 0.00001 && amount > 0) {\n        return amount.toExponential(3);\n    }\n    \n    return formatted;\n}\n\n/**\n * Format USD amount with 2 decimal places\n * @param {number} amount - USD amount\n * @returns {string} - Formatted USD string\n */\nfunction formatUSD(amount) {\n    return amount.toFixed(2);\n}\n\n/**\n * Format percentage with 1 decimal place\n * @param {number} percentage - Percentage value\n * @returns {string} - Formatted percentage string\n */\nfunction formatPercentage(percentage) {\n    return percentage.toFixed(1);\n}\n\nmodule.exports = {\n    formatLTC,\n    formatUSD,\n    formatPercentage\n};","size_bytes":1172},"attached_assets/casino/attached_assets/casino/utils/litecoinDirect.js":{"content":"/**\n * Litecoin Direct Connection - No API Keys Required\n * Uses public blockchain explorers and direct libraries\n */\n\nconst axios = require('axios');\nconst bitcoin = require('bitcoinjs-lib');\n\n// Public Litecoin explorer APIs (no API key required)\nconst EXPLORERS = {\n    mainnet: {\n        base: 'https://litecoinspace.org/api',\n        fallback: 'https://insight.litecore.io/api'\n    },\n    testnet: {\n        base: 'https://litecoinspace.org/testnet/api',\n        fallback: 'https://testnet.litecore.io/api'\n    }\n};\n\n// Network configuration\nconst NETWORK = bitcoin.networks.bitcoin; // Litecoin uses Bitcoin network params\n\n/**\n * Get address balance using public explorer\n * @param {string} address - Litecoin address\n * @param {boolean} testnet - Use testnet (default: false)\n * @returns {Promise<number>} Balance in LTC\n */\nasync function getAddressBalance(address, testnet = false) {\n    const explorer = testnet ? EXPLORERS.testnet : EXPLORERS.mainnet;\n    \n    try {\n        // Try primary explorer\n        const response = await axios.get(`${explorer.base}/address/${address}`, {\n            timeout: 10000\n        });\n        \n        if (response.data && typeof response.data.chain_stats !== 'undefined') {\n            // Litecoin Space format\n            const confirmedBalance = response.data.chain_stats.funded_txo_sum || 0;\n            const spentBalance = response.data.chain_stats.spent_txo_sum || 0;\n            const balance = (confirmedBalance - spentBalance) / 100000000; // Convert satoshis to LTC\n            \n            if (balance > 0) {\n                console.log(`‚úÖ ${address.substring(0, 10)}...: ${balance} LTC`);\n            }\n            return balance;\n        }\n        \n        return 0;\n        \n    } catch (error) {\n        console.log(`‚ö†Ô∏è Erreur explorer principal pour ${address.substring(0, 10)}...: ${error.message}`);\n        \n        // Try fallback explorer\n        try {\n            const fallbackResponse = await axios.get(`${explorer.fallback}/addr/${address}`, {\n                timeout: 10000\n            });\n            \n            if (fallbackResponse.data && typeof fallbackResponse.data.balance !== 'undefined') {\n                // Insight API format\n                const balance = parseFloat(fallbackResponse.data.balance);\n                \n                if (balance > 0) {\n                    console.log(`‚úÖ ${address.substring(0, 10)}... (fallback): ${balance} LTC`);\n                }\n                return balance;\n            }\n            \n        } catch (fallbackError) {\n            console.log(`‚ö†Ô∏è Fallback √©galement √©chou√© pour ${address.substring(0, 10)}...: ${fallbackError.message}`);\n        }\n        \n        return 0;\n    }\n}\n\n/**\n * Get UTXO list for address\n * @param {string} address - Litecoin address\n * @param {boolean} testnet - Use testnet (default: false)\n * @returns {Promise<Array>} Array of UTXOs\n */\nasync function getAddressUTXOs(address, testnet = false) {\n    const explorer = testnet ? EXPLORERS.testnet : EXPLORERS.mainnet;\n    \n    try {\n        // Get UTXOs from Litecoin Space\n        const response = await axios.get(`${explorer.base}/address/${address}/utxo`, {\n            timeout: 10000\n        });\n        \n        if (response.data && Array.isArray(response.data)) {\n            return response.data.map(utxo => ({\n                txid: utxo.txid,\n                outputIndex: utxo.vout,\n                script: utxo.scriptpubkey || '',\n                satoshis: utxo.value\n            }));\n        }\n        \n        return [];\n        \n    } catch (error) {\n        console.error(`Erreur UTXO pour ${address}:`, error.message);\n        return [];\n    }\n}\n\n/**\n * Get transaction details\n * @param {string} txid - Transaction ID\n * @param {boolean} testnet - Use testnet (default: false)\n * @returns {Promise<Object|null>} Transaction details\n */\nasync function getTransaction(txid, testnet = false) {\n    const explorer = testnet ? EXPLORERS.testnet : EXPLORERS.mainnet;\n    \n    try {\n        const response = await axios.get(`${explorer.base}/tx/${txid}`, {\n            timeout: 10000\n        });\n        \n        return response.data;\n        \n    } catch (error) {\n        console.error(`Erreur transaction ${txid}:`, error.message);\n        return null;\n    }\n}\n\n/**\n * Broadcast transaction to network\n * @param {string} txHex - Raw transaction hex\n * @param {boolean} testnet - Use testnet (default: false)\n * @returns {Promise<string|null>} Transaction ID if successful\n */\nasync function broadcastTransaction(txHex, testnet = false) {\n    const explorer = testnet ? EXPLORERS.testnet : EXPLORERS.mainnet;\n    \n    try {\n        const response = await axios.post(`${explorer.base}/tx`, txHex, {\n            headers: { 'Content-Type': 'text/plain' },\n            timeout: 15000\n        });\n        \n        if (typeof response.data === 'string') {\n            console.log(`‚úÖ Transaction diffus√©e avec succ√®s: ${response.data}`);\n            return response.data; // Transaction ID\n        }\n        \n        return null;\n        \n    } catch (error) {\n        console.error('Erreur diffusion transaction:', error.message);\n        return null;\n    }\n}\n\n/**\n * Check for new transactions on an address\n * @param {string} address - Litecoin address\n * @param {number} lastCheckedTimestamp - Last check timestamp\n * @param {boolean} testnet - Use testnet (default: false)\n * @returns {Promise<Array>} Array of new transactions\n */\nasync function getNewTransactions(address, lastCheckedTimestamp, testnet = false) {\n    const explorer = testnet ? EXPLORERS.testnet : EXPLORERS.mainnet;\n    \n    try {\n        const response = await axios.get(`${explorer.base}/address/${address}/txs`, {\n            timeout: 10000\n        });\n        \n        if (response.data && Array.isArray(response.data)) {\n            // Filter transactions newer than last check\n            const newTxs = response.data.filter(tx => {\n                const txTimestamp = tx.status?.block_time ? tx.status.block_time * 1000 : Date.now();\n                return txTimestamp > lastCheckedTimestamp;\n            });\n            \n            return newTxs;\n        }\n        \n        return [];\n        \n    } catch (error) {\n        console.error(`Erreur nouvelles transactions pour ${address}:`, error.message);\n        return [];\n    }\n}\n\n/**\n * Check multiple addresses efficiently\n * @param {Array<string>} addresses - Array of addresses to check\n * @param {boolean} testnet - Use testnet (default: false)\n * @returns {Promise<Object>} Object with address -> balance mapping\n */\nasync function checkMultipleAddresses(addresses, testnet = false) {\n    const results = {};\n    \n    // Process addresses with delay to avoid rate limiting\n    for (let i = 0; i < addresses.length; i++) {\n        const address = addresses[i];\n        \n        try {\n            results[address] = await getAddressBalance(address, testnet);\n        } catch (error) {\n            console.error(`Erreur pour ${address}:`, error.message);\n            results[address] = 0;\n        }\n        \n        // Small delay between requests to be respectful to public APIs\n        if (i < addresses.length - 1) {\n            await new Promise(resolve => setTimeout(resolve, 1000)); // 1 second delay\n        }\n    }\n    \n    return results;\n}\n\n/**\n * Health check for explorer APIs\n * @param {boolean} testnet - Use testnet (default: false)\n * @returns {Promise<boolean>} True if APIs are responsive\n */\nasync function healthCheck(testnet = false) {\n    const explorer = testnet ? EXPLORERS.testnet : EXPLORERS.mainnet;\n    \n    try {\n        // Test with a known address (Litecoin Foundation donation address)\n        const testAddress = testnet ? 'mkYY3QRCJKJHZczVz6mJ6ztNKYZrn4s7hS' : 'LTC1QH7KYTQZ9ZXQX3Y8ZGX7ZXQX3Y8ZGX7ZXQX3Y8ZGX7Z';\n        \n        const response = await axios.get(`${explorer.base}/address/${testAddress}`, {\n            timeout: 5000\n        });\n        \n        return response.status === 200;\n        \n    } catch (error) {\n        console.error('Health check failed:', error.message);\n        return false;\n    }\n}\n\nmodule.exports = {\n    getAddressBalance,\n    getAddressUTXOs,\n    getTransaction,\n    broadcastTransaction,\n    getNewTransactions,\n    checkMultipleAddresses,\n    healthCheck,\n    NETWORK\n};","size_bytes":8312},"attached_assets/casino/attached_assets/casino/utils/logManager.js":{"content":"const fs = require('fs');\nconst path = require('path');\nconst { EmbedBuilder } = require('discord.js');\n\nconst CONFIG_FILE = path.join(__dirname, '../data/log_config.json');\n\nfunction loadLogConfig() {\n    try {\n        if (fs.existsSync(CONFIG_FILE)) {\n            const data = fs.readFileSync(CONFIG_FILE, 'utf8');\n            return JSON.parse(data);\n        }\n    } catch (error) {\n        console.error('Error loading log config:', error.message);\n    }\n    return {};\n}\n\n/**\n * Send balance log to configured channel\n * @param {Object} client - Discord client\n * @param {string} serverId - Server ID\n * @param {Object} logData - Log data\n */\nasync function sendBalanceLog(client, serverId, logData) {\n    try {\n        const config = loadLogConfig();\n        const channelId = config[serverId]?.balanceLogChannel;\n        \n        if (!channelId) {\n            console.log('No balance log channel configured for server:', serverId);\n            return;\n        }\n        \n        const channel = await client.channels.fetch(channelId);\n        if (!channel) {\n            console.log('Balance log channel not found:', channelId);\n            return;\n        }\n        \n        const embed = createBalanceLogEmbed(logData);\n        await channel.send({ embeds: [embed] });\n        \n    } catch (error) {\n        console.error('Error sending balance log:', error.message);\n    }\n}\n\n/**\n * Send gambling log to configured channel\n * @param {Object} client - Discord client\n * @param {string} serverId - Server ID\n * @param {Object} logData - Log data\n */\nasync function sendGamblingLog(client, serverId, logData) {\n    try {\n        const config = loadLogConfig();\n        const channelId = config[serverId]?.gamblingLogChannel;\n        \n        if (!channelId) {\n            console.log('No gambling log channel configured for server:', serverId);\n            return;\n        }\n        \n        const channel = await client.channels.fetch(channelId);\n        if (!channel) {\n            console.log('Gambling log channel not found:', channelId);\n            return;\n        }\n        \n        const embed = createGamblingLogEmbed(logData);\n        await channel.send({ embeds: [embed] });\n        \n    } catch (error) {\n        console.error('Error sending gambling log:', error.message);\n    }\n}\n\n/**\n * Create balance log embed\n * @param {Object} logData - Log data\n * @returns {EmbedBuilder} Embed\n */\nfunction createBalanceLogEmbed(logData) {\n    const { type, user, amount, address, details } = logData;\n    \n    let embed = new EmbedBuilder()\n        .setTimestamp();\n    \n    switch (type) {\n        case 'deposit':\n            embed\n                .setColor('#00ff00')\n                .setTitle('üí∞ Deposit Confirmed')\n                .setDescription(`User ${user.username} deposited **${amount} LTC**`)\n                .addFields(\n                    {\n                        name: 'üë§ User',\n                        value: `${user} (${user.id})`,\n                        inline: true\n                    },\n                    {\n                        name: 'üí∞ Amount',\n                        value: `${amount} LTC`,\n                        inline: true\n                    },\n                    {\n                        name: 'üìç Address',\n                        value: `\\`${address}\\``,\n                        inline: false\n                    }\n                );\n            break;\n            \n        case 'address_generated':\n            embed\n                .setColor('#0099ff')\n                .setTitle('üîë Deposit Address Generated')\n                .setDescription(`New deposit address created for ${user.username}`)\n                .addFields(\n                    {\n                        name: 'üë§ User',\n                        value: `${user} (${user.id})`,\n                        inline: true\n                    },\n                    {\n                        name: 'üìç Address',\n                        value: `\\`${address}\\``,\n                        inline: false\n                    }\n                );\n            break;\n            \n        case 'channel_closed':\n            embed\n                .setColor('#ffaa00')\n                .setTitle('üîí Deposit Channel Closed')\n                .setDescription(`Deposit channel closed for ${user.username}`)\n                .addFields(\n                    {\n                        name: 'üë§ User',\n                        value: `${user} (${user.id})`,\n                        inline: true\n                    },\n                    {\n                        name: '‚è±Ô∏è Reason',\n                        value: details || 'Auto-close after 20 minutes',\n                        inline: true\n                    }\n                );\n            break;\n    }\n    \n    return embed;\n}\n\n/**\n * Create gambling log embed\n * @param {Object} logData - Log data\n * @returns {EmbedBuilder} Embed\n */\nfunction createGamblingLogEmbed(logData) {\n    const { type, user, game, bet, result, payout, details } = logData;\n    \n    let embed = new EmbedBuilder()\n        .setTimestamp();\n    \n    switch (type) {\n        case 'blackjack':\n            embed\n                .setColor(result === 'win' ? '#00ff00' : result === 'lose' ? '#ff0000' : '#ffaa00')\n                .setTitle('üÉè Blackjack Game')\n                .setDescription(`${user.username} ${result === 'win' ? 'won' : result === 'lose' ? 'lost' : 'tied'} ${bet} LTC`)\n                .addFields(\n                    {\n                        name: 'üë§ Player',\n                        value: `${user} (${user.id})`,\n                        inline: true\n                    },\n                    {\n                        name: 'üí∞ Bet',\n                        value: `${bet} LTC`,\n                        inline: true\n                    },\n                    {\n                        name: 'üé∞ Result',\n                        value: result.toUpperCase(),\n                        inline: true\n                    },\n                    {\n                        name: 'üíµ Payout',\n                        value: `${payout || 0} LTC`,\n                        inline: true\n                    }\n                );\n            \n            if (details) {\n                embed.addFields({\n                    name: 'üìã Game Details',\n                    value: details,\n                    inline: false\n                });\n            }\n            break;\n            \n        case 'roulette':\n            embed\n                .setColor(result === 'win' ? '#00ff00' : '#ff0000')\n                .setTitle('üé∞ Roulette Spin')\n                .setDescription(`${user.username} ${result === 'win' ? 'won' : 'lost'} ${bet} LTC`)\n                .addFields(\n                    {\n                        name: 'üë§ Player',\n                        value: `${user} (${user.id})`,\n                        inline: true\n                    },\n                    {\n                        name: 'üí∞ Bet',\n                        value: `${bet} LTC`,\n                        inline: true\n                    },\n                    {\n                        name: 'üé∞ Result',\n                        value: result.toUpperCase(),\n                        inline: true\n                    },\n                    {\n                        name: 'üíµ Payout',\n                        value: `${payout || 0} LTC`,\n                        inline: true\n                    }\n                );\n            \n            if (details) {\n                embed.addFields({\n                    name: 'üìã Spin Details',\n                    value: details,\n                    inline: false\n                });\n            }\n            break;\n            \n        case 'big_win':\n            embed\n                .setColor('#ffd700')\n                .setTitle('üèÜ BIG WIN!')\n                .setDescription(`${user.username} hit a big win of **${payout} LTC**!`)\n                .addFields(\n                    {\n                        name: 'üë§ Winner',\n                        value: `${user} (${user.id})`,\n                        inline: true\n                    },\n                    {\n                        name: 'üéÆ Game',\n                        value: game.toUpperCase(),\n                        inline: true\n                    },\n                    {\n                        name: 'üí∞ Bet',\n                        value: `${bet} LTC`,\n                        inline: true\n                    },\n                    {\n                        name: 'üèÜ Win Amount',\n                        value: `${payout} LTC`,\n                        inline: true\n                    }\n                );\n            break;\n    }\n    \n    return embed;\n}\n\nmodule.exports = {\n    sendBalanceLog,\n    sendGamblingLog,\n    createBalanceLogEmbed,\n    createGamblingLogEmbed\n};","size_bytes":8851},"attached_assets/casino/attached_assets/casino/utils/panelManager.js":{"content":"/**\n * Panel Manager for Casino Bot\n * Manages channel configurations and panel systems\n */\n\nconst fs = require('fs');\n\nconst CONFIG_FILE = './data/panel_config.json';\n\n/**\n * Get default configuration\n */\nfunction getDefaultConfig() {\n    return {\n        panels: {\n            casinoPanel: {\n                channelId: null,\n                messageId: null,\n                ticketCategory: null,\n                staffRole: null\n            },\n            addBalancePanel: {\n                channelId: null,\n                messageId: null,\n                ticketCategory: null,\n                staffRole: null\n            }\n        },\n        whitelist: {\n            serverIds: [],\n            adminRoles: []\n        }\n    };\n}\n\n/**\n * Load panel configuration\n */\nfunction loadConfig() {\n    try {\n        if (!fs.existsSync('./data')) {\n            fs.mkdirSync('./data', { recursive: true });\n        }\n        \n        if (fs.existsSync(CONFIG_FILE)) {\n            const data = fs.readFileSync(CONFIG_FILE, 'utf8');\n            return JSON.parse(data);\n        }\n    } catch (error) {\n        console.error('Erreur lors du chargement de la config des panels:', error);\n    }\n    \n    return getDefaultConfig();\n}\n\n/**\n * Save panel configuration\n */\nfunction saveConfig(config) {\n    try {\n        if (!fs.existsSync('./data')) {\n            fs.mkdirSync('./data', { recursive: true });\n        }\n        \n        fs.writeFileSync(CONFIG_FILE, JSON.stringify(config, null, 2));\n        console.log('‚úÖ Configuration des panels sauvegard√©e');\n        return true;\n    } catch (error) {\n        console.error('Erreur lors de la sauvegarde config panels:', error);\n        return false;\n    }\n}\n\n/**\n * Set channel for a specific panel type\n */\nfunction setPanelChannel(panelType, channelId, categoryId = null, staffRole = null) {\n    const config = loadConfig();\n    \n    if (!config.panels[panelType]) {\n        config.panels[panelType] = {\n            channelId: null,\n            messageId: null,\n            ticketCategory: null,\n            staffRole: null\n        };\n    }\n    \n    config.panels[panelType].channelId = channelId;\n    if (categoryId) config.panels[panelType].ticketCategory = categoryId;\n    if (staffRole) config.panels[panelType].staffRole = staffRole;\n    \n    return saveConfig(config);\n}\n\n/**\n * Get panel configuration for a specific type\n */\nfunction getPanelConfig(panelType) {\n    const config = loadConfig();\n    return config.panels[panelType] || null;\n}\n\n/**\n * Check if user/server is whitelisted for panel management\n */\nfunction isWhitelisted(serverId, userId, userRoles) {\n    const config = loadConfig();\n    \n    // Check server whitelist\n    if (!config.whitelist.serverIds.includes(serverId)) {\n        return false;\n    }\n    \n    // Check admin roles\n    if (config.whitelist.adminRoles.length > 0) {\n        const hasAdminRole = config.whitelist.adminRoles.some(roleId => \n            userRoles.includes(roleId)\n        );\n        return hasAdminRole;\n    }\n    \n    return true; // If no admin roles defined, allow all users in whitelisted servers\n}\n\n/**\n * Add server to whitelist\n */\nfunction addToWhitelist(serverId, adminRoleId = null) {\n    const config = loadConfig();\n    \n    if (!config.whitelist.serverIds.includes(serverId)) {\n        config.whitelist.serverIds.push(serverId);\n    }\n    \n    if (adminRoleId && !config.whitelist.adminRoles.includes(adminRoleId)) {\n        config.whitelist.adminRoles.push(adminRoleId);\n    }\n    \n    return saveConfig(config);\n}\n\n/**\n * Remove server from whitelist\n */\nfunction removeFromWhitelist(serverId) {\n    const config = loadConfig();\n    \n    config.whitelist.serverIds = config.whitelist.serverIds.filter(id => id !== serverId);\n    \n    return saveConfig(config);\n}\n\n/**\n * Set message ID for panel (after sending)\n */\nfunction setPanelMessageId(panelType, messageId) {\n    const config = loadConfig();\n    \n    if (config.panels[panelType]) {\n        config.panels[panelType].messageId = messageId;\n        return saveConfig(config);\n    }\n    \n    return false;\n}\n\n/**\n * Get all panel configurations\n */\nfunction getAllPanels() {\n    const config = loadConfig();\n    return config.panels;\n}\n\nmodule.exports = {\n    loadConfig,\n    saveConfig,\n    setPanelChannel,\n    getPanelConfig,\n    isWhitelisted,\n    addToWhitelist,\n    removeFromWhitelist,\n    setPanelMessageId,\n    getAllPanels\n};","size_bytes":4405},"attached_assets/casino/attached_assets/casino/utils/securityManager.js":{"content":"const fs = require('fs');\nconst path = require('path');\nconst crypto = require('crypto');\n\nconst SECURITY_FILE = path.join(__dirname, '../data/user_security.json');\nconst ACTIVE_DEPOSITS_FILE = path.join(__dirname, '../data/active_deposits.json');\nconst GAMBLING_SESSIONS_FILE = path.join(__dirname, '../data/gambling_sessions.json');\n\n// Ensure data directory exists\nconst dataDir = path.join(__dirname, '../data');\nif (!fs.existsSync(dataDir)) {\n    fs.mkdirSync(dataDir, { recursive: true });\n}\n\n/**\n * Load user security data\n * @returns {Object} Security data\n */\nfunction loadSecurityData() {\n    try {\n        if (fs.existsSync(SECURITY_FILE)) {\n            const data = fs.readFileSync(SECURITY_FILE, 'utf8');\n            return JSON.parse(data);\n        }\n    } catch (error) {\n        console.error('Error loading security data:', error.message);\n    }\n    return {};\n}\n\n/**\n * Save user security data\n * @param {Object} data - Security data to save\n */\nfunction saveSecurityData(data) {\n    try {\n        fs.writeFileSync(SECURITY_FILE, JSON.stringify(data, null, 2));\n        console.log('‚úÖ Security data saved');\n    } catch (error) {\n        console.error('Error saving security data:', error.message);\n    }\n}\n\n/**\n * Load active deposits\n * @returns {Object} Active deposits data\n */\nfunction loadActiveDeposits() {\n    try {\n        if (fs.existsSync(ACTIVE_DEPOSITS_FILE)) {\n            const data = fs.readFileSync(ACTIVE_DEPOSITS_FILE, 'utf8');\n            return JSON.parse(data);\n        }\n    } catch (error) {\n        console.error('Error loading active deposits:', error.message);\n    }\n    return {};\n}\n\n/**\n * Save active deposits\n * @param {Object} data - Active deposits data to save\n */\nfunction saveActiveDeposits(data) {\n    try {\n        fs.writeFileSync(ACTIVE_DEPOSITS_FILE, JSON.stringify(data, null, 2));\n        console.log('‚úÖ Active deposits saved');\n    } catch (error) {\n        console.error('Error saving active deposits:', error.message);\n    }\n}\n\n/**\n * Load gambling sessions\n * @returns {Object} Gambling sessions data\n */\nfunction loadGamblingSessions() {\n    try {\n        if (fs.existsSync(GAMBLING_SESSIONS_FILE)) {\n            const data = fs.readFileSync(GAMBLING_SESSIONS_FILE, 'utf8');\n            return JSON.parse(data);\n        }\n    } catch (error) {\n        console.error('Error loading gambling sessions:', error.message);\n    }\n    return {};\n}\n\n/**\n * Save gambling sessions\n * @param {Object} data - Gambling sessions data to save\n */\nfunction saveGamblingSessions(data) {\n    try {\n        fs.writeFileSync(GAMBLING_SESSIONS_FILE, JSON.stringify(data, null, 2));\n        console.log('‚úÖ Gambling sessions saved');\n    } catch (error) {\n        console.error('Error saving gambling sessions:', error.message);\n    }\n}\n\n/**\n * Generate secure recovery key\n * @returns {string} Recovery key\n */\nfunction generateRecoveryKey() {\n    return crypto.randomBytes(16).toString('hex').toUpperCase();\n}\n\n/**\n * Hash password securely\n * @param {string} password - Plain text password\n * @returns {string} Hashed password\n */\nfunction hashPassword(password) {\n    const salt = crypto.randomBytes(16).toString('hex');\n    const hash = crypto.pbkdf2Sync(password, salt, 10000, 64, 'sha512').toString('hex');\n    return `${salt}:${hash}`;\n}\n\n/**\n * Verify password\n * @param {string} password - Plain text password\n * @param {string} hashedPassword - Stored hashed password\n * @returns {boolean} True if password matches\n */\nfunction verifyPassword(password, hashedPassword) {\n    try {\n        const [salt, hash] = hashedPassword.split(':');\n        const verifyHash = crypto.pbkdf2Sync(password, salt, 10000, 64, 'sha512').toString('hex');\n        return hash === verifyHash;\n    } catch (error) {\n        return false;\n    }\n}\n\n/**\n * Get or create user security profile\n * @param {string} userId - Discord user ID\n * @returns {Object} Security profile\n */\nfunction getUserSecurity(userId) {\n    const security = loadSecurityData();\n    \n    if (!security[userId]) {\n        security[userId] = {\n            userId: userId,\n            hasPassword: false,\n            passwordHash: null,\n            recoveryKey: null,\n            depositRequests: [],\n            lastGamblingSession: null,\n            wageredAmount: 0,\n            depositedAmount: 0,\n            canCashout: true,\n            createdAt: new Date().toISOString()\n        };\n        saveSecurityData(security);\n    }\n    \n    return security[userId];\n}\n\n/**\n * Set user password and generate recovery key\n * @param {string} userId - Discord user ID\n * @param {string} password - New password\n * @returns {string} Recovery key\n */\nfunction setUserPassword(userId, password) {\n    const security = loadSecurityData();\n    const userSec = getUserSecurity(userId);\n    \n    const recoveryKey = generateRecoveryKey();\n    \n    userSec.hasPassword = true;\n    userSec.passwordHash = hashPassword(password);\n    userSec.recoveryKey = recoveryKey;\n    \n    security[userId] = userSec;\n    saveSecurityData(security);\n    \n    return recoveryKey;\n}\n\n/**\n * Change user password\n * @param {string} userId - Discord user ID\n * @param {string} oldPassword - Current password\n * @param {string} newPassword - New password\n * @returns {boolean} Success\n */\nfunction changeUserPassword(userId, oldPassword, newPassword) {\n    const security = loadSecurityData();\n    const userSec = getUserSecurity(userId);\n    \n    if (!userSec.hasPassword || !verifyPassword(oldPassword, userSec.passwordHash)) {\n        return false;\n    }\n    \n    userSec.passwordHash = hashPassword(newPassword);\n    security[userId] = userSec;\n    saveSecurityData(security);\n    \n    return true;\n}\n\n/**\n * Verify user password\n * @param {string} userId - Discord user ID\n * @param {string} password - Password to verify\n * @returns {boolean} True if password is correct\n */\nfunction verifyUserPassword(userId, password) {\n    const userSec = getUserSecurity(userId);\n    \n    if (!userSec.hasPassword) {\n        return false;\n    }\n    \n    return verifyPassword(password, userSec.passwordHash);\n}\n\n/**\n * Reset recovery key with old key + password\n * @param {string} userId - Discord user ID\n * @param {string} oldRecoveryKey - Old recovery key\n * @param {string} password - Current password\n * @returns {string|null} New recovery key or null if failed\n */\nfunction resetRecoveryKey(userId, oldRecoveryKey, password) {\n    const security = loadSecurityData();\n    const userSec = getUserSecurity(userId);\n    \n    if (!userSec.hasPassword || \n        userSec.recoveryKey !== oldRecoveryKey.toUpperCase() ||\n        !verifyPassword(password, userSec.passwordHash)) {\n        return null;\n    }\n    \n    const newRecoveryKey = generateRecoveryKey();\n    userSec.recoveryKey = newRecoveryKey;\n    \n    security[userId] = userSec;\n    saveSecurityData(security);\n    \n    return newRecoveryKey;\n}\n\n/**\n * Reset user password and recovery key (Admin function)\n * @param {string} userId - Discord user ID  \n * @param {string} newRecoveryKey - New recovery key to set\n * @returns {Object} Result with success status\n */\nfunction resetPassword(userId, newRecoveryKey) {\n    try {\n        const security = loadSecurityData();\n        const userSec = getUserSecurity(userId);\n        \n        // Reset password to null (user will need to set new one)\n        userSec.hasPassword = false;\n        userSec.passwordHash = null;\n        userSec.recoveryKey = newRecoveryKey;\n        \n        security[userId] = userSec;\n        saveSecurityData(security);\n        \n        console.log(`üîê Admin reset password for user ${userId}`);\n        return { success: true };\n        \n    } catch (error) {\n        console.error('Error resetting password:', error);\n        return { success: false, error: error.message };\n    }\n}\n\n/**\n * Add active deposit request\n * @param {string} userId - Discord user ID\n * @param {string} address - LTC address\n * @param {number} initialBalance - Initial balance of address\n */\nfunction addActiveDeposit(userId, address, initialBalance = 0) {\n    const activeDeposits = loadActiveDeposits();\n    \n    if (!activeDeposits[userId]) {\n        activeDeposits[userId] = [];\n    }\n    \n    activeDeposits[userId].push({\n        address: address,\n        userId: userId,\n        lastKnownBalance: initialBalance,\n        createdAt: new Date().toISOString(),\n        active: true\n    });\n    \n    saveActiveDeposits(activeDeposits);\n}\n\n/**\n * Get active deposits for user\n * @param {string} userId - Discord user ID\n * @returns {Array} Active deposit requests\n */\nfunction getActiveDeposits(userId) {\n    const activeDeposits = loadActiveDeposits();\n    return activeDeposits[userId] || [];\n}\n\n/**\n * Get all active deposits across all users\n * @returns {Array} All active deposit requests\n */\nfunction getAllActiveDeposits() {\n    const activeDeposits = loadActiveDeposits();\n    const allDeposits = [];\n    \n    for (const userId in activeDeposits) {\n        allDeposits.push(...activeDeposits[userId].filter(deposit => deposit.active));\n    }\n    \n    return allDeposits;\n}\n\n/**\n * Complete deposit request\n * @param {string} userId - Discord user ID\n * @param {string} address - LTC address\n */\nfunction completeDepositRequest(userId, address) {\n    const activeDeposits = loadActiveDeposits();\n    \n    if (activeDeposits[userId]) {\n        const deposit = activeDeposits[userId].find(d => d.address === address);\n        if (deposit) {\n            deposit.active = false;\n            deposit.completedAt = new Date().toISOString();\n        }\n    }\n    \n    saveActiveDeposits(activeDeposits);\n}\n\n/**\n * Start gambling session\n * @param {string} userId - Discord user ID\n * @param {number} minutes - Session duration in minutes\n * @returns {Date} Session end time\n */\nfunction startGamblingSession(userId, minutes) {\n    const sessions = loadGamblingSessions();\n    const endTime = new Date(Date.now() + minutes * 60 * 1000);\n    \n    sessions[userId] = {\n        userId: userId,\n        startTime: new Date().toISOString(),\n        endTime: endTime.toISOString(),\n        durationMinutes: minutes,\n        active: true\n    };\n    \n    saveGamblingSessions(sessions);\n    \n    // Update user security\n    const security = loadSecurityData();\n    const userSec = getUserSecurity(userId);\n    userSec.lastGamblingSession = sessions[userId];\n    security[userId] = userSec;\n    saveSecurityData(security);\n    \n    return endTime;\n}\n\n/**\n * Check if user has active gambling session\n * @param {string} userId - Discord user ID\n * @returns {boolean} True if session is active\n */\nfunction hasActiveGamblingSession(userId) {\n    const sessions = loadGamblingSessions();\n    \n    if (!sessions[userId] || !sessions[userId].active) {\n        return false;\n    }\n    \n    const now = new Date();\n    const endTime = new Date(sessions[userId].endTime);\n    \n    if (now > endTime) {\n        // Session expired\n        sessions[userId].active = false;\n        saveGamblingSessions(sessions);\n        return false;\n    }\n    \n    return true;\n}\n\n/**\n * Add wagered amount for user\n * @param {string} userId - Discord user ID\n * @param {number} amount - Amount wagered\n */\nfunction addWageredAmount(userId, amount) {\n    const security = loadSecurityData();\n    const userSec = getUserSecurity(userId);\n    \n    userSec.wageredAmount += amount;\n    security[userId] = userSec;\n    saveSecurityData(security);\n}\n\n/**\n * Add deposited amount for user\n * @param {string} userId - Discord user ID\n * @param {number} amount - Amount deposited\n */\nfunction addDepositedAmount(userId, amount) {\n    const security = loadSecurityData();\n    const userSec = getUserSecurity(userId);\n    \n    userSec.depositedAmount += amount;\n    // Check if user can cashout (wagered >= deposited)\n    userSec.canCashout = userSec.wageredAmount >= userSec.depositedAmount;\n    \n    security[userId] = userSec;\n    saveSecurityData(security);\n}\n\n/**\n * Clear all active deposits (Admin function)\n * @returns {boolean} Success status\n */\nfunction clearAllActiveDeposits() {\n    try {\n        const emptyDeposits = {};\n        saveActiveDeposits(emptyDeposits);\n        console.log('üóØÔ∏è All active deposits cleared');\n        return true;\n    } catch (error) {\n        console.error('Error clearing active deposits:', error);\n        return false;\n    }\n}\n\n/**\n * Check if user can cashout\n * @param {string} userId - Discord user ID\n * @returns {Object} Cashout status and info\n */\nfunction canUserCashout(userId) {\n    const userSec = getUserSecurity(userId);\n    \n    const wageredPercent = userSec.depositedAmount > 0 ? \n        (userSec.wageredAmount / userSec.depositedAmount) * 100 : 100;\n    \n    return {\n        canCashout: userSec.canCashout,\n        wageredAmount: userSec.wageredAmount,\n        depositedAmount: userSec.depositedAmount,\n        wageredPercent: wageredPercent,\n        remainingToWager: Math.max(0, userSec.depositedAmount - userSec.wageredAmount)\n    };\n}\n\nmodule.exports = {\n    getUserSecurity,\n    setUserPassword,\n    changeUserPassword,\n    verifyUserPassword,\n    resetRecoveryKey,\n    resetPassword,\n    addActiveDeposit,\n    getActiveDeposits,\n    getAllActiveDeposits,\n    completeDepositRequest,\n    clearAllActiveDeposits,\n    startGamblingSession,\n    hasActiveGamblingSession,\n    addWageredAmount,\n    addDepositedAmount,\n    canUserCashout,\n    generateRecoveryKey\n};","size_bytes":13379},"attached_assets/casino/attached_assets/casino/utils/ticketManager.js":{"content":"/**\n * Ticket Manager for Casino Bot\n * Handles creation and management of private ticket channels\n */\n\nconst fs = require('fs');\nconst TICKETS_FILE = './data/tickets.json';\n\n/**\n * Get default tickets data\n */\nfunction getDefaultData() {\n    return {\n        activeTickets: {},\n        ticketCounter: 0\n    };\n}\n\n/**\n * Load tickets data\n */\nfunction loadTickets() {\n    try {\n        if (!fs.existsSync('./data')) {\n            fs.mkdirSync('./data', { recursive: true });\n        }\n        \n        if (fs.existsSync(TICKETS_FILE)) {\n            const data = fs.readFileSync(TICKETS_FILE, 'utf8');\n            return JSON.parse(data);\n        }\n    } catch (error) {\n        console.error('Erreur lors du chargement des tickets:', error);\n    }\n    \n    return getDefaultData();\n}\n\n/**\n * Save tickets data\n */\nfunction saveTickets(data) {\n    try {\n        if (!fs.existsSync('./data')) {\n            fs.mkdirSync('./data', { recursive: true });\n        }\n        \n        fs.writeFileSync(TICKETS_FILE, JSON.stringify(data, null, 2));\n        return true;\n    } catch (error) {\n        console.error('Erreur lors de la sauvegarde des tickets:', error);\n        return false;\n    }\n}\n\n/**\n * Create a private ticket channel for user\n */\nasync function createTicket(guild, user, categoryId, staffRoleId, ticketType = 'general') {\n    try {\n        const data = loadTickets();\n        \n        // Check if user already has an active ticket\n        const existingTicket = Object.values(data.activeTickets).find(ticket => \n            ticket.userId === user.id && ticket.type === ticketType\n        );\n        \n        if (existingTicket) {\n            try {\n                const existingChannel = guild.channels.cache.get(existingTicket.channelId);\n                if (existingChannel) {\n                    return { \n                        success: false, \n                        error: 'existing',\n                        channel: existingChannel \n                    };\n                } else {\n                    // Channel doesn't exist anymore, remove from data\n                    delete data.activeTickets[existingTicket.ticketId];\n                    saveTickets(data);\n                }\n            } catch (error) {\n                console.log('Erreur v√©rification channel existant:', error);\n            }\n        }\n        \n        // Increment counter and create ticket ID\n        data.ticketCounter++;\n        const ticketId = `ticket-${data.ticketCounter}`;\n        \n        // Determine ticket name based on type\n        const ticketNames = {\n            'balance': 'üí∞-balance',\n            'profile': 'üë§-profile', \n            'general': 'üé´-casino'\n        };\n        \n        const channelName = `${ticketNames[ticketType] || 'üé´-casino'}-${user.username}`.toLowerCase();\n        \n        // Set up permissions\n        const permissionOverwrites = [\n            {\n                id: guild.id, // @everyone\n                deny: ['ViewChannel', 'SendMessages', 'ReadMessageHistory']\n            },\n            {\n                id: user.id,\n                allow: ['ViewChannel', 'SendMessages', 'ReadMessageHistory', 'AttachFiles', 'EmbedLinks']\n            }\n        ];\n        \n        // Add staff role permissions if provided\n        if (staffRoleId) {\n            permissionOverwrites.push({\n                id: staffRoleId,\n                allow: ['ViewChannel', 'SendMessages', 'ReadMessageHistory', 'AttachFiles', 'EmbedLinks', 'ManageMessages']\n            });\n        }\n        \n        // Create the channel\n        const channel = await guild.channels.create({\n            name: channelName,\n            type: 0, // Text channel\n            topic: `Private ${ticketType} session for ${user.username} ‚Ä¢ Ticket ID: ${ticketId}`,\n            parent: categoryId,\n            permissionOverwrites: permissionOverwrites\n        });\n        \n        // Save ticket data\n        data.activeTickets[ticketId] = {\n            ticketId,\n            channelId: channel.id,\n            userId: user.id,\n            username: user.username,\n            type: ticketType,\n            createdAt: Date.now(),\n            staffRoleId\n        };\n        \n        saveTickets(data);\n        \n        return {\n            success: true,\n            channel,\n            ticketId\n        };\n        \n    } catch (error) {\n        console.error('Erreur cr√©ation ticket:', error);\n        return {\n            success: false,\n            error: 'create_failed'\n        };\n    }\n}\n\n/**\n * Close a ticket channel\n */\nasync function closeTicket(ticketId, guild) {\n    try {\n        const data = loadTickets();\n        const ticket = data.activeTickets[ticketId];\n        \n        if (!ticket) {\n            return { success: false, error: 'not_found' };\n        }\n        \n        // Try to delete the channel\n        try {\n            const channel = guild.channels.cache.get(ticket.channelId);\n            if (channel) {\n                await channel.delete();\n            }\n        } catch (error) {\n            console.log('Erreur suppression channel:', error);\n        }\n        \n        // Remove from data\n        delete data.activeTickets[ticketId];\n        saveTickets(data);\n        \n        return { success: true };\n        \n    } catch (error) {\n        console.error('Erreur fermeture ticket:', error);\n        return { success: false, error: 'close_failed' };\n    }\n}\n\n/**\n * Get ticket by channel ID\n */\nfunction getTicketByChannel(channelId) {\n    const data = loadTickets();\n    return Object.values(data.activeTickets).find(ticket => \n        ticket.channelId === channelId\n    );\n}\n\n/**\n * Get ticket by user ID and type\n */\nfunction getTicketByUser(userId, ticketType = null) {\n    const data = loadTickets();\n    return Object.values(data.activeTickets).find(ticket => \n        ticket.userId === userId && (ticketType ? ticket.type === ticketType : true)\n    );\n}\n\n/**\n * Get all active tickets\n */\nfunction getAllTickets() {\n    const data = loadTickets();\n    return data.activeTickets;\n}\n\n/**\n * Clean up old/invalid tickets\n */\nasync function cleanupTickets(guild) {\n    try {\n        const data = loadTickets();\n        let cleanedCount = 0;\n        \n        for (const [ticketId, ticket] of Object.entries(data.activeTickets)) {\n            try {\n                const channel = guild.channels.cache.get(ticket.channelId);\n                if (!channel) {\n                    // Channel doesn't exist, remove ticket\n                    delete data.activeTickets[ticketId];\n                    cleanedCount++;\n                }\n            } catch (error) {\n                // Error checking channel, remove ticket\n                delete data.activeTickets[ticketId];\n                cleanedCount++;\n            }\n        }\n        \n        if (cleanedCount > 0) {\n            saveTickets(data);\n            console.log(`üßπ Nettoy√© ${cleanedCount} ticket(s) invalide(s)`);\n        }\n        \n        return cleanedCount;\n        \n    } catch (error) {\n        console.error('Erreur nettoyage tickets:', error);\n        return 0;\n    }\n}\n\nmodule.exports = {\n    createTicket,\n    closeTicket,\n    getTicketByChannel,\n    getTicketByUser,\n    getAllTickets,\n    cleanupTickets\n};","size_bytes":7231},"attached_assets/casino/attached_assets/casino/utils/userProfiles.js":{"content":"const fs = require('fs');\nconst path = require('path');\n\nconst PROFILES_FILE = path.join(__dirname, '../data/user_profiles.json');\nconst ADDRESS_MAPPING_FILE = path.join(__dirname, '../data/address_mapping.json');\n\n// Ensure data directory exists\nconst dataDir = path.join(__dirname, '../data');\nif (!fs.existsSync(dataDir)) {\n    fs.mkdirSync(dataDir, { recursive: true });\n}\n\n/**\n * Load user profiles from JSON file\n * @returns {Object} User profiles object\n */\nfunction loadProfiles() {\n    try {\n        if (fs.existsSync(PROFILES_FILE)) {\n            const data = fs.readFileSync(PROFILES_FILE, 'utf8');\n            return JSON.parse(data);\n        }\n    } catch (error) {\n        console.error('Error loading user profiles:', error.message);\n    }\n    return {};\n}\n\n/**\n * Save user profiles to JSON file\n * @param {Object} profiles - User profiles to save\n */\nfunction saveProfiles(profiles) {\n    try {\n        fs.writeFileSync(PROFILES_FILE, JSON.stringify(profiles, null, 2));\n        console.log('‚úÖ User profiles saved');\n    } catch (error) {\n        console.error('Error saving user profiles:', error.message);\n    }\n}\n\n/**\n * Load address mapping from JSON file\n * @returns {Object} Address mapping object\n */\nfunction loadAddressMapping() {\n    try {\n        if (fs.existsSync(ADDRESS_MAPPING_FILE)) {\n            const data = fs.readFileSync(ADDRESS_MAPPING_FILE, 'utf8');\n            return JSON.parse(data);\n        }\n    } catch (error) {\n        console.error('Error loading address mapping:', error.message);\n    }\n    return {};\n}\n\n/**\n * Save address mapping to JSON file\n * @param {Object} mapping - Address mapping to save\n */\nfunction saveAddressMapping(mapping) {\n    try {\n        fs.writeFileSync(ADDRESS_MAPPING_FILE, JSON.stringify(mapping, null, 2));\n        console.log('‚úÖ Address mapping saved');\n    } catch (error) {\n        console.error('Error saving address mapping:', error.message);\n    }\n}\n\n/**\n * Get or create user profile\n * @param {string} userId - Discord user ID\n * @returns {Object} User profile\n */\nfunction getUserProfile(userId) {\n    const profiles = loadProfiles();\n    \n    if (!profiles[userId]) {\n        profiles[userId] = {\n            userId: userId,\n            balance: 0,\n            totalDeposited: 0,\n            totalWithdrawn: 0,\n            depositHistory: [],\n            withdrawalHistory: [],\n            gameHistory: [],\n            addresses: [],\n            createdAt: new Date().toISOString(),\n            lastActivity: new Date().toISOString()\n        };\n        saveProfiles(profiles);\n    }\n    \n    return profiles[userId];\n}\n\n/**\n * Update user profile\n * @param {string} userId - Discord user ID\n * @param {Object} updates - Updates to apply to profile\n */\nfunction updateUserProfile(userId, updates) {\n    const profiles = loadProfiles();\n    \n    if (!profiles[userId]) {\n        profiles[userId] = getUserProfile(userId);\n    }\n    \n    // Merge updates\n    profiles[userId] = { ...profiles[userId], ...updates };\n    profiles[userId].lastActivity = new Date().toISOString();\n    \n    saveProfiles(profiles);\n    return profiles[userId];\n}\n\n/**\n * Add deposit to user profile\n * @param {string} userId - Discord user ID\n * @param {number} amount - Deposit amount in LTC\n * @param {string} address - Deposit address\n * @param {string} txid - Transaction ID\n */\nfunction addDeposit(userId, amount, address, txid = null) {\n    const profile = getUserProfile(userId);\n    \n    const deposit = {\n        amount: amount,\n        address: address,\n        txid: txid,\n        timestamp: new Date().toISOString(),\n        confirmed: txid !== null\n    };\n    \n    profile.depositHistory.push(deposit);\n    profile.balance += amount;\n    profile.totalDeposited += amount;\n    \n    updateUserProfile(userId, profile);\n    \n    console.log(`üí∞ Added deposit: ${amount} LTC for user ${userId}`);\n    return deposit;\n}\n\n/**\n * Add withdrawal to user profile\n * @param {string} userId - Discord user ID\n * @param {number} amount - Withdrawal amount in LTC\n * @param {string} toAddress - Destination address\n * @param {string} txid - Transaction ID\n */\nfunction addWithdrawal(userId, amount, toAddress, txid) {\n    const profile = getUserProfile(userId);\n    \n    if (profile.balance < amount) {\n        throw new Error('Insufficient balance');\n    }\n    \n    const withdrawal = {\n        amount: amount,\n        toAddress: toAddress,\n        txid: txid,\n        timestamp: new Date().toISOString()\n    };\n    \n    profile.withdrawalHistory.push(withdrawal);\n    profile.balance -= amount;\n    profile.totalWithdrawn += amount;\n    \n    updateUserProfile(userId, profile);\n    \n    console.log(`üí∏ Added withdrawal: ${amount} LTC for user ${userId}`);\n    return withdrawal;\n}\n\n/**\n * Transfer balance between users\n * @param {string} fromUserId - Sender user ID\n * @param {string} toUserId - Receiver user ID\n * @param {number} amount - Amount to transfer\n */\nfunction transferBalance(fromUserId, toUserId, amount) {\n    const fromProfile = getUserProfile(fromUserId);\n    const toProfile = getUserProfile(toUserId);\n    \n    if (fromProfile.balance < amount) {\n        throw new Error('Insufficient balance');\n    }\n    \n    fromProfile.balance -= amount;\n    toProfile.balance += amount;\n    \n    const transfer = {\n        amount: amount,\n        from: fromUserId,\n        to: toUserId,\n        timestamp: new Date().toISOString(),\n        type: 'transfer'\n    };\n    \n    // Add to both users' histories\n    fromProfile.gameHistory.push({ ...transfer, action: 'sent' });\n    toProfile.gameHistory.push({ ...transfer, action: 'received' });\n    \n    updateUserProfile(fromUserId, fromProfile);\n    updateUserProfile(toUserId, toProfile);\n    \n    console.log(`üîÑ Transfer: ${amount} LTC from ${fromUserId} to ${toUserId}`);\n    return transfer;\n}\n\n/**\n * Link a Litecoin address to a Discord user\n * @param {string} userId - Discord user ID\n * @param {string} address - Litecoin address\n */\nfunction linkAddressToUser(userId, address) {\n    const mapping = loadAddressMapping();\n    const profile = getUserProfile(userId);\n    \n    mapping[address] = userId;\n    profile.addresses.push(address);\n    \n    saveAddressMapping(mapping);\n    updateUserProfile(userId, profile);\n    \n    console.log(`üîó Linked address ${address} to user ${userId}`);\n}\n\n/**\n * Get user ID from Litecoin address\n * @param {string} address - Litecoin address\n * @returns {string|null} Discord user ID or null if not found\n */\nfunction getUserFromAddress(address) {\n    const mapping = loadAddressMapping();\n    return mapping[address] || null;\n}\n\n/**\n * Get all user profiles\n * @returns {Object} All user profiles\n */\nfunction getAllProfiles() {\n    return loadProfiles();\n}\n\n/**\n * Get leaderboard data\n * @param {string} type - 'balance', 'deposited', 'withdrawn'\n * @param {number} limit - Number of users to return\n * @returns {Array} Sorted user data\n */\nfunction getLeaderboard(type = 'balance', limit = 10) {\n    const profiles = loadProfiles();\n    const users = Object.values(profiles);\n    \n    let sortKey;\n    switch (type) {\n        case 'deposited':\n            sortKey = 'totalDeposited';\n            break;\n        case 'withdrawn':\n            sortKey = 'totalWithdrawn';\n            break;\n        default:\n            sortKey = 'balance';\n    }\n    \n    return users\n        .sort((a, b) => b[sortKey] - a[sortKey])\n        .slice(0, limit)\n        .map(user => ({\n            userId: user.userId,\n            value: user[sortKey],\n            balance: user.balance\n        }));\n}\n\n/**\n * Reset user security (password and recovery key) - Admin function\n * @param {string} userId - Discord user ID\n * @returns {Object} Result with success status and new recovery key\n */\nfunction resetUserSecurity(userId) {\n    try {\n        const securityManager = require('./securityManager.js');\n        const profiles = loadProfiles();\n        \n        if (!profiles[userId]) {\n            return { success: false, error: 'User profile not found' };\n        }\n        \n        // Generate new recovery key using securityManager\n        const newRecoveryKey = securityManager.generateRecoveryKey();\n        \n        // Reset password to null (forces user to create new one)\n        const resetResult = securityManager.resetPassword(userId, newRecoveryKey);\n        \n        if (resetResult.success) {\n            console.log(`üîê Admin reset security for user ${userId}`);\n            \n            return {\n                success: true,\n                newRecoveryKey: newRecoveryKey\n            };\n        } else {\n            return { success: false, error: 'Security reset failed' };\n        }\n        \n    } catch (error) {\n        console.error('Error resetting user security:', error);\n        return { success: false, error: 'Reset failed' };\n    }\n}\n\nmodule.exports = {\n    getUserProfile,\n    updateUserProfile,\n    addDeposit,\n    addWithdrawal,\n    transferBalance,\n    linkAddressToUser,\n    getUserFromAddress,\n    getAllProfiles,\n    getLeaderboard,\n    loadProfiles,\n    saveProfiles,\n    resetUserSecurity\n};","size_bytes":9095},"attached_assets/casino/commands/addwhitelist.js":{"content":"const { SlashCommandBuilder, EmbedBuilder, PermissionFlagsBits } = require('discord.js');\nconst panelManager = require('../utils/panelManager.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('addwhitelist')\n        .setDescription('Add this server to panel management whitelist (Bot Owner only)')\n        .addRoleOption(option =>\n            option.setName('admin_role')\n                .setDescription('Role that can manage panels (optional)')\n                .setRequired(false)\n        ),\n    \n    async execute(interaction) {\n        // Check if interaction is too old\n        const interactionAge = Date.now() - interaction.createdTimestamp;\n        if (interactionAge > 10 * 60 * 1000) {\n            console.log('Interaction trop ancienne, ignor√©e');\n            return;\n        }\n        \n        // Check if user is bot owner (you can change this logic)\n        const botOwnerIds = ['1409315903937449994']; // Add your user ID here\n        \n        if (!botOwnerIds.includes(interaction.user.id)) {\n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Access Denied')\n                .setDescription('Only the bot owner can manage the whitelist.')\n                .setTimestamp();\n            \n            await interaction.reply({ embeds: [errorEmbed], ephemeral: true });\n            return;\n        }\n        \n        await interaction.deferReply({ ephemeral: true });\n        \n        try {\n            const adminRole = interaction.options.getRole('admin_role');\n            const serverId = interaction.guild.id;\n            \n            // Add to whitelist\n            const success = panelManager.addToWhitelist(serverId, adminRole?.id);\n            \n            if (success) {\n                const successEmbed = new EmbedBuilder()\n                    .setColor('#00ff00')\n                    .setTitle('‚úÖ Server Whitelisted')\n                    .setDescription(`Server **${interaction.guild.name}** has been added to the whitelist.`)\n                    .addFields(\n                        {\n                            name: 'üèõÔ∏è Server',\n                            value: interaction.guild.name,\n                            inline: true\n                        },\n                        {\n                            name: 'üëë Admin Role',\n                            value: adminRole ? adminRole.name : 'None (all members can manage)',\n                            inline: true\n                        },\n                        {\n                            name: 'üìã Available Commands',\n                            value: '‚Ä¢ `/setpanel` - Configure casino panels\\n‚Ä¢ `/stopallactives` - Stop active deposits',\n                            inline: false\n                        }\n                    )\n                    .setFooter({ text: `Server ID: ${serverId}` })\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [successEmbed] });\n                \n                console.log(`‚úÖ Serveur ${interaction.guild.name} ajout√© √† la whitelist par ${interaction.user.username}`);\n                \n            } else {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Whitelist Failed')\n                    .setDescription('Failed to add server to whitelist.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n            }\n            \n        } catch (error) {\n            console.error('Erreur addwhitelist:', error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Error')\n                .setDescription('An error occurred while adding server to whitelist.')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};","size_bytes":4028},"attached_assets/casino/commands/admintransfer.js":{"content":"const { SlashCommandBuilder, EmbedBuilder } = require('discord.js');\nconst userProfiles = require('../utils/userProfiles.js');\nconst { formatLTC } = require('../utils/formatters.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('admintransfer')\n        .setDescription('[ADMIN] Transfer balance between any users')\n        .addUserOption(option =>\n            option.setName('from')\n                .setDescription('User to transfer balance from')\n                .setRequired(true)\n        )\n        .addUserOption(option =>\n            option.setName('to')\n                .setDescription('User to transfer balance to')\n                .setRequired(true)\n        )\n        .addNumberOption(option =>\n            option.setName('amount')\n                .setDescription('Amount to transfer (in LTC)')\n                .setRequired(true)\n                .setMinValue(0.00000001)\n        ),\n    \n    async execute(interaction) {\n        await interaction.deferReply();\n        \n        try {\n            // Check if user is the bot owner\n            const ownerId = process.env.OWNER_ID;\n            \n            if (!ownerId || interaction.user.id !== ownerId) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Access Denied')\n                    .setDescription('Only the bot owner can perform admin transfers.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n\n            const fromUser = interaction.options.getUser('from');\n            const toUser = interaction.options.getUser('to');\n            const amount = interaction.options.getNumber('amount');\n            const fromUserId = fromUser.id;\n            const toUserId = toUser.id;\n            \n            // Validation checks\n            if (fromUserId === toUserId) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Invalid Transfer')\n                    .setDescription('Cannot transfer balance to the same user!')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            if (amount <= 0) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Invalid Amount')\n                    .setDescription('Amount must be greater than 0!')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Check sender's balance\n            const senderProfile = userProfiles.getUserProfile(fromUserId);\n            \n            if (senderProfile.balance < amount) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Insufficient Balance')\n                    .setDescription(`${fromUser.username} doesn't have enough balance!\\n\\n**Current Balance:** ${formatLTC(senderProfile.balance)} LTC\\n**Required:** ${formatLTC(amount)} LTC`)\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Perform the admin transfer\n            const transfer = userProfiles.transferBalance(fromUserId, toUserId, amount);\n            \n            // Get updated profiles\n            const updatedSenderProfile = userProfiles.getUserProfile(fromUserId);\n            const updatedReceiverProfile = userProfiles.getUserProfile(toUserId);\n            \n            const successEmbed = new EmbedBuilder()\n                .setColor('#ff6600')\n                .setTitle('‚úÖ Admin Transfer Successful')\n                .setDescription(`Successfully transferred **${formatLTC(amount)} LTC** from ${fromUser} to ${toUser}`)\n                .addFields(\n                    {\n                        name: 'üë§ From',\n                        value: `${fromUser.username}\\n**New Balance:** ${formatLTC(updatedSenderProfile.balance)} LTC`,\n                        inline: true\n                    },\n                    {\n                        name: 'üë§ To',\n                        value: `${toUser.username}\\n**New Balance:** ${formatLTC(updatedReceiverProfile.balance)} LTC`,\n                        inline: true\n                    },\n                    {\n                        name: 'üõ°Ô∏è Admin Details',\n                        value: `**Executed by:** ${interaction.user.username}\\n**Amount:** ${formatLTC(amount)} LTC\\n**Date:** ${new Date(transfer.timestamp).toLocaleString()}\\n**ID:** ${transfer.timestamp}`,\n                        inline: false\n                    }\n                )\n                .setThumbnail('https://cryptologos.cc/logos/litecoin-ltc-logo.png')\n                .setFooter({ text: 'Admin Transfer - Owner Command' })\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [successEmbed] });\n            \n            // Try to notify both users\n            try {\n                // Notify the sender\n                const senderDM = await fromUser.createDM();\n                const senderNotification = new EmbedBuilder()\n                    .setColor('#ff6600')\n                    .setTitle('‚ö†Ô∏è Admin Transfer Notice')\n                    .setDescription(`An admin has transferred **${formatLTC(amount)} LTC** from your account to ${toUser.username}`)\n                    .addFields({\n                        name: 'üí≥ Your New Balance',\n                        value: `${formatLTC(updatedSenderProfile.balance)} LTC`,\n                        inline: true\n                    })\n                    .setThumbnail('https://cryptologos.cc/logos/litecoin-ltc-logo.png')\n                    .setTimestamp();\n                \n                await senderDM.send({ embeds: [senderNotification] });\n            } catch (dmError) {\n                console.log('Could not send DM to sender:', dmError.message);\n            }\n\n            try {\n                // Notify the receiver\n                const receiverDM = await toUser.createDM();\n                const receiverNotification = new EmbedBuilder()\n                    .setColor('#00ff00')\n                    .setTitle('üí∞ Admin Transfer Received')\n                    .setDescription(`You received **${formatLTC(amount)} LTC** via admin transfer from ${fromUser.username}`)\n                    .addFields({\n                        name: 'üí≥ Your New Balance',\n                        value: `${formatLTC(updatedReceiverProfile.balance)} LTC`,\n                        inline: true\n                    })\n                    .setThumbnail('https://cryptologos.cc/logos/litecoin-ltc-logo.png')\n                    .setTimestamp();\n                \n                await receiverDM.send({ embeds: [receiverNotification] });\n            } catch (dmError) {\n                console.log('Could not send DM to receiver:', dmError.message);\n            }\n            \n        } catch (error) {\n            console.error('Admin transfer command error:', error);\n            \n            let errorMessage = 'Failed to process admin transfer. Please try again.';\n            \n            if (error.message === 'Insufficient balance') {\n                errorMessage = 'Insufficient balance for this transfer.';\n            }\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Admin Transfer Failed')\n                .setDescription(errorMessage)\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};","size_bytes":7974},"attached_assets/casino/commands/balance.js":{"content":"const { SlashCommandBuilder, EmbedBuilder } = require('discord.js');\nconst userProfiles = require('../utils/userProfiles.js');\nconst currencyConverter = require('../utils/currencyConverter.js');\nconst { formatLTC, formatUSD } = require('../utils/formatters.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('balance')\n        .setDescription('Check your current balance')\n        .addUserOption(option =>\n            option.setName('user')\n                .setDescription('User to check balance for (optional)')\n                .setRequired(false)\n        ),\n    \n    async execute(interaction) {\n        // Check if interaction is too old\n        const interactionAge = Date.now() - interaction.createdTimestamp;\n        if (interactionAge > 10 * 60 * 1000) {\n            console.log('Interaction trop ancienne, ignor√©e');\n            return;\n        }\n        \n        await interaction.deferReply();\n        \n        try {\n            const targetUser = interaction.options.getUser('user') || interaction.user;\n            const profile = userProfiles.getUserProfile(targetUser.id);\n            \n            // Get LTC price for USD conversion\n            let ltcPrice = null;\n            let eurPrice = null;\n            \n            try {\n                const [usdData, eurData] = await Promise.all([\n                    currencyConverter.getLitecoinPrice('USD'),\n                    currencyConverter.getLitecoinPrice('EUR')\n                ]);\n                ltcPrice = usdData.price;\n                eurPrice = eurData.price;\n            } catch (error) {\n                console.log('Could not fetch crypto prices:', error.message);\n            }\n            \n            const balanceEmbed = new EmbedBuilder()\n                .setColor('#f7931a')\n                .setTitle('üí∞ Balance Information')\n                .setAuthor({ \n                    name: targetUser.username, \n                    iconURL: targetUser.displayAvatarURL() \n                })\n                .addFields({\n                    name: 'ü™ô Litecoin Balance',\n                    value: `**${formatLTC(profile.balance)} LTC**`,\n                    inline: false\n                })\n                .setThumbnail('https://cryptologos.cc/logos/litecoin-ltc-logo.png')\n                .setTimestamp();\n            \n            // Add USD and EUR conversions if available\n            if (ltcPrice && eurPrice) {\n                const usdValue = profile.balance * ltcPrice;\n                const eurValue = profile.balance * eurPrice;\n                \n                balanceEmbed.addFields(\n                    {\n                        name: 'üíµ USD Equivalent',\n                        value: `$${formatUSD(usdValue)}`,\n                        inline: true\n                    },\n                    {\n                        name: 'üí∂ EUR Equivalent',\n                        value: `‚Ç¨${formatUSD(eurValue)}`,\n                        inline: true\n                    }\n                );\n            }\n            \n            // Add quick stats\n            if (profile.depositHistory.length > 0 || profile.withdrawalHistory.length > 0) {\n                balanceEmbed.addFields({\n                    name: 'üìä Quick Stats',\n                    value: `**Total Deposited:** ${formatLTC(profile.totalDeposited)} LTC\\n**Total Withdrawn:** ${formatLTC(profile.totalWithdrawn)} LTC\\n**Net Gain/Loss:** ${formatLTC(profile.totalDeposited - profile.totalWithdrawn - profile.balance)} LTC`,\n                    inline: false\n                });\n            }\n            \n            // Check if viewing someone else's balance\n            if (targetUser.id !== interaction.user.id) {\n                balanceEmbed.setFooter({ text: `Balance requested by ${interaction.user.username}` });\n            }\n            \n            await interaction.editReply({ embeds: [balanceEmbed] });\n            \n        } catch (error) {\n            console.error('Balance command error:', error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Error')\n                .setDescription('Failed to fetch balance information. Please try again.')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};","size_bytes":4361},"attached_assets/casino/commands/blackjack.js":{"content":"const { SlashCommandBuilder, EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle } = require('discord.js');\nconst userProfiles = require('../utils/userProfiles.js');\nconst securityManager = require('../utils/securityManager.js');\nconst logManager = require('../utils/logManager.js');\nconst { formatLTC } = require('../utils/formatters.js');\n\n// Card deck\nconst suits = ['‚ô†Ô∏è', '‚ô•Ô∏è', '‚ô¶Ô∏è', '‚ô£Ô∏è'];\nconst ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];\n\n// Active games storage\nconst activeGames = new Map();\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('blackjack')\n        .setDescription('Play Blackjack against the dealer')\n        .addNumberOption(option =>\n            option.setName('bet')\n                .setDescription('Amount to bet in LTC')\n                .setRequired(true)\n                .setMinValue(0.001)\n        ),\n    \n    async execute(interaction) {\n        // Check if interaction is too old\n        const interactionAge = Date.now() - interaction.createdTimestamp;\n        if (interactionAge > 10 * 60 * 1000) {\n            console.log('Interaction trop ancienne, ignor√©e');\n            return;\n        }\n        \n        await interaction.deferReply({ ephemeral: false });\n        \n        try {\n            const bet = interaction.options.getNumber('bet');\n            const userId = interaction.user.id;\n            \n            // Check if user has active game\n            if (activeGames.has(userId)) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Game Already Active')\n                    .setDescription('You already have an active blackjack game. Finish it first!')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Get user profile and verify balance\n            const profile = userProfiles.getUserProfile(userId);\n            \n            if (profile.balance < bet) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Insufficient Balance')\n                    .setDescription(`You need **${formatLTC(bet)} LTC** to play but only have **${formatLTC(profile.balance)} LTC**.`)\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Check password protection\n            const userSec = securityManager.getUserSecurity(userId);\n            if (!userSec.hasPassword) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ffaa00')\n                    .setTitle('üîí Password Required')\n                    .setDescription('You need to set a password before gambling. Use `/setpassword` first.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Deduct bet from balance\n            userProfiles.updateUserProfile(userId, { \n                balance: profile.balance - bet \n            });\n            \n            // Add wagered amount\n            securityManager.addWageredAmount(userId, bet);\n            \n            // Create new game\n            const game = createNewGame(bet, userId);\n            activeGames.set(userId, game);\n            \n            // Deal initial cards\n            dealInitialCards(game);\n            \n            // Create game embed\n            const gameEmbed = createGameEmbed(game, interaction.user);\n            const gameButtons = createGameButtons(game);\n            \n            await interaction.editReply({ \n                embeds: [gameEmbed],\n                components: [gameButtons]\n            });\n            \n            // Auto-timeout after 2 minutes\n            setTimeout(() => {\n                if (activeGames.has(userId)) {\n                    const timeoutGame = activeGames.get(userId);\n                    if (timeoutGame.status === 'playing') {\n                        timeoutGame.status = 'timeout';\n                        activeGames.delete(userId);\n                        console.log(`üïê Blackjack game timed out for ${interaction.user.username}`);\n                    }\n                }\n            }, 120000); // 2 minutes\n            \n        } catch (error) {\n            console.error('Erreur blackjack:', error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Error')\n                .setDescription('An error occurred while starting the blackjack game.')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};\n\nfunction createNewGame(bet, userId) {\n    return {\n        userId: userId,\n        bet: bet,\n        deck: createDeck(),\n        playerHand: [],\n        dealerHand: [],\n        playerValue: 0,\n        dealerValue: 0,\n        status: 'playing', // playing, won, lost, push, timeout\n        canDoubleDown: true,\n        startTime: Date.now()\n    };\n}\n\nfunction createDeck() {\n    const deck = [];\n    for (const suit of suits) {\n        for (const rank of ranks) {\n            deck.push({ suit, rank });\n        }\n    }\n    return shuffleDeck(deck);\n}\n\nfunction shuffleDeck(deck) {\n    for (let i = deck.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        [deck[i], deck[j]] = [deck[j], deck[i]];\n    }\n    return deck;\n}\n\nfunction dealCard(game) {\n    return game.deck.pop();\n}\n\nfunction dealInitialCards(game) {\n    // Deal 2 cards to player and dealer\n    game.playerHand.push(dealCard(game));\n    game.dealerHand.push(dealCard(game));\n    game.playerHand.push(dealCard(game));\n    game.dealerHand.push(dealCard(game));\n    \n    game.playerValue = calculateHandValue(game.playerHand);\n    game.dealerValue = calculateHandValue(game.dealerHand);\n    \n    // Check for natural blackjack\n    if (game.playerValue === 21) {\n        if (game.dealerValue === 21) {\n            game.status = 'push'; // Tie\n        } else {\n            game.status = 'blackjack'; // Player blackjack\n        }\n    }\n}\n\nfunction calculateHandValue(hand) {\n    let value = 0;\n    let aces = 0;\n    \n    for (const card of hand) {\n        if (card.rank === 'A') {\n            aces++;\n            value += 11;\n        } else if (['J', 'Q', 'K'].includes(card.rank)) {\n            value += 10;\n        } else {\n            value += parseInt(card.rank);\n        }\n    }\n    \n    // Handle aces\n    while (value > 21 && aces > 0) {\n        value -= 10;\n        aces--;\n    }\n    \n    return value;\n}\n\nfunction formatHand(hand, hideFirst = false) {\n    return hand.map((card, index) => {\n        if (hideFirst && index === 0) {\n            return 'üÉè';\n        }\n        return `${card.rank}${card.suit}`;\n    }).join(' ');\n}\n\nfunction createGameEmbed(game, user) {\n    const playerHandStr = formatHand(game.playerHand);\n    const dealerHandStr = formatHand(game.dealerHand, game.status === 'playing');\n    \n    let title = 'üÉè Blackjack Game';\n    let color = '#f7931a';\n    let description = `Bet: **${formatLTC(game.bet)} LTC**`;\n    \n    if (game.status === 'won') {\n        title = 'üéâ You Win!';\n        color = '#00ff00';\n        description = `You won **${formatLTC(game.bet * 2)} LTC**!`;\n    } else if (game.status === 'lost') {\n        title = 'üí∏ You Lost';\n        color = '#ff0000';\n        description = `You lost **${formatLTC(game.bet)} LTC**`;\n    } else if (game.status === 'push') {\n        title = 'ü§ù Push (Tie)';\n        color = '#ffaa00';\n        description = `Your bet of **${formatLTC(game.bet)} LTC** has been returned`;\n    } else if (game.status === 'blackjack') {\n        title = 'üéØ BLACKJACK!';\n        color = '#ffd700';\n        description = `You won **${formatLTC(game.bet * 2.5)} LTC** with Blackjack!`;\n    }\n    \n    const embed = new EmbedBuilder()\n        .setColor(color)\n        .setTitle(title)\n        .setDescription(description)\n        .addFields(\n            {\n                name: `üë§ ${user.username}'s Hand (${game.playerValue})`,\n                value: playerHandStr,\n                inline: false\n            },\n            {\n                name: `üé∞ Dealer's Hand ${game.status === 'playing' ? '(?)' : `(${game.dealerValue})`}`,\n                value: dealerHandStr,\n                inline: false\n            }\n        )\n        .setFooter({ text: 'Good luck!' })\n        .setTimestamp();\n    \n    if (game.status !== 'playing') {\n        const profile = userProfiles.getUserProfile(game.userId);\n        embed.addFields({\n            name: 'üí∞ New Balance',\n            value: `${formatLTC(profile.balance)} LTC`,\n            inline: true\n        });\n    }\n    \n    return embed;\n}\n\nfunction createGameButtons(game) {\n    const row = new ActionRowBuilder();\n    \n    if (game.status === 'playing') {\n        row.addComponents(\n            new ButtonBuilder()\n                .setCustomId('blackjack_hit')\n                .setLabel('Hit')\n                .setStyle(ButtonStyle.Primary)\n                .setEmoji('üéØ'),\n            new ButtonBuilder()\n                .setCustomId('blackjack_stand')\n                .setLabel('Stand')\n                .setStyle(ButtonStyle.Secondary)\n                .setEmoji('‚úã')\n        );\n        \n        if (game.canDoubleDown && game.playerHand.length === 2) {\n            const profile = userProfiles.getUserProfile(game.userId);\n            if (profile.balance >= game.bet) {\n                row.addComponents(\n                    new ButtonBuilder()\n                        .setCustomId('blackjack_double')\n                        .setLabel('Double Down')\n                        .setStyle(ButtonStyle.Success)\n                        .setEmoji('üí∞')\n                );\n            }\n        }\n    }\n    \n    return row;\n}\n\n// Export game functions for button handlers\nmodule.exports.activeGames = activeGames;\nmodule.exports.calculateHandValue = calculateHandValue;\nmodule.exports.dealCard = dealCard;\nmodule.exports.createGameEmbed = createGameEmbed;\nmodule.exports.createGameButtons = createGameButtons;\nmodule.exports.formatHand = formatHand;","size_bytes":10444},"attached_assets/casino/commands/cashout.js":{"content":"const { SlashCommandBuilder, EmbedBuilder } = require('discord.js');\nconst securityManager = require('../utils/securityManager.js');\nconst userProfiles = require('../utils/userProfiles.js');\nconst ltcWallet = require('../litecoin-casino-bot.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('cashout')\n        .setDescription('Withdraw your LTC balance (requires password and 100% wagering)')\n        .addStringOption(option =>\n            option.setName('address')\n                .setDescription('Your LTC address to withdraw to')\n                .setRequired(true)\n        )\n        .addNumberOption(option =>\n            option.setName('amount')\n                .setDescription('Amount to withdraw in LTC')\n                .setRequired(true)\n                .setMinValue(0.001)\n        )\n        .addStringOption(option =>\n            option.setName('password')\n                .setDescription('Your account password')\n                .setRequired(true)\n        ),\n    \n    async execute(interaction) {\n        await interaction.deferReply({ ephemeral: true });\n        \n        try {\n            const toAddress = interaction.options.getString('address');\n            const amount = interaction.options.getNumber('amount');\n            const password = interaction.options.getString('password');\n            const userId = interaction.user.id;\n            \n            // Check if user has a password set\n            const userSec = securityManager.getUserSecurity(userId);\n            if (!userSec.hasPassword) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå No Password Set')\n                    .setDescription('You need to set a password first using `/setpassword` to cashout.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Verify password\n            if (!securityManager.verifyUserPassword(userId, password)) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Wrong Password')\n                    .setDescription('The password you entered is incorrect.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Check cashout eligibility (100% wagering requirement)\n            const cashoutStatus = securityManager.canUserCashout(userId);\n            \n            if (!cashoutStatus.canCashout) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Cashout Not Allowed')\n                    .setDescription('You must wager at least 100% of your deposited amount before cashing out.')\n                    .addFields(\n                        {\n                            name: 'üìä Wagering Status',\n                            value: `**Deposited:** ${cashoutStatus.depositedAmount.toFixed(8)} LTC\\n**Wagered:** ${cashoutStatus.wageredAmount.toFixed(8)} LTC\\n**Progress:** ${cashoutStatus.wageredPercent.toFixed(1)}%`,\n                            inline: true\n                        },\n                        {\n                            name: 'üéØ Remaining to Wager',\n                            value: `${cashoutStatus.remainingToWager.toFixed(8)} LTC`,\n                            inline: true\n                        },\n                        {\n                            name: 'üí° How to Unlock Cashout',\n                            value: 'Play casino games to increase your wagered amount to 100% of deposits.',\n                            inline: false\n                        }\n                    )\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Check user balance\n            const profile = userProfiles.getUserProfile(userId);\n            \n            if (profile.balance < amount) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Insufficient Balance')\n                    .setDescription(`You don't have enough balance to withdraw.`)\n                    .addFields({\n                        name: 'üí∞ Available Balance',\n                        value: `${profile.balance.toFixed(8)} LTC`,\n                        inline: true\n                    })\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Find a source address with sufficient balance\n            const addresses = ltcWallet.loadAddresses();\n            let fromAddress = null;\n            \n            for (const addr of addresses) {\n                if (addr.balance >= amount) {\n                    fromAddress = addr.address;\n                    break;\n                }\n            }\n            \n            if (!fromAddress) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå No Suitable Address')\n                    .setDescription('No address found with sufficient balance for withdrawal.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Process withdrawal\n            const processingEmbed = new EmbedBuilder()\n                .setColor('#ffaa00')\n                .setTitle('‚è≥ Processing Withdrawal')\n                .setDescription('Your withdrawal is being processed...')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [processingEmbed] });\n            \n            // Execute withdrawal\n            const txid = await ltcWallet.withdraw(fromAddress, toAddress, amount);\n            \n            if (!txid) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Withdrawal Failed')\n                    .setDescription('Failed to process withdrawal. Please try again or contact support.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Update user profile\n            userProfiles.addWithdrawal(userId, amount, toAddress, txid);\n            \n            const successEmbed = new EmbedBuilder()\n                .setColor('#00ff00')\n                .setTitle('‚úÖ Withdrawal Successful')\n                .setDescription('Your withdrawal has been processed and broadcasted to the Litecoin network.')\n                .addFields(\n                    {\n                        name: 'üí∞ Amount',\n                        value: `${amount.toFixed(8)} LTC`,\n                        inline: true\n                    },\n                    {\n                        name: 'üìç Destination',\n                        value: `\\`${toAddress}\\``,\n                        inline: false\n                    },\n                    {\n                        name: 'üîó Transaction ID',\n                        value: `\\`${txid}\\``,\n                        inline: false\n                    },\n                    {\n                        name: '‚è∞ Status',\n                        value: 'Transaction broadcasted - confirmations pending',\n                        inline: false\n                    }\n                )\n                .setThumbnail('https://cryptologos.cc/logos/litecoin-ltc-logo.png')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [successEmbed] });\n            \n            console.log(`üí∏ Processed withdrawal: ${amount} LTC for user ${interaction.user.username} - TXID: ${txid}`);\n            \n        } catch (error) {\n            console.error('Cashout error:', error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Cashout Error')\n                .setDescription('An error occurred while processing your withdrawal. Please try again.')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};","size_bytes":8639},"attached_assets/casino/commands/casino.js":{"content":"const { SlashCommandBuilder, EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle } = require('discord.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('casino')\n        .setDescription('Open the casino main panel'),\n    \n    async execute(interaction) {\n        // Check if interaction is too old\n        const interactionAge = Date.now() - interaction.createdTimestamp;\n        if (interactionAge > 10 * 60 * 1000) {\n            console.log('Interaction trop ancienne, ignor√©e');\n            return;\n        }\n        \n        try {\n            const casinoEmbed = new EmbedBuilder()\n                .setColor('#f7931a')\n                .setTitle('üé∞ Litecoin Casino')\n                .setDescription('Welcome to the Litecoin Casino! Choose an option below to get started.')\n                .addFields(\n                    {\n                        name: 'üí∞ Add Balance',\n                        value: 'Generate a unique Litecoin address to deposit funds',\n                        inline: true\n                    },\n                    {\n                        name: 'üéÆ Games Available',\n                        value: 'Blackjack, Roulette - Start playing now!',\n                        inline: true\n                    },\n                    {\n                        name: 'üìä Profile',\n                        value: 'View your balance and transaction history',\n                        inline: true\n                    }\n                )\n                .setThumbnail('https://cryptologos.cc/logos/litecoin-ltc-logo.png')\n                .setImage('https://i.imgur.com/9KpZK8h.png') // Casino banner (optional)\n                .setFooter({ text: 'Secure ‚Ä¢ Fast ‚Ä¢ Transparent' })\n                .setTimestamp();\n            \n            const actionRow = new ActionRowBuilder()\n                .addComponents(\n                    new ButtonBuilder()\n                        .setCustomId('add_balance')\n                        .setLabel('üí∞ Add Balance')\n                        .setStyle(ButtonStyle.Success)\n                        .setEmoji('üí∞'),\n                    new ButtonBuilder()\n                        .setCustomId('view_profile')\n                        .setLabel('üë§ Profile')\n                        .setStyle(ButtonStyle.Primary)\n                        .setEmoji('üë§'),\n                    new ButtonBuilder()\n                        .setCustomId('leaderboard')\n                        .setLabel('üèÜ Leaderboard')\n                        .setStyle(ButtonStyle.Secondary)\n                        .setEmoji('üèÜ')\n                );\n            \n            // Games row (now functional!)\n            const gamesRow = new ActionRowBuilder()\n                .addComponents(\n                    new ButtonBuilder()\n                        .setCustomId('casino_blackjack')\n                        .setLabel('üÉè Blackjack')\n                        .setStyle(ButtonStyle.Primary)\n                        .setEmoji('üÉè'),\n                    new ButtonBuilder()\n                        .setCustomId('casino_roulette')\n                        .setLabel('üé∞ Roulette')\n                        .setStyle(ButtonStyle.Primary)\n                        .setEmoji('üé∞'),\n                    new ButtonBuilder()\n                        .setCustomId('casino_slots')\n                        .setLabel('üé≤ Slots')\n                        .setStyle(ButtonStyle.Secondary)\n                        .setEmoji('üé≤')\n                        .setDisabled(true) // Coming soon\n                );\n            \n            await interaction.reply({ \n                embeds: [casinoEmbed], \n                components: [actionRow, gamesRow]\n            });\n            \n        } catch (error) {\n            console.error('Casino command error:', error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Error')\n                .setDescription('Failed to load casino panel. Please try again.')\n                .setTimestamp();\n            \n            try {\n                if (interaction.replied || interaction.deferred) {\n                    await interaction.followUp({ embeds: [errorEmbed], ephemeral: true });\n                } else {\n                    await interaction.reply({ embeds: [errorEmbed], ephemeral: true });\n                }\n            } catch (replyError) {\n                console.error('Impossible de r√©pondre √† l\\'erreur casino:', replyError.message);\n            }\n        }\n    }\n};","size_bytes":4564},"attached_assets/casino/commands/changepassword.js":{"content":"const { SlashCommandBuilder, EmbedBuilder } = require('discord.js');\nconst securityManager = require('../utils/securityManager.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('changepassword')\n        .setDescription('Change your account password')\n        .addStringOption(option =>\n            option.setName('oldpassword')\n                .setDescription('Your current password')\n                .setRequired(true)\n        )\n        .addStringOption(option =>\n            option.setName('newpassword')\n                .setDescription('Your new password (minimum 6 characters)')\n                .setRequired(true)\n        ),\n    \n    async execute(interaction) {\n        await interaction.deferReply({ ephemeral: true });\n        \n        try {\n            const oldPassword = interaction.options.getString('oldpassword');\n            const newPassword = interaction.options.getString('newpassword');\n            \n            // Validate new password\n            if (newPassword.length < 6) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Invalid Password')\n                    .setDescription('New password must be at least 6 characters long.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Check if user has a password set\n            const userSec = securityManager.getUserSecurity(interaction.user.id);\n            if (!userSec.hasPassword) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå No Password Set')\n                    .setDescription('You need to set a password first using `/setpassword`.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Try to change password\n            const success = securityManager.changeUserPassword(interaction.user.id, oldPassword, newPassword);\n            \n            if (!success) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Wrong Password')\n                    .setDescription('Your current password is incorrect.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            const successEmbed = new EmbedBuilder()\n                .setColor('#00ff00')\n                .setTitle('‚úÖ Password Changed')\n                .setDescription('Your password has been successfully changed.')\n                .addFields({\n                    name: 'üîí Security',\n                    value: 'Your recovery key remains the same and is still valid.',\n                    inline: false\n                })\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [successEmbed] });\n            \n        } catch (error) {\n            console.error('Change password error:', error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Error')\n                .setDescription('Failed to change password. Please try again.')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};","size_bytes":3608},"attached_assets/casino/commands/coinflip.js":{"content":"const { SlashCommandBuilder, EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle } = require('discord.js');\nconst securityManager = require('../utils/securityManager.js');\nconst userProfiles = require('../utils/userProfiles.js');\nconst treasuryManager = require('../utils/treasuryManager.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('coinflip')\n        .setDescription('ü™ô Play coin flip - Choose heads or tails and double your bet!')\n        .addNumberOption(option =>\n            option.setName('amount')\n                .setDescription('Amount to bet in LTC')\n                .setRequired(true)\n                .setMinValue(0.001)\n                .setMaxValue(10)\n        )\n        .addStringOption(option =>\n            option.setName('choice')\n                .setDescription('Choose heads or tails')\n                .setRequired(true)\n                .addChoices(\n                    { name: 'ü¶Ö Heads', value: 'heads' },\n                    { name: '‚ö° Tails', value: 'tails' }\n                )\n        ),\n\n    async execute(interaction) {\n        await interaction.deferReply({ ephemeral: false });\n\n        try {\n            const amount = interaction.options.getNumber('amount');\n            const playerChoice = interaction.options.getString('choice');\n            const userId = interaction.user.id;\n\n            // Check if user has active gambling session\n            if (!securityManager.hasActiveGamblingSession(userId)) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#e74c3c')\n                    .setTitle('üîí No Active Session')\n                    .setDescription('You need to enable a gambling session first using `/enable`.')\n                    .addFields({\n                        name: 'üéÆ How to Start',\n                        value: 'Use `/enable [minutes] [password]` to start a gambling session.',\n                        inline: false\n                    })\n                    .setTimestamp();\n\n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n\n            // Check treasury bet limits\n            const maxBet = treasuryManager.getMaxBetLimit();\n            if (amount > maxBet) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#e74c3c')\n                    .setTitle('‚ùå Bet Too High')\n                    .setDescription(`Maximum bet allowed is ${maxBet.toFixed(8)} LTC (30% of casino funds).`)\n                    .addFields({\n                        name: 'üí∞ Current Limits',\n                        value: `**Your bet:** ${amount.toFixed(8)} LTC\\n**Maximum allowed:** ${maxBet.toFixed(8)} LTC\\n**Casino funds:** ${treasuryManager.getCurrentBalance().toFixed(8)} LTC`,\n                        inline: false\n                    })\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n\n            // Check user balance\n            const profile = userProfiles.getUserProfile(userId);\n            if (profile.balance < amount) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#e74c3c')\n                    .setTitle('‚ùå Insufficient Balance')\n                    .setDescription('You don\\'t have enough balance to place this bet.')\n                    .addFields({\n                        name: 'üí∞ Available Balance',\n                        value: `${profile.balance.toFixed(8)} LTC`,\n                        inline: true\n                    })\n                    .setTimestamp();\n\n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n\n            // Flip the coin\n            const coinResult = Math.random() < 0.5 ? 'heads' : 'tails';\n            const won = playerChoice === coinResult;\n            const resultAmount = won ? amount * 2 : 0;\n\n            // Record treasury transaction\n            if (won) {\n                treasuryManager.recordPayout(amount, interaction.user.id, 'coinflip', {\n                    originalAmount: amount,\n                    winAmount: resultAmount,\n                    choice: playerChoice,\n                    result: coinResult\n                });\n            } else {\n                treasuryManager.recordHouseWin(amount, interaction.user.id, 'coinflip', {\n                    lostAmount: amount,\n                    choice: playerChoice,\n                    result: coinResult\n                });\n            }\n\n            // Update balance\n            const newBalance = profile.balance - amount + resultAmount;\n            userProfiles.updateUserProfile(userId, { balance: newBalance });\n\n            // Add wagered amount\n            securityManager.addWageredAmount(userId, amount);\n\n            // Check cashout status\n            const cashoutStatus = securityManager.canUserCashout(userId);\n\n            // Create result embed with coin flip animation\n            const resultEmbed = new EmbedBuilder()\n                .setColor(won ? '#2ecc71' : '#e74c3c')\n                .setTitle('ü™ô COIN FLIP RESULT')\n                .setDescription(`**${interaction.user.username}** chose **${playerChoice === 'heads' ? 'ü¶Ö Heads' : '‚ö° Tails'}**`)\n                .addFields(\n                    {\n                        name: 'üéØ Game Result',\n                        value: `**Coin landed on:** ${coinResult === 'heads' ? 'ü¶Ö **HEADS**' : '‚ö° **TAILS**'}\\n**Your choice:** ${playerChoice === 'heads' ? 'ü¶Ö Heads' : '‚ö° Tails'}\\n**Result:** ${won ? 'üéâ **YOU WON!**' : 'üíî **YOU LOST**'}`,\n                        inline: false\n                    },\n                    {\n                        name: 'üí∞ Financial Summary',\n                        value: `**Bet Amount:** ${amount.toFixed(8)} LTC\\n**${won ? 'Winnings' : 'Lost'}:** ${won ? resultAmount.toFixed(8) : amount.toFixed(8)} LTC\\n**Net Change:** ${won ? '+' : '-'}${Math.abs(resultAmount - amount).toFixed(8)} LTC`,\n                        inline: true\n                    },\n                    {\n                        name: 'üí≥ Balance Update',\n                        value: `**Previous:** ${profile.balance.toFixed(8)} LTC\\n**Current:** ${newBalance.toFixed(8)} LTC`,\n                        inline: true\n                    },\n                    {\n                        name: 'üìä Cashout Status',\n                        value: `**Progress:** ${cashoutStatus.wageredPercent.toFixed(1)}%\\n**Can Cashout:** ${cashoutStatus.canCashout ? '‚úÖ Yes' : '‚ùå No'}\\n**Remaining:** ${cashoutStatus.remainingToWager.toFixed(8)} LTC`,\n                        inline: false\n                    }\n                )\n                .setThumbnail(coinResult === 'heads' ? \n                    'https://media.giphy.com/media/l0ErFafpUCQTQFMSk/giphy.gif' : \n                    'https://media.giphy.com/media/l0ErYcNCCW3V3pnig/giphy.gif'\n                )\n                .setFooter({ \n                    text: `ü™ô ${won ? 'Lucky flip!' : 'Better luck next time!'} ‚Ä¢ Casino Bot`,\n                    iconURL: 'https://cryptologos.cc/logos/litecoin-ltc-logo.png'\n                })\n                .setTimestamp();\n\n            // Add special effects for big wins\n            if (won && amount >= 0.01) {\n                resultEmbed.setImage('https://media.giphy.com/media/g9582DNuQppxC/giphy.gif');\n            }\n\n            // Create action buttons for continuing play\n            const actionRow = this.createGameActionButtons(newBalance, cashoutStatus.canCashout);\n\n            await interaction.editReply({\n                embeds: [resultEmbed],\n                components: actionRow ? [actionRow] : []\n            });\n\n            console.log(`ü™ô ${interaction.user.username} played coinflip: ${playerChoice} vs ${coinResult} - ${won ? 'WON' : 'LOST'} ${amount.toFixed(8)} LTC`);\n\n        } catch (error) {\n            console.error('Coin flip error:', error);\n\n            const errorEmbed = new EmbedBuilder()\n                .setColor('#e74c3c')\n                .setTitle('‚ùå Game Error')\n                .setDescription('An error occurred during the coin flip. Please try again.')\n                .setTimestamp();\n\n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    },\n\n    createGameActionButtons(balance, canCashout) {\n        if (balance < 0.001) return null;\n\n        const actionRow = new ActionRowBuilder()\n            .addComponents(\n                new ButtonBuilder()\n                    .setCustomId('coinflip_again_small')\n                    .setLabel('ü™ô Flip Again (0.001)')\n                    .setStyle(ButtonStyle.Primary)\n                    .setEmoji('ü™ô'),\n                new ButtonBuilder()\n                    .setCustomId('coinflip_again_medium')\n                    .setLabel('üéØ Medium Bet (0.01)')\n                    .setStyle(ButtonStyle.Secondary)\n                    .setEmoji('üéØ')\n                    .setDisabled(balance < 0.01),\n                new ButtonBuilder()\n                    .setCustomId('coinflip_again_big')\n                    .setLabel('üíé High Roller (0.1)')\n                    .setStyle(ButtonStyle.Danger)\n                    .setEmoji('üíé')\n                    .setDisabled(balance < 0.1)\n            );\n\n        if (canCashout) {\n            actionRow.addComponents(\n                new ButtonBuilder()\n                    .setCustomId('quick_cashout')\n                    .setLabel('üí∞ Cashout')\n                    .setStyle(ButtonStyle.Success)\n                    .setEmoji('üí∞')\n            );\n        }\n\n        return actionRow;\n    }\n};","size_bytes":9725},"attached_assets/casino/commands/convert-eur-usd.js":{"content":"const { SlashCommandBuilder, EmbedBuilder } = require('discord.js');\nconst currencyConverter = require('../utils/currencyConverter.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('convert-eur-usd')\n        .setDescription('Convert EUR to USD')\n        .addNumberOption(option =>\n            option.setName('amount')\n                .setDescription('Amount in EUR to convert')\n                .setRequired(true)\n                .setMinValue(0.01)\n        ),\n    \n    async execute(interaction) {\n        await interaction.deferReply();\n        \n        try {\n            const amount = interaction.options.getNumber('amount');\n            \n            // Perform currency conversion\n            const conversion = await currencyConverter.convertCurrency(amount, 'EUR', 'USD');\n            \n            const conversionEmbed = new EmbedBuilder()\n                .setColor('#4CAF50')\n                .setTitle('üí± Currency Conversion')\n                .setDescription('**EUR ‚Üí USD**')\n                .addFields(\n                    {\n                        name: 'üá™üá∫ Euro Amount',\n                        value: `‚Ç¨${conversion.originalAmount.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`,\n                        inline: true\n                    },\n                    {\n                        name: 'üá∫üá∏ US Dollar Equivalent',\n                        value: `$${conversion.convertedAmount.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`,\n                        inline: true\n                    },\n                    {\n                        name: 'üìä Exchange Rate',\n                        value: `1 EUR = $${conversion.exchangeRate.toFixed(4)} USD`,\n                        inline: false\n                    }\n                )\n                .setFooter({ \n                    text: 'Exchange rates are updated in real-time' \n                })\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [conversionEmbed] });\n            \n        } catch (error) {\n            console.error('EUR to USD conversion error:', error);\n            \n            let errorMessage = 'Failed to convert currency. Please try again later.';\n            \n            if (error.message.includes('Amount must be greater than 0')) {\n                errorMessage = 'Please enter a valid amount greater than 0.';\n            } else if (error.message.includes('Failed to fetch exchange rate')) {\n                errorMessage = 'Currency conversion service is temporarily unavailable.';\n            }\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Conversion Failed')\n                .setDescription(errorMessage)\n                .addFields({\n                    name: 'üí° Tip',\n                    value: 'Exchange rates are fetched from external APIs. Please try again in a few moments.',\n                    inline: false\n                })\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};","size_bytes":3206},"attached_assets/casino/commands/convert-usd-eur.js":{"content":"const { SlashCommandBuilder, EmbedBuilder } = require('discord.js');\nconst currencyConverter = require('../utils/currencyConverter.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('convert-usd-eur')\n        .setDescription('Convert USD to EUR')\n        .addNumberOption(option =>\n            option.setName('amount')\n                .setDescription('Amount in USD to convert')\n                .setRequired(true)\n                .setMinValue(0.01)\n        ),\n    \n    async execute(interaction) {\n        await interaction.deferReply();\n        \n        try {\n            const amount = interaction.options.getNumber('amount');\n            \n            // Perform currency conversion\n            const conversion = await currencyConverter.convertCurrency(amount, 'USD', 'EUR');\n            \n            const conversionEmbed = new EmbedBuilder()\n                .setColor('#4CAF50')\n                .setTitle('üí± Currency Conversion')\n                .setDescription('**USD ‚Üí EUR**')\n                .addFields(\n                    {\n                        name: 'üá∫üá∏ US Dollar Amount',\n                        value: `$${conversion.originalAmount.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`,\n                        inline: true\n                    },\n                    {\n                        name: 'üá™üá∫ Euro Equivalent',\n                        value: `‚Ç¨${conversion.convertedAmount.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`,\n                        inline: true\n                    },\n                    {\n                        name: 'üìä Exchange Rate',\n                        value: `1 USD = ‚Ç¨${conversion.exchangeRate.toFixed(4)} EUR`,\n                        inline: false\n                    }\n                )\n                .setFooter({ \n                    text: 'Exchange rates are updated in real-time' \n                })\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [conversionEmbed] });\n            \n        } catch (error) {\n            console.error('USD to EUR conversion error:', error);\n            \n            let errorMessage = 'Failed to convert currency. Please try again later.';\n            \n            if (error.message.includes('Amount must be greater than 0')) {\n                errorMessage = 'Please enter a valid amount greater than 0.';\n            } else if (error.message.includes('Failed to fetch exchange rate')) {\n                errorMessage = 'Currency conversion service is temporarily unavailable.';\n            }\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Conversion Failed')\n                .setDescription(errorMessage)\n                .addFields({\n                    name: 'üí° Tip',\n                    value: 'Exchange rates are fetched from external APIs. Please try again in a few moments.',\n                    inline: false\n                })\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};","size_bytes":3208},"attached_assets/casino/commands/createsession.js":{"content":"const { SlashCommandBuilder, EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle, StringSelectMenuBuilder } = require('discord.js');\nconst sessionManager = require('../utils/sessionManager.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('createsession')\n        .setDescription('Create a private gaming session with friends')\n        .addStringOption(option =>\n            option.setName('type')\n                .setDescription('Type of gaming session')\n                .setRequired(true)\n                .addChoices(\n                    { name: 'üé∞ General Casino', value: 'general' },\n                    { name: 'üÉè Blackjack Tournament', value: 'blackjack' },\n                    { name: 'üéØ Roulette Party', value: 'roulette' },\n                    { name: 'üé≤ High Stakes', value: 'highstakes' },\n                    { name: 'üë• Group Games', value: 'group' }\n                )\n        )\n        .addIntegerOption(option =>\n            option.setName('duration')\n                .setDescription('Session duration in minutes (15-360)')\n                .setMinValue(15)\n                .setMaxValue(360)\n        )\n        .addIntegerOption(option =>\n            option.setName('maxplayers')\n                .setDescription('Maximum number of players (2-20)')\n                .setMinValue(2)\n                .setMaxValue(20)\n        )\n        .addNumberOption(option =>\n            option.setName('minbet')\n                .setDescription('Minimum bet amount in LTC')\n                .setMinValue(0.001)\n                .setMaxValue(1.0)\n        )\n        .addNumberOption(option =>\n            option.setName('maxbet')\n                .setDescription('Maximum bet amount in LTC')\n                .setMinValue(0.001)\n                .setMaxValue(100.0)\n        ),\n\n    async execute(interaction) {\n        await interaction.deferReply({ ephemeral: false });\n\n        try {\n            const sessionType = interaction.options.getString('type');\n            const duration = interaction.options.getInteger('duration') || 60;\n            const maxParticipants = interaction.options.getInteger('maxplayers') || 6;\n            const minBet = interaction.options.getNumber('minbet') || 0.001;\n            const maxBet = interaction.options.getNumber('maxbet') || 1.0;\n\n            // Check if user is already in a session\n            const existingSession = sessionManager.isUserInSession(interaction.user.id);\n            if (existingSession) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#e74c3c')\n                    .setTitle('‚ùå Already in Session')\n                    .setDescription('You are already in an active gaming session!')\n                    .addFields({\n                        name: 'üéÆ Current Session',\n                        value: `**Type:** ${existingSession.sessionType}\\n**Channel:** <#${existingSession.channelId}>`,\n                        inline: false\n                    })\n                    .setTimestamp();\n\n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n\n            // Validate bet limits\n            if (minBet >= maxBet) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#e74c3c')\n                    .setTitle('‚ùå Invalid Bet Limits')\n                    .setDescription('Minimum bet must be less than maximum bet!')\n                    .setTimestamp();\n\n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n\n            const options = {\n                duration,\n                maxParticipants,\n                minBet,\n                maxBet,\n                isPublic: false,\n                allowSpectators: true\n            };\n\n            // Create the session\n            const result = await sessionManager.createPrivateSession(\n                interaction.guild,\n                interaction.user,\n                sessionType,\n                options\n            );\n\n            if (result.success) {\n                const successEmbed = new EmbedBuilder()\n                    .setColor('#2ecc71')\n                    .setTitle('üéâ Gaming Session Created!')\n                    .setDescription(`Your private ${sessionType} session has been created successfully!`)\n                    .addFields(\n                        {\n                            name: 'üè† Your Private Room',\n                            value: `${result.channel}\\nClick the link to enter your session!`,\n                            inline: false\n                        },\n                        {\n                            name: 'üéÆ Session Details',\n                            value: `**Type:** ${sessionType.charAt(0).toUpperCase() + sessionType.slice(1)}\\n**Duration:** ${duration} minutes\\n**Max Players:** ${maxParticipants}`,\n                            inline: true\n                        },\n                        {\n                            name: 'üí∞ Betting Limits',\n                            value: `**Min Bet:** ${minBet} LTC\\n**Max Bet:** ${maxBet} LTC`,\n                            inline: true\n                        },\n                        {\n                            name: 'üéØ Next Steps',\n                            value: '‚Ä¢ Invite friends to your session\\n‚Ä¢ Configure additional settings\\n‚Ä¢ Start playing games!\\n‚Ä¢ Have fun! üéä',\n                            inline: false\n                        }\n                    )\n                    .setThumbnail(interaction.user.displayAvatarURL({ dynamic: true }))\n                    .setFooter({ text: `Session ID: ${result.session.id}` })\n                    .setTimestamp();\n\n                const actionRow = new ActionRowBuilder()\n                    .addComponents(\n                        new ButtonBuilder()\n                            .setLabel('üöÄ Go to Session')\n                            .setStyle(ButtonStyle.Link)\n                            .setURL(`https://discord.com/channels/${interaction.guild.id}/${result.channel.id}`)\n                            .setEmoji('üöÄ'),\n                        new ButtonBuilder()\n                            .setCustomId(`session_invite_${result.session.id}`)\n                            .setLabel('üë• Invite Friends')\n                            .setStyle(ButtonStyle.Primary)\n                            .setEmoji('üë•')\n                    );\n\n                await interaction.editReply({ \n                    embeds: [successEmbed],\n                    components: [actionRow]\n                });\n\n                console.log(`üéÆ New gaming session created by ${interaction.user.username}: ${result.session.id}`);\n\n            } else {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#e74c3c')\n                    .setTitle('‚ùå Session Creation Failed')\n                    .setDescription(`Failed to create gaming session: ${result.error}`)\n                    .setTimestamp();\n\n                await interaction.editReply({ embeds: [errorEmbed] });\n            }\n\n        } catch (error) {\n            console.error('Create session error:', error);\n\n            const errorEmbed = new EmbedBuilder()\n                .setColor('#e74c3c')\n                .setTitle('‚ùå Unexpected Error')\n                .setDescription('An error occurred while creating your gaming session. Please try again.')\n                .setTimestamp();\n\n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};","size_bytes":7586},"attached_assets/casino/commands/enable.js":{"content":"const { SlashCommandBuilder, EmbedBuilder } = require('discord.js');\nconst securityManager = require('../utils/securityManager.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('enable')\n        .setDescription('Enable gambling session with time limit (requires password)')\n        .addIntegerOption(option =>\n            option.setName('minutes')\n                .setDescription('Session duration in minutes (1-60)')\n                .setRequired(true)\n                .setMinValue(1)\n                .setMaxValue(60)\n        )\n        .addStringOption(option =>\n            option.setName('password')\n                .setDescription('Your account password')\n                .setRequired(true)\n        ),\n    \n    async execute(interaction) {\n        await interaction.deferReply({ ephemeral: true });\n        \n        try {\n            const minutes = interaction.options.getInteger('minutes');\n            const password = interaction.options.getString('password');\n            \n            // Check if user has a password set\n            const userSec = securityManager.getUserSecurity(interaction.user.id);\n            if (!userSec.hasPassword) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå No Password Set')\n                    .setDescription('You need to set a password first using `/setpassword` to enable gambling sessions.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Verify password\n            if (!securityManager.verifyUserPassword(interaction.user.id, password)) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Wrong Password')\n                    .setDescription('The password you entered is incorrect.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Check if user already has an active session\n            if (securityManager.hasActiveGamblingSession(interaction.user.id)) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ffaa00')\n                    .setTitle('‚ö†Ô∏è Session Already Active')\n                    .setDescription('You already have an active gambling session. Wait for it to expire before starting a new one.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Start gambling session\n            const endTime = securityManager.startGamblingSession(interaction.user.id, minutes);\n            \n            const successEmbed = new EmbedBuilder()\n                .setColor('#00ff00')\n                .setTitle('üé∞ Gambling Session Enabled')\n                .setDescription(`Your gambling session is now active for **${minutes} minute${minutes > 1 ? 's' : ''}**.`)\n                .addFields(\n                    {\n                        name: '‚è∞ Session Details',\n                        value: `**Started:** <t:${Math.floor(Date.now()/1000)}:T>\\n**Ends:** <t:${Math.floor(endTime.getTime()/1000)}:T>\\n**Duration:** ${minutes} minute${minutes > 1 ? 's' : ''}`,\n                        inline: false\n                    },\n                    {\n                        name: 'üéÆ What you can do now',\n                        value: '‚Ä¢ Play casino games\\n‚Ä¢ Place bets\\n‚Ä¢ Use gambling features\\n‚Ä¢ All protected by your session',\n                        inline: true\n                    },\n                    {\n                        name: 'üîí Security',\n                        value: '‚Ä¢ Session auto-expires\\n‚Ä¢ Password protected\\n‚Ä¢ Secure gambling environment',\n                        inline: true\n                    }\n                )\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [successEmbed] });\n            \n        } catch (error) {\n            console.error('Enable gambling session error:', error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Error')\n                .setDescription('Failed to enable gambling session. Please try again.')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};","size_bytes":4646},"attached_assets/casino/commands/givebal.js":{"content":"const { SlashCommandBuilder, EmbedBuilder } = require('discord.js');\nconst userProfiles = require('../utils/userProfiles.js');\nconst { formatLTC } = require('../utils/formatters.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('givebal')\n        .setDescription('Transfer balance to another user')\n        .addUserOption(option =>\n            option.setName('user')\n                .setDescription('User to transfer balance to')\n                .setRequired(true)\n        )\n        .addNumberOption(option =>\n            option.setName('amount')\n                .setDescription('Amount to transfer (in LTC)')\n                .setRequired(true)\n                .setMinValue(0.00000001)\n        ),\n    \n    async execute(interaction) {\n        await interaction.deferReply();\n        \n        try {\n            const targetUser = interaction.options.getUser('user');\n            const amount = interaction.options.getNumber('amount');\n            const fromUserId = interaction.user.id;\n            const toUserId = targetUser.id;\n            \n            // Validation checks\n            if (fromUserId === toUserId) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Invalid Transfer')\n                    .setDescription('You cannot transfer balance to yourself!')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            if (amount <= 0) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Invalid Amount')\n                    .setDescription('Amount must be greater than 0!')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Check sender's balance\n            const senderProfile = userProfiles.getUserProfile(fromUserId);\n            \n            if (senderProfile.balance < amount) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Insufficient Balance')\n                    .setDescription(`You don't have enough balance!\\n\\n**Your Balance:** ${formatLTC(senderProfile.balance)} LTC\\n**Required:** ${formatLTC(amount)} LTC`)\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Perform the transfer\n            const transfer = userProfiles.transferBalance(fromUserId, toUserId, amount);\n            \n            // Get updated profiles\n            const updatedSenderProfile = userProfiles.getUserProfile(fromUserId);\n            const updatedReceiverProfile = userProfiles.getUserProfile(toUserId);\n            \n            const successEmbed = new EmbedBuilder()\n                .setColor('#00ff00')\n                .setTitle('‚úÖ Transfer Successful')\n                .setDescription(`Successfully transferred **${formatLTC(amount)} LTC** to ${targetUser}`)\n                .addFields(\n                    {\n                        name: 'üë§ From',\n                        value: `${interaction.user}\\n**New Balance:** ${formatLTC(updatedSenderProfile.balance)} LTC`,\n                        inline: true\n                    },\n                    {\n                        name: 'üë§ To',\n                        value: `${targetUser}\\n**New Balance:** ${formatLTC(updatedReceiverProfile.balance)} LTC`,\n                        inline: true\n                    },\n                    {\n                        name: 'üìã Transaction Details',\n                        value: `**Amount:** ${formatLTC(amount)} LTC\\n**Date:** ${new Date(transfer.timestamp).toLocaleString()}\\n**ID:** ${transfer.timestamp}`,\n                        inline: false\n                    }\n                )\n                .setThumbnail('https://cryptologos.cc/logos/litecoin-ltc-logo.png')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [successEmbed] });\n            \n            // Try to notify the receiver (if they share a server)\n            try {\n                const receiverDM = await targetUser.createDM();\n                \n                const notificationEmbed = new EmbedBuilder()\n                    .setColor('#00ff00')\n                    .setTitle('üí∞ Balance Received')\n                    .setDescription(`You received **${amount.toFixed(8)} LTC** from ${interaction.user.username}!`)\n                    .addFields({\n                        name: 'üí≥ Your New Balance',\n                        value: `${updatedReceiverProfile.balance.toFixed(8)} LTC`,\n                        inline: true\n                    })\n                    .setThumbnail('https://cryptologos.cc/logos/litecoin-ltc-logo.png')\n                    .setTimestamp();\n                \n                await receiverDM.send({ embeds: [notificationEmbed] });\n            } catch (dmError) {\n                console.log('Could not send DM notification:', dmError.message);\n                // This is not critical, so we don't show error to user\n            }\n            \n        } catch (error) {\n            console.error('Transfer command error:', error);\n            \n            let errorMessage = 'Failed to process transfer. Please try again.';\n            \n            if (error.message === 'Insufficient balance') {\n                errorMessage = 'Insufficient balance for this transfer.';\n            }\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Transfer Failed')\n                .setDescription(errorMessage)\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};","size_bytes":6057},"attached_assets/casino/commands/ownertransfer.js":{"content":"const { SlashCommandBuilder, EmbedBuilder } = require('discord.js');\nconst userProfiles = require('../utils/userProfiles.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('ownertransfer')\n        .setDescription('üîë Owner only: Transfer balance between any users')\n        .addUserOption(option =>\n            option.setName('fromuser')\n                .setDescription('User to transfer FROM')\n                .setRequired(true)\n        )\n        .addUserOption(option =>\n            option.setName('touser')\n                .setDescription('User to transfer TO')\n                .setRequired(true)\n        )\n        .addNumberOption(option =>\n            option.setName('amount')\n                .setDescription('Amount to transfer (in LTC)')\n                .setRequired(true)\n                .setMinValue(0.00000001)\n                .setMaxValue(100)\n        ),\n\n    async execute(interaction) {\n        await interaction.deferReply({ ephemeral: false });\n\n        try {\n            // Check if user is owner\n            if (interaction.user.id !== process.env.OWNER_ID) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#e74c3c')\n                    .setTitle('‚ùå Acc√®s Refus√©')\n                    .setDescription('Cette commande est r√©serv√©e au propri√©taire du bot.')\n                    .setTimestamp();\n\n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n\n            const fromUser = interaction.options.getUser('fromuser');\n            const toUser = interaction.options.getUser('touser');\n            const amount = parseFloat(interaction.options.getNumber('amount'));\n\n            // Validate amount\n            if (amount <= 0 || isNaN(amount)) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#e74c3c')\n                    .setTitle('‚ùå Montant Invalide')\n                    .setDescription('Le montant doit √™tre sup√©rieur √† 0.')\n                    .setTimestamp();\n\n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n\n            // Get user profiles\n            const fromProfile = userProfiles.getUserProfile(fromUser.id);\n            const toProfile = userProfiles.getUserProfile(toUser.id);\n\n            // Check if fromUser has sufficient balance\n            if (fromProfile.balance < amount) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#e74c3c')\n                    .setTitle('‚ùå Fonds Insuffisants')\n                    .setDescription(`${fromUser.username} n'a que ${fromProfile.balance.toFixed(8)} LTC disponible.`)\n                    .addFields({\n                        name: 'üí∞ D√©tails',\n                        value: `**Demand√©:** ${amount.toFixed(8)} LTC\\n**Disponible:** ${fromProfile.balance.toFixed(8)} LTC\\n**Manquant:** ${(amount - fromProfile.balance).toFixed(8)} LTC`,\n                        inline: false\n                    })\n                    .setTimestamp();\n\n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n\n            // Perform the transfer\n            const oldFromBalance = fromProfile.balance;\n            const oldToBalance = toProfile.balance;\n\n            fromProfile.balance -= amount;\n            toProfile.balance += amount;\n\n            // Update profiles\n            userProfiles.updateUserProfile(fromUser.id, fromProfile);\n            userProfiles.updateUserProfile(toUser.id, toProfile);\n\n            // Create success embed\n            const successEmbed = new EmbedBuilder()\n                .setColor('#2ecc71')\n                .setTitle('‚úÖ Transfert R√©alis√©')\n                .setDescription(`**${amount.toFixed(8)} LTC** transf√©r√© avec succ√®s!`)\n                .addFields(\n                    {\n                        name: 'üì§ √âmetteur',\n                        value: `**${fromUser.username}**\\n*Ancien:* ${oldFromBalance.toFixed(8)} LTC\\n*Nouveau:* ${fromProfile.balance.toFixed(8)} LTC`,\n                        inline: true\n                    },\n                    {\n                        name: 'üì• Destinataire',\n                        value: `**${toUser.username}**\\n*Ancien:* ${oldToBalance.toFixed(8)} LTC\\n*Nouveau:* ${toProfile.balance.toFixed(8)} LTC`,\n                        inline: true\n                    },\n                    {\n                        name: 'üîó Transaction',\n                        value: `**Montant:** ${amount.toFixed(8)} LTC\\n**Par:** ${interaction.user.username}\\n**Type:** Transfert Owner`,\n                        inline: false\n                    }\n                )\n                .setThumbnail('https://cryptologos.cc/logos/litecoin-ltc-logo.png')\n                .setFooter({ text: `üîë Transfert autoris√© par le propri√©taire` })\n                .setTimestamp();\n\n            await interaction.editReply({ embeds: [successEmbed] });\n\n            console.log(`üí∏ Owner transfer: ${amount.toFixed(8)} LTC from ${fromUser.username} to ${toUser.username} by ${interaction.user.username}`);\n\n        } catch (error) {\n            console.error('Owner transfer error:', error);\n\n            const errorEmbed = new EmbedBuilder()\n                .setColor('#e74c3c')\n                .setTitle('‚ùå Erreur de Transfert')\n                .setDescription('Une erreur est survenue lors du transfert.')\n                .setTimestamp();\n\n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};","size_bytes":5596},"attached_assets/casino/commands/profile.js":{"content":"const { SlashCommandBuilder, EmbedBuilder } = require('discord.js');\nconst userProfiles = require('../utils/userProfiles.js');\nconst currencyConverter = require('../utils/currencyConverter.js');\nconst { formatLTC, formatUSD } = require('../utils/formatters.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('profile')\n        .setDescription('View your casino profile and balance'),\n    \n    async execute(interaction) {\n        // Check if interaction is too old (Discord timeout is 15 minutes)\n        const interactionAge = Date.now() - interaction.createdTimestamp;\n        if (interactionAge > 10 * 60 * 1000) { // 10 minutes safety margin\n            console.log('Interaction trop ancienne, ignor√©e');\n            return;\n        }\n        \n        await interaction.deferReply();\n        \n        try {\n            const profile = userProfiles.getUserProfile(interaction.user.id);\n            \n            // Get recent deposit and withdrawal\n            const recentDeposit = profile.depositHistory.slice(-1)[0];\n            const recentWithdrawal = profile.withdrawalHistory.slice(-1)[0];\n            \n            // Try to get LTC price for reference\n            let ltcPrice = null;\n            try {\n                const priceData = await currencyConverter.getLitecoinPrice('USD');\n                ltcPrice = priceData.price;\n            } catch (error) {\n                console.log('Could not fetch LTC price:', error.message);\n            }\n            \n            const profileEmbed = new EmbedBuilder()\n                .setColor('#f7931a')\n                .setTitle('üé∞ Casino Profile')\n                .setAuthor({ \n                    name: interaction.user.username, \n                    iconURL: interaction.user.displayAvatarURL() \n                })\n                .addFields(\n                    { \n                        name: 'üí∞ Current Balance', \n                        value: `**${formatLTC(profile.balance)} LTC**${ltcPrice ? `\\n‚âà $${formatUSD(profile.balance * ltcPrice)} USD` : ''}`, \n                        inline: true \n                    },\n                    { \n                        name: 'üìä Statistics', \n                        value: `**Deposited:** ${formatLTC(profile.totalDeposited)} LTC\\n**Withdrawn:** ${formatLTC(profile.totalWithdrawn)} LTC\\n**Net:** ${formatLTC(profile.totalDeposited - profile.totalWithdrawn)} LTC`, \n                        inline: true \n                    },\n                    { \n                        name: 'üéÆ Activity', \n                        value: `**Deposits:** ${profile.depositHistory.length}\\n**Withdrawals:** ${profile.withdrawalHistory.length}\\n**Games Played:** ${profile.gameHistory.length}`, \n                        inline: true \n                    }\n                )\n                .setThumbnail('https://cryptologos.cc/logos/litecoin-ltc-logo.png')\n                .setFooter({ \n                    text: `Member since ${new Date(profile.createdAt).toLocaleDateString()}` \n                })\n                .setTimestamp();\n            \n            // Add recent activity if available\n            if (recentDeposit || recentWithdrawal) {\n                let recentActivity = '';\n                \n                if (recentDeposit) {\n                    const depositDate = new Date(recentDeposit.timestamp).toLocaleDateString();\n                    recentActivity += `üì• **Last Deposit:** ${formatLTC(recentDeposit.amount)} LTC (${depositDate})\\n`;\n                }\n                \n                if (recentWithdrawal) {\n                    const withdrawalDate = new Date(recentWithdrawal.timestamp).toLocaleDateString();\n                    recentActivity += `üì§ **Last Withdrawal:** ${formatLTC(recentWithdrawal.amount)} LTC (${withdrawalDate})`;\n                }\n                \n                profileEmbed.addFields({\n                    name: 'üìà Recent Activity',\n                    value: recentActivity,\n                    inline: false\n                });\n            }\n            \n            // Add addresses count if any\n            if (profile.addresses.length > 0) {\n                profileEmbed.addFields({\n                    name: 'üìç Linked Addresses',\n                    value: `${profile.addresses.length} Litecoin address(es)`,\n                    inline: true\n                });\n            }\n            \n            await interaction.editReply({ embeds: [profileEmbed] });\n            \n        } catch (error) {\n            console.error('Profile command error:', error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Error')\n                .setDescription('Failed to load your profile. Please try again.')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};","size_bytes":4915},"attached_assets/casino/commands/recoverykey.js":{"content":"const { SlashCommandBuilder, EmbedBuilder } = require('discord.js');\nconst securityManager = require('../utils/securityManager.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('recoverykey')\n        .setDescription('View your recovery key (requires password)')\n        .addStringOption(option =>\n            option.setName('password')\n                .setDescription('Your account password')\n                .setRequired(true)\n        ),\n    \n    async execute(interaction) {\n        await interaction.deferReply({ ephemeral: true });\n        \n        try {\n            const password = interaction.options.getString('password');\n            \n            // Check if user has a password set\n            const userSec = securityManager.getUserSecurity(interaction.user.id);\n            if (!userSec.hasPassword) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå No Password Set')\n                    .setDescription('You need to set a password first using `/setpassword`.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Verify password\n            if (!securityManager.verifyUserPassword(interaction.user.id, password)) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Wrong Password')\n                    .setDescription('The password you entered is incorrect.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            const recoveryKeyEmbed = new EmbedBuilder()\n                .setColor('#f7931a')\n                .setTitle('üîë Your Recovery Key')\n                .setDescription('**Keep this key safe!** You need it to recover your account.')\n                .addFields(\n                    {\n                        name: 'üîê Recovery Key',\n                        value: `\\`${userSec.recoveryKey}\\``,\n                        inline: false\n                    },\n                    {\n                        name: '‚ö†Ô∏è Security Warning',\n                        value: 'Never share this key with anyone. Store it in a secure location offline.',\n                        inline: false\n                    },\n                    {\n                        name: 'üîÑ Reset Key',\n                        value: 'Use `/resetrecovery` if you want to generate a new recovery key.',\n                        inline: false\n                    }\n                )\n                .setFooter({ text: 'This message will delete automatically for security' })\n                .setTimestamp();\n            \n            const message = await interaction.editReply({ embeds: [recoveryKeyEmbed] });\n            \n            // Auto-delete the message after 30 seconds for security\n            setTimeout(async () => {\n                try {\n                    await message.delete();\n                } catch (error) {\n                    console.log('Could not delete recovery key message:', error.message);\n                }\n            }, 30000);\n            \n        } catch (error) {\n            console.error('Recovery key error:', error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Error')\n                .setDescription('Failed to retrieve recovery key. Please try again.')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};","size_bytes":3766},"attached_assets/casino/commands/resetpassworduser.js":{"content":"const { SlashCommandBuilder, EmbedBuilder } = require('discord.js');\nconst userProfiles = require('../utils/userProfiles.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('resetpassworduser')\n        .setDescription('Reset password for any user (Bot Owner only)')\n        .addUserOption(option =>\n            option.setName('user')\n                .setDescription('User whose password to reset')\n                .setRequired(true)\n        ),\n    \n    async execute(interaction) {\n        // Check if interaction is too old\n        const interactionAge = Date.now() - interaction.createdTimestamp;\n        if (interactionAge > 10 * 60 * 1000) {\n            console.log('Interaction trop ancienne, ignor√©e');\n            return;\n        }\n        \n        // Check if user is bot owner\n        const ownerId = process.env.OWNER_ID;\n        \n        if (!ownerId || interaction.user.id !== ownerId) {\n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Access Denied')\n                .setDescription('Only the bot owner can reset user passwords.')\n                .setTimestamp();\n            \n            await interaction.reply({ embeds: [errorEmbed], ephemeral: true });\n            return;\n        }\n        \n        await interaction.deferReply({ ephemeral: true });\n        \n        try {\n            const targetUser = interaction.options.getUser('user');\n            \n            // Check if user has a profile\n            const profile = userProfiles.getUserProfile(targetUser.id);\n            if (!profile) {\n                const noProfileEmbed = new EmbedBuilder()\n                    .setColor('#ffaa00')\n                    .setTitle('‚ö†Ô∏è User Not Found')\n                    .setDescription(`User ${targetUser.username} doesn't have a casino profile yet.`)\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [noProfileEmbed] });\n                return;\n            }\n            \n            // Reset password and recovery key\n            const resetResult = userProfiles.resetUserSecurity(targetUser.id);\n            \n            if (resetResult.success) {\n                const successEmbed = new EmbedBuilder()\n                    .setColor('#00ff00')\n                    .setTitle('‚úÖ Password Reset Complete')\n                    .setDescription(`Successfully reset security settings for ${targetUser.username}`)\n                    .addFields(\n                        {\n                            name: 'üë§ Target User',\n                            value: `${targetUser.username} (${targetUser.id})`,\n                            inline: false\n                        },\n                        {\n                            name: 'üîê Actions Taken',\n                            value: '‚Ä¢ Password cleared\\n‚Ä¢ Recovery key regenerated\\n‚Ä¢ User can now set new password with `/setpassword`',\n                            inline: false\n                        },\n                        {\n                            name: 'üîë New Recovery Key',\n                            value: `\\`${resetResult.newRecoveryKey}\\``,\n                            inline: false\n                        }\n                    )\n                    .setFooter({ text: 'Owner command executed' })\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [successEmbed] });\n                \n                console.log(`üîê Owner ${interaction.user.username} reset password for user ${targetUser.username} (${targetUser.id})`);\n                \n                // Try to notify the user via DM (optional)\n                try {\n                    const dmEmbed = new EmbedBuilder()\n                        .setColor('#0099ff')\n                        .setTitle('üîê Password Reset by Admin')\n                        .setDescription('Your casino password has been reset by an administrator.')\n                        .addFields(\n                            {\n                                name: 'üìù What to do next',\n                                value: '‚Ä¢ Use `/setpassword` to set a new password\\n‚Ä¢ Your balance and profile are safe',\n                                inline: false\n                            },\n                            {\n                                name: 'üîë Your New Recovery Key',\n                                value: `\\`${resetResult.newRecoveryKey}\\`\\n*Save this somewhere safe!*`,\n                                inline: false\n                            }\n                        )\n                        .setTimestamp();\n                    \n                    await targetUser.send({ embeds: [dmEmbed] });\n                    console.log(`üì© Notification DM envoy√©e √† ${targetUser.username}`);\n                } catch (dmError) {\n                    console.log(`‚ö†Ô∏è Impossible d'envoyer DM √† ${targetUser.username}: ${dmError.message}`);\n                }\n                \n            } else {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Reset Failed')\n                    .setDescription('Failed to reset user password. Please try again.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n            }\n            \n        } catch (error) {\n            console.error('Erreur resetpassworduser:', error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Error')\n                .setDescription('An error occurred while resetting the password.')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};","size_bytes":5893},"attached_assets/casino/commands/resetrecovery.js":{"content":"const { SlashCommandBuilder, EmbedBuilder } = require('discord.js');\nconst securityManager = require('../utils/securityManager.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('resetrecovery')\n        .setDescription('Reset your recovery key (requires old key + password)')\n        .addStringOption(option =>\n            option.setName('oldkey')\n                .setDescription('Your current recovery key')\n                .setRequired(true)\n        )\n        .addStringOption(option =>\n            option.setName('password')\n                .setDescription('Your account password')\n                .setRequired(true)\n        ),\n    \n    async execute(interaction) {\n        await interaction.deferReply({ ephemeral: true });\n        \n        try {\n            const oldKey = interaction.options.getString('oldkey');\n            const password = interaction.options.getString('password');\n            \n            // Check if user has a password set\n            const userSec = securityManager.getUserSecurity(interaction.user.id);\n            if (!userSec.hasPassword) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå No Password Set')\n                    .setDescription('You need to set a password first using `/setpassword`.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Try to reset recovery key\n            const newRecoveryKey = securityManager.resetRecoveryKey(interaction.user.id, oldKey, password);\n            \n            if (!newRecoveryKey) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Reset Failed')\n                    .setDescription('Invalid recovery key or password. Both must be correct to reset.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            const successEmbed = new EmbedBuilder()\n                .setColor('#00ff00')\n                .setTitle('üîÑ Recovery Key Reset')\n                .setDescription('Your recovery key has been successfully reset.')\n                .addFields(\n                    {\n                        name: 'üîë New Recovery Key',\n                        value: `\\`${newRecoveryKey}\\``,\n                        inline: false\n                    },\n                    {\n                        name: '‚ö†Ô∏è IMPORTANT',\n                        value: '**Save this new recovery key immediately!** Your old key is no longer valid.',\n                        inline: false\n                    },\n                    {\n                        name: 'üîí Security',\n                        value: 'Store your new recovery key in a safe place. You will need it to recover your account.',\n                        inline: false\n                    }\n                )\n                .setFooter({ text: 'This message will delete automatically for security' })\n                .setTimestamp();\n            \n            const message = await interaction.editReply({ embeds: [successEmbed] });\n            \n            // Auto-delete the message after 45 seconds for security\n            setTimeout(async () => {\n                try {\n                    await message.delete();\n                } catch (error) {\n                    console.log('Could not delete reset recovery message:', error.message);\n                }\n            }, 45000);\n            \n        } catch (error) {\n            console.error('Reset recovery error:', error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Error')\n                .setDescription('Failed to reset recovery key. Please try again.')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};","size_bytes":4126},"attached_assets/casino/commands/roulette.js":{"content":"const { SlashCommandBuilder, EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle, StringSelectMenuBuilder } = require('discord.js');\nconst userProfiles = require('../utils/userProfiles.js');\nconst securityManager = require('../utils/securityManager.js');\nconst logManager = require('../utils/logManager.js');\nconst { formatLTC } = require('../utils/formatters.js');\n\n// Roulette wheel numbers and colors\nconst wheel = {\n    0: 'green',\n    1: 'red', 2: 'black', 3: 'red', 4: 'black', 5: 'red', 6: 'black',\n    7: 'red', 8: 'black', 9: 'red', 10: 'black', 11: 'black', 12: 'red',\n    13: 'black', 14: 'red', 15: 'black', 16: 'red', 17: 'black', 18: 'red',\n    19: 'red', 20: 'black', 21: 'red', 22: 'black', 23: 'red', 24: 'black',\n    25: 'red', 26: 'black', 27: 'red', 28: 'black', 29: 'black', 30: 'red',\n    31: 'black', 32: 'red', 33: 'black', 34: 'red', 35: 'black', 36: 'red'\n};\n\n// Active spins storage\nconst activeSpins = new Map();\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('roulette')\n        .setDescription('Play Roulette - place your bets!')\n        .addNumberOption(option =>\n            option.setName('bet')\n                .setDescription('Amount to bet in LTC')\n                .setRequired(true)\n                .setMinValue(0.001)\n        ),\n    \n    async execute(interaction) {\n        // Check if interaction is too old\n        const interactionAge = Date.now() - interaction.createdTimestamp;\n        if (interactionAge > 10 * 60 * 1000) {\n            console.log('Interaction trop ancienne, ignor√©e');\n            return;\n        }\n        \n        await interaction.deferReply({ ephemeral: false });\n        \n        try {\n            const bet = interaction.options.getNumber('bet');\n            const userId = interaction.user.id;\n            \n            // Check if user has active spin\n            if (activeSpins.has(userId)) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Spin Already Active')\n                    .setDescription('You already have an active roulette spin. Wait for it to finish!')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Get user profile and verify balance\n            const profile = userProfiles.getUserProfile(userId);\n            \n            if (profile.balance < bet) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Insufficient Balance')\n                    .setDescription(`You need **${formatLTC(bet)} LTC** to play but only have **${formatLTC(profile.balance)} LTC**.`)\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Check password protection\n            const userSec = securityManager.getUserSecurity(userId);\n            if (!userSec.hasPassword) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ffaa00')\n                    .setTitle('üîí Password Required')\n                    .setDescription('You need to set a password before gambling. Use `/setpassword` first.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Create new spin\n            const spin = {\n                userId: userId,\n                bet: bet,\n                bets: new Map(),\n                status: 'betting',\n                result: null,\n                totalPayout: 0,\n                startTime: Date.now()\n            };\n            \n            activeSpins.set(userId, spin);\n            \n            // Show betting interface\n            const bettingEmbed = createBettingEmbed(spin, interaction.user);\n            const bettingComponents = createBettingComponents();\n            \n            await interaction.editReply({ \n                embeds: [bettingEmbed],\n                components: bettingComponents\n            });\n            \n            // Auto-timeout after 2 minutes\n            setTimeout(() => {\n                if (activeSpins.has(userId)) {\n                    const timeoutSpin = activeSpins.get(userId);\n                    if (timeoutSpin.status === 'betting') {\n                        timeoutSpin.status = 'timeout';\n                        activeSpins.delete(userId);\n                        console.log(`üïê Roulette spin timed out for ${interaction.user.username}`);\n                    }\n                }\n            }, 120000);\n            \n        } catch (error) {\n            console.error('Erreur roulette:', error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Error')\n                .setDescription('An error occurred while starting the roulette game.')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};\n\nfunction createBettingEmbed(spin, user) {\n    const embed = new EmbedBuilder()\n        .setColor('#9932cc')\n        .setTitle('üé∞ Roulette - Place Your Bets!')\n        .setDescription(`**Available to bet:** ${formatLTC(spin.bet)} LTC`)\n        .addFields(\n            {\n                name: 'üéØ How to Play',\n                value: '‚Ä¢ Choose your betting options below\\n‚Ä¢ Numbers pay 35:1\\n‚Ä¢ Colors (Red/Black) pay 1:1\\n‚Ä¢ Even/Odd pay 1:1\\n‚Ä¢ High/Low pay 1:1',\n                inline: false\n            },\n            {\n                name: 'üí∞ Current Bets',\n                value: spin.bets.size > 0 ? formatBets(spin.bets) : 'No bets placed yet',\n                inline: false\n            }\n        )\n        .setFooter({ text: 'Select your bets below, then click Spin!' })\n        .setTimestamp();\n    \n    return embed;\n}\n\nfunction createBettingComponents() {\n    const colorRow = new ActionRowBuilder()\n        .addComponents(\n            new ButtonBuilder()\n                .setCustomId('roulette_bet_red')\n                .setLabel('Red (1:1)')\n                .setStyle(ButtonStyle.Danger)\n                .setEmoji('üî¥'),\n            new ButtonBuilder()\n                .setCustomId('roulette_bet_black')\n                .setLabel('Black (1:1)')\n                .setStyle(ButtonStyle.Secondary)\n                .setEmoji('‚ö´'),\n            new ButtonBuilder()\n                .setCustomId('roulette_bet_green')\n                .setLabel('Green (35:1)')\n                .setStyle(ButtonStyle.Success)\n                .setEmoji('üü¢')\n        );\n    \n    const oddEvenRow = new ActionRowBuilder()\n        .addComponents(\n            new ButtonBuilder()\n                .setCustomId('roulette_bet_even')\n                .setLabel('Even (1:1)')\n                .setStyle(ButtonStyle.Primary)\n                .setEmoji('2Ô∏è‚É£'),\n            new ButtonBuilder()\n                .setCustomId('roulette_bet_odd')\n                .setLabel('Odd (1:1)')\n                .setStyle(ButtonStyle.Primary)\n                .setEmoji('1Ô∏è‚É£'),\n            new ButtonBuilder()\n                .setCustomId('roulette_bet_low')\n                .setLabel('Low 1-18 (1:1)')\n                .setStyle(ButtonStyle.Primary)\n                .setEmoji('üîΩ'),\n            new ButtonBuilder()\n                .setCustomId('roulette_bet_high')\n                .setLabel('High 19-36 (1:1)')\n                .setStyle(ButtonStyle.Primary)\n                .setEmoji('üîº')\n        );\n    \n    const numberSelect = new ActionRowBuilder()\n        .addComponents(\n            new StringSelectMenuBuilder()\n                .setCustomId('roulette_bet_number')\n                .setPlaceholder('Choose a number (0-36) for 35:1 payout')\n                .addOptions(\n                    Array.from({ length: 37 }, (_, i) => ({\n                        label: `Number ${i}`,\n                        value: `number_${i}`,\n                        description: `Bet on ${i} (35:1 payout)`,\n                        emoji: i === 0 ? 'üü¢' : (wheel[i] === 'red' ? 'üî¥' : '‚ö´')\n                    }))\n                )\n        );\n    \n    const actionRow = new ActionRowBuilder()\n        .addComponents(\n            new ButtonBuilder()\n                .setCustomId('roulette_spin')\n                .setLabel('üé∞ SPIN!')\n                .setStyle(ButtonStyle.Success)\n                .setEmoji('üé∞'),\n            new ButtonBuilder()\n                .setCustomId('roulette_clear')\n                .setLabel('Clear Bets')\n                .setStyle(ButtonStyle.Secondary)\n                .setEmoji('üóëÔ∏è'),\n            new ButtonBuilder()\n                .setCustomId('roulette_cancel')\n                .setLabel('Cancel')\n                .setStyle(ButtonStyle.Danger)\n                .setEmoji('‚ùå')\n        );\n    \n    return [colorRow, oddEvenRow, numberSelect, actionRow];\n}\n\nfunction formatBets(bets) {\n    let betString = '';\n    let totalBet = 0;\n    \n    for (const [betType, amount] of bets) {\n        betString += `‚Ä¢ **${betType}**: ${formatLTC(amount)} LTC\\n`;\n        totalBet += amount;\n    }\n    \n    betString += `\\n**Total Bet**: ${formatLTC(totalBet)} LTC`;\n    return betString;\n}\n\nfunction spinWheel() {\n    return Math.floor(Math.random() * 37);\n}\n\nfunction calculatePayout(bets, result) {\n    let totalPayout = 0;\n    const winningBets = [];\n    \n    for (const [betType, amount] of bets) {\n        let won = false;\n        let multiplier = 0;\n        \n        if (betType.startsWith('number_')) {\n            const number = parseInt(betType.split('_')[1]);\n            if (number === result) {\n                won = true;\n                multiplier = 35;\n            }\n        } else if (betType === 'red' && wheel[result] === 'red') {\n            won = true;\n            multiplier = 1;\n        } else if (betType === 'black' && wheel[result] === 'black') {\n            won = true;\n            multiplier = 1;\n        } else if (betType === 'green' && wheel[result] === 'green') {\n            won = true;\n            multiplier = 35;\n        } else if (betType === 'even' && result !== 0 && result % 2 === 0) {\n            won = true;\n            multiplier = 1;\n        } else if (betType === 'odd' && result % 2 === 1) {\n            won = true;\n            multiplier = 1;\n        } else if (betType === 'low' && result >= 1 && result <= 18) {\n            won = true;\n            multiplier = 1;\n        } else if (betType === 'high' && result >= 19 && result <= 36) {\n            won = true;\n            multiplier = 1;\n        }\n        \n        if (won) {\n            const payout = amount * (multiplier + 1);\n            totalPayout += payout;\n            winningBets.push({ betType, amount, payout, multiplier });\n        }\n    }\n    \n    return { totalPayout, winningBets };\n}\n\nfunction createResultEmbed(spin, result, payout, winningBets, user) {\n    const resultColor = wheel[result];\n    const colorEmoji = resultColor === 'red' ? 'üî¥' : resultColor === 'black' ? '‚ö´' : 'üü¢';\n    \n    let title = 'üé∞ Roulette Result';\n    let color = '#9932cc';\n    let description = `The ball landed on **${result}** ${colorEmoji}`;\n    \n    if (payout > 0) {\n        title = 'üéâ You Win!';\n        color = '#00ff00';\n        description += `\\n\\nYou won **${formatLTC(payout)} LTC**!`;\n    } else {\n        title = 'üí∏ House Wins';\n        color = '#ff0000';\n        description += `\\n\\nBetter luck next time!`;\n    }\n    \n    const embed = new EmbedBuilder()\n        .setColor(color)\n        .setTitle(title)\n        .setDescription(description)\n        .addFields(\n            {\n                name: 'üéØ Winning Number',\n                value: `**${result}** ${colorEmoji} (${resultColor})`,\n                inline: true\n            }\n        );\n    \n    if (winningBets.length > 0) {\n        const winningBetsStr = winningBets.map(bet => \n            `‚Ä¢ **${bet.betType}**: ${formatLTC(bet.amount)} LTC ‚Üí ${formatLTC(bet.payout)} LTC (${bet.multiplier + 1}x)`\n        ).join('\\n');\n        \n        embed.addFields({\n            name: 'üèÜ Winning Bets',\n            value: winningBetsStr,\n            inline: false\n        });\n    }\n    \n    const profile = userProfiles.getUserProfile(spin.userId);\n    embed.addFields({\n        name: 'üí∞ New Balance',\n        value: `${formatLTC(profile.balance)} LTC`,\n        inline: true\n    });\n    \n    return embed;\n}\n\nmodule.exports.activeSpins = activeSpins;\nmodule.exports.spinWheel = spinWheel;\nmodule.exports.calculatePayout = calculatePayout;\nmodule.exports.createResultEmbed = createResultEmbed;\nmodule.exports.createBettingEmbed = createBettingEmbed;\nmodule.exports.createBettingComponents = createBettingComponents;\nmodule.exports.wheel = wheel;","size_bytes":12983},"attached_assets/casino/commands/setlogbal.js":{"content":"const { SlashCommandBuilder, EmbedBuilder, PermissionFlagsBits, ChannelType } = require('discord.js');\nconst fs = require('fs');\nconst path = require('path');\n\nconst CONFIG_FILE = path.join(__dirname, '../data/log_config.json');\n\n// Ensure data directory exists\nconst dataDir = path.join(__dirname, '../data');\nif (!fs.existsSync(dataDir)) {\n    fs.mkdirSync(dataDir, { recursive: true });\n}\n\nfunction loadLogConfig() {\n    try {\n        if (fs.existsSync(CONFIG_FILE)) {\n            const data = fs.readFileSync(CONFIG_FILE, 'utf8');\n            return JSON.parse(data);\n        }\n    } catch (error) {\n        console.error('Error loading log config:', error.message);\n    }\n    return {};\n}\n\nfunction saveLogConfig(config) {\n    try {\n        fs.writeFileSync(CONFIG_FILE, JSON.stringify(config, null, 2));\n        console.log('‚úÖ Log config saved');\n    } catch (error) {\n        console.error('Error saving log config:', error.message);\n    }\n}\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('setlogbal')\n        .setDescription('Configure balance log channel (Admin only)')\n        .addChannelOption(option =>\n            option.setName('channel')\n                .setDescription('Channel to send balance logs to')\n                .setRequired(true)\n                .addChannelTypes(ChannelType.GuildText)\n        )\n        .setDefaultMemberPermissions(PermissionFlagsBits.Administrator),\n    \n    async execute(interaction) {\n        // Check if interaction is too old\n        const interactionAge = Date.now() - interaction.createdTimestamp;\n        if (interactionAge > 10 * 60 * 1000) {\n            console.log('Interaction trop ancienne, ignor√©e');\n            return;\n        }\n        \n        await interaction.deferReply({ ephemeral: true });\n        \n        try {\n            const channel = interaction.options.getChannel('channel');\n            const serverId = interaction.guild.id;\n            \n            // Load config\n            const config = loadLogConfig();\n            \n            if (!config[serverId]) {\n                config[serverId] = {};\n            }\n            \n            config[serverId].balanceLogChannel = channel.id;\n            \n            // Save config\n            saveLogConfig(config);\n            \n            const successEmbed = new EmbedBuilder()\n                .setColor('#00ff00')\n                .setTitle('‚úÖ Balance Log Channel Set')\n                .setDescription(`Balance logs will now be sent to ${channel}`)\n                .addFields(\n                    {\n                        name: 'üìã Configuration Details',\n                        value: `**Channel:** ${channel}\\n**Channel ID:** \\`${channel.id}\\`\\n**Server:** ${interaction.guild.name}`,\n                        inline: false\n                    },\n                    {\n                        name: 'üìù What gets logged',\n                        value: '‚Ä¢ Deposit confirmations\\n‚Ä¢ Balance additions\\n‚Ä¢ Deposit channel closures\\n‚Ä¢ Address generations',\n                        inline: false\n                    }\n                )\n                .setFooter({ text: `Configured by ${interaction.user.username}` })\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [successEmbed] });\n            \n            // Send test message to the log channel\n            try {\n                const testEmbed = new EmbedBuilder()\n                    .setColor('#0099ff')\n                    .setTitle('üîß Balance Log Channel Configured')\n                    .setDescription('This channel has been set up to receive balance logs from the casino bot.')\n                    .addFields(\n                        {\n                            name: '‚öôÔ∏è Configured by',\n                            value: `${interaction.user} (${interaction.user.username})`,\n                            inline: false\n                        }\n                    )\n                    .setTimestamp();\n                \n                await channel.send({ embeds: [testEmbed] });\n            } catch (channelError) {\n                console.log('Could not send test message to log channel:', channelError.message);\n            }\n            \n            console.log(`üìù Balance log channel set to ${channel.name} for server ${interaction.guild.name}`);\n            \n        } catch (error) {\n            console.error('Erreur setlogbal:', error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Error')\n                .setDescription('An error occurred while setting the log channel.')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};","size_bytes":4791},"attached_assets/casino/commands/setloggamble.js":{"content":"const { SlashCommandBuilder, EmbedBuilder, PermissionFlagsBits, ChannelType } = require('discord.js');\nconst fs = require('fs');\nconst path = require('path');\n\nconst CONFIG_FILE = path.join(__dirname, '../data/log_config.json');\n\n// Ensure data directory exists\nconst dataDir = path.join(__dirname, '../data');\nif (!fs.existsSync(dataDir)) {\n    fs.mkdirSync(dataDir, { recursive: true });\n}\n\nfunction loadLogConfig() {\n    try {\n        if (fs.existsSync(CONFIG_FILE)) {\n            const data = fs.readFileSync(CONFIG_FILE, 'utf8');\n            return JSON.parse(data);\n        }\n    } catch (error) {\n        console.error('Error loading log config:', error.message);\n    }\n    return {};\n}\n\nfunction saveLogConfig(config) {\n    try {\n        fs.writeFileSync(CONFIG_FILE, JSON.stringify(config, null, 2));\n        console.log('‚úÖ Log config saved');\n    } catch (error) {\n        console.error('Error saving log config:', error.message);\n    }\n}\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('setloggamble')\n        .setDescription('Configure gambling log channel (Admin only)')\n        .addChannelOption(option =>\n            option.setName('channel')\n                .setDescription('Channel to send gambling logs to')\n                .setRequired(true)\n                .addChannelTypes(ChannelType.GuildText)\n        )\n        .setDefaultMemberPermissions(PermissionFlagsBits.Administrator),\n    \n    async execute(interaction) {\n        // Check if interaction is too old\n        const interactionAge = Date.now() - interaction.createdTimestamp;\n        if (interactionAge > 10 * 60 * 1000) {\n            console.log('Interaction trop ancienne, ignor√©e');\n            return;\n        }\n        \n        await interaction.deferReply({ ephemeral: true });\n        \n        try {\n            const channel = interaction.options.getChannel('channel');\n            const serverId = interaction.guild.id;\n            \n            // Load config\n            const config = loadLogConfig();\n            \n            if (!config[serverId]) {\n                config[serverId] = {};\n            }\n            \n            config[serverId].gamblingLogChannel = channel.id;\n            \n            // Save config\n            saveLogConfig(config);\n            \n            const successEmbed = new EmbedBuilder()\n                .setColor('#00ff00')\n                .setTitle('‚úÖ Gambling Log Channel Set')\n                .setDescription(`Gambling logs will now be sent to ${channel}`)\n                .addFields(\n                    {\n                        name: 'üìã Configuration Details',\n                        value: `**Channel:** ${channel}\\n**Channel ID:** \\`${channel.id}\\`\\n**Server:** ${interaction.guild.name}`,\n                        inline: false\n                    },\n                    {\n                        name: 'üé∞ What gets logged',\n                        value: '‚Ä¢ Blackjack games and results\\n‚Ä¢ Roulette spins and payouts\\n‚Ä¢ Big wins and losses\\n‚Ä¢ Suspicious gambling patterns',\n                        inline: false\n                    }\n                )\n                .setFooter({ text: `Configured by ${interaction.user.username}` })\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [successEmbed] });\n            \n            // Send test message to the log channel\n            try {\n                const testEmbed = new EmbedBuilder()\n                    .setColor('#9932cc')\n                    .setTitle('üé∞ Gambling Log Channel Configured')\n                    .setDescription('This channel has been set up to receive gambling logs from the casino bot.')\n                    .addFields(\n                        {\n                            name: '‚öôÔ∏è Configured by',\n                            value: `${interaction.user} (${interaction.user.username})`,\n                            inline: false\n                        }\n                    )\n                    .setTimestamp();\n                \n                await channel.send({ embeds: [testEmbed] });\n            } catch (channelError) {\n                console.log('Could not send test message to gambling log channel:', channelError.message);\n            }\n            \n            console.log(`üé∞ Gambling log channel set to ${channel.name} for server ${interaction.guild.name}`);\n            \n        } catch (error) {\n            console.error('Erreur setloggamble:', error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Error')\n                .setDescription('An error occurred while setting the gambling log channel.')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};","size_bytes":4842},"attached_assets/casino/commands/setpanel.js":{"content":"const { SlashCommandBuilder, EmbedBuilder, PermissionFlagsBits } = require('discord.js');\nconst panelManager = require('../utils/panelManager.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('setpanel')\n        .setDescription('Configure a casino panel in a channel')\n        .addStringOption(option =>\n            option.setName('type')\n                .setDescription('Type of panel to create')\n                .setRequired(true)\n                .addChoices(\n                    { name: 'üé∞ Casino Main Panel', value: 'casinoPanel' },\n                    { name: 'üí∞ Add Balance Panel', value: 'addBalancePanel' }\n                )\n        )\n        .addChannelOption(option =>\n            option.setName('channel')\n                .setDescription('Channel to send the panel to')\n                .setRequired(true)\n        )\n        .addChannelOption(option =>\n            option.setName('ticket_category')\n                .setDescription('Category for creating ticket channels')\n                .setRequired(false)\n        )\n        .addRoleOption(option =>\n            option.setName('staff_role')\n                .setDescription('Staff role that can see tickets')\n                .setRequired(false)\n        )\n        .setDefaultMemberPermissions(PermissionFlagsBits.Administrator),\n    \n    async execute(interaction) {\n        // Check if interaction is too old\n        const interactionAge = Date.now() - interaction.createdTimestamp;\n        if (interactionAge > 10 * 60 * 1000) {\n            console.log('Interaction trop ancienne, ignor√©e');\n            return;\n        }\n        \n        await interaction.deferReply({ ephemeral: true });\n        \n        try {\n            const panelType = interaction.options.getString('type');\n            const channel = interaction.options.getChannel('channel');\n            const ticketCategory = interaction.options.getChannel('ticket_category');\n            const staffRole = interaction.options.getRole('staff_role');\n            \n            // Validate channel type\n            if (channel.type !== 0) { // Not a text channel\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Invalid Channel')\n                    .setDescription('Please select a text channel for the panel.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Validate category if provided\n            if (ticketCategory && ticketCategory.type !== 4) { // Not a category\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Invalid Category')\n                    .setDescription('Please select a channel category for tickets.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Save configuration\n            const success = panelManager.setPanelChannel(\n                panelType,\n                channel.id,\n                ticketCategory?.id,\n                staffRole?.id\n            );\n            \n            if (!success) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Configuration Failed')\n                    .setDescription('Failed to save panel configuration.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Create and send the panel\n            const panelEmbed = await createPanelEmbed(panelType, interaction.guild);\n            const components = await createPanelComponents(panelType);\n            \n            try {\n                const message = await channel.send({ \n                    embeds: [panelEmbed], \n                    components: components \n                });\n                \n                // Save message ID\n                panelManager.setPanelMessageId(panelType, message.id);\n                \n                const successEmbed = new EmbedBuilder()\n                    .setColor('#00ff00')\n                    .setTitle('‚úÖ Panel Created')\n                    .setDescription(`${getPanelName(panelType)} has been sent to ${channel}`)\n                    .addFields(\n                        {\n                            name: 'üìã Configuration',\n                            value: `**Channel:** ${channel}\\n**Ticket Category:** ${ticketCategory || 'Not set'}\\n**Staff Role:** ${staffRole || 'Not set'}`,\n                            inline: false\n                        }\n                    )\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [successEmbed] });\n                \n            } catch (sendError) {\n                console.error('Erreur envoi panel:', sendError);\n                \n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Send Failed')\n                    .setDescription('Failed to send panel to channel. Check bot permissions.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n            }\n            \n        } catch (error) {\n            console.error('Erreur setpanel:', error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Error')\n                .setDescription('Failed to configure panel.')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};\n\n/**\n * Create panel embed based on type\n */\nasync function createPanelEmbed(panelType, guild) {\n    const { EmbedBuilder } = require('discord.js');\n    \n    if (panelType === 'casinoPanel') {\n        return new EmbedBuilder()\n            .setColor('#f7931a')\n            .setTitle('üé∞ Welcome to the Casino!')\n            .setDescription('Click the buttons below to start your casino experience.')\n            .addFields(\n                {\n                    name: 'üí∞ Add Balance',\n                    value: 'Generate a unique Litecoin address for deposits',\n                    inline: true\n                },\n                {\n                    name: 'üë§ View Profile',\n                    value: 'Check your balance and casino statistics',\n                    inline: true\n                },\n                {\n                    name: 'üèÜ Leaderboard',\n                    value: 'See the top players and rankings',\n                    inline: true\n                },\n                {\n                    name: 'üéÆ Games Available Soon',\n                    value: '‚Ä¢ üÉè Blackjack\\n‚Ä¢ üé≤ Roulette\\n‚Ä¢ üé∞ Slots',\n                    inline: false\n                }\n            )\n            .setThumbnail('https://cryptologos.cc/logos/litecoin-ltc-logo.png')\n            .setFooter({ \n                text: `${guild.name} Casino ‚Ä¢ Powered by Litecoin`,\n                iconURL: guild.iconURL() \n            })\n            .setTimestamp();\n    }\n    \n    if (panelType === 'addBalancePanel') {\n        return new EmbedBuilder()\n            .setColor('#00ff00')\n            .setTitle('üí∞ Add Balance to Your Casino Account')\n            .setDescription('Click the button below to get a unique deposit address and start playing!')\n            .addFields(\n                {\n                    name: '‚ö° Instant Detection',\n                    value: 'Deposits are detected within 30 seconds',\n                    inline: true\n                },\n                {\n                    name: 'üîí Secure',\n                    value: 'Each deposit gets a unique address',\n                    inline: true\n                },\n                {\n                    name: 'üìà Minimum Deposit',\n                    value: '0.001 LTC',\n                    inline: true\n                }\n            )\n            .setThumbnail('https://cryptologos.cc/logos/litecoin-ltc-logo.png')\n            .setFooter({ \n                text: `${guild.name} Casino ‚Ä¢ Safe & Secure`,\n                iconURL: guild.iconURL() \n            })\n            .setTimestamp();\n    }\n}\n\n/**\n * Create panel components based on type\n */\nasync function createPanelComponents(panelType) {\n    const { ActionRowBuilder, ButtonBuilder, ButtonStyle } = require('discord.js');\n    \n    if (panelType === 'casinoPanel') {\n        return [\n            new ActionRowBuilder()\n                .addComponents(\n                    new ButtonBuilder()\n                        .setCustomId('panel_add_balance')\n                        .setLabel('üí∞ Add Balance')\n                        .setStyle(ButtonStyle.Success)\n                        .setEmoji('üí∞'),\n                    new ButtonBuilder()\n                        .setCustomId('panel_view_profile')\n                        .setLabel('üë§ View Profile')\n                        .setStyle(ButtonStyle.Primary)\n                        .setEmoji('üë§'),\n                    new ButtonBuilder()\n                        .setCustomId('panel_leaderboard')\n                        .setLabel('üèÜ Leaderboard')\n                        .setStyle(ButtonStyle.Secondary)\n                        .setEmoji('üèÜ')\n                ),\n            new ActionRowBuilder()\n                .addComponents(\n                    new ButtonBuilder()\n                        .setCustomId('panel_games_blackjack')\n                        .setLabel('üÉè Blackjack')\n                        .setStyle(ButtonStyle.Secondary)\n                        .setEmoji('üÉè')\n                        .setDisabled(true),\n                    new ButtonBuilder()\n                        .setCustomId('panel_games_roulette')\n                        .setLabel('üé≤ Roulette')\n                        .setStyle(ButtonStyle.Secondary)\n                        .setEmoji('üé≤')\n                        .setDisabled(true),\n                    new ButtonBuilder()\n                        .setCustomId('panel_games_slots')\n                        .setLabel('üé∞ Slots')\n                        .setStyle(ButtonStyle.Secondary)\n                        .setEmoji('üé∞')\n                        .setDisabled(true)\n                )\n        ];\n    }\n    \n    if (panelType === 'addBalancePanel') {\n        return [\n            new ActionRowBuilder()\n                .addComponents(\n                    new ButtonBuilder()\n                        .setCustomId('panel_add_balance')\n                        .setLabel('üí∞ Get Deposit Address')\n                        .setStyle(ButtonStyle.Success)\n                        .setEmoji('üí∞')\n                )\n        ];\n    }\n    \n    return [];\n}\n\n/**\n * Get friendly panel name\n */\nfunction getPanelName(panelType) {\n    const names = {\n        'casinoPanel': 'üé∞ Casino Main Panel',\n        'addBalancePanel': 'üí∞ Add Balance Panel'\n    };\n    return names[panelType] || panelType;\n}","size_bytes":11275},"attached_assets/casino/commands/setpassword.js":{"content":"const { SlashCommandBuilder, EmbedBuilder } = require('discord.js');\nconst securityManager = require('../utils/securityManager.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('setpassword')\n        .setDescription('Set your account password (required for security features)')\n        .addStringOption(option =>\n            option.setName('password')\n                .setDescription('Your new password (minimum 6 characters)')\n                .setRequired(true)\n        ),\n    \n    async execute(interaction) {\n        await interaction.deferReply({ ephemeral: true });\n        \n        try {\n            const password = interaction.options.getString('password');\n            \n            // Validate password\n            if (password.length < 6) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Invalid Password')\n                    .setDescription('Password must be at least 6 characters long.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Check if user already has a password\n            const userSec = securityManager.getUserSecurity(interaction.user.id);\n            if (userSec.hasPassword) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Password Already Set')\n                    .setDescription('You already have a password set. Use `/changepassword` to change it.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Set password and generate recovery key\n            const recoveryKey = securityManager.setUserPassword(interaction.user.id, password);\n            \n            const successEmbed = new EmbedBuilder()\n                .setColor('#00ff00')\n                .setTitle('üîí Password Set Successfully')\n                .setDescription('Your password has been set and your recovery key has been generated.')\n                .addFields(\n                    {\n                        name: 'üîë Recovery Key',\n                        value: `\\`${recoveryKey}\\``,\n                        inline: false\n                    },\n                    {\n                        name: '‚ö†Ô∏è IMPORTANT',\n                        value: '**Save this recovery key immediately!** You need it to recover your account if you lose access. Store it in a safe place.',\n                        inline: false\n                    },\n                    {\n                        name: 'üõ°Ô∏è Security Features Unlocked',\n                        value: '‚Ä¢ View recovery key with password\\n‚Ä¢ Enable gambling sessions\\n‚Ä¢ Secure cashout protection\\n‚Ä¢ Account recovery',\n                        inline: false\n                    }\n                )\n                .setThumbnail('https://em-content.zobj.net/thumbs/120/twitter/351/locked_1f512.png')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [successEmbed] });\n            \n        } catch (error) {\n            console.error('Set password error:', error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Error')\n                .setDescription('Failed to set password. Please try again.')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};","size_bytes":3699},"attached_assets/casino/commands/stopallactives.js":{"content":"const { SlashCommandBuilder, EmbedBuilder, PermissionFlagsBits } = require('discord.js');\nconst securityManager = require('../utils/securityManager.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('stopallactives')\n        .setDescription('Stop all active deposits monitoring (Admin only)')\n        .setDefaultMemberPermissions(PermissionFlagsBits.Administrator),\n    \n    async execute(interaction) {\n        // Check if interaction is too old\n        const interactionAge = Date.now() - interaction.createdTimestamp;\n        if (interactionAge > 10 * 60 * 1000) {\n            console.log('Interaction trop ancienne, ignor√©e');\n            return;\n        }\n        \n        await interaction.deferReply({ ephemeral: true });\n        \n        try {\n            // Get all active deposits before clearing\n            const activeDeposits = securityManager.getAllActiveDeposits();\n            const activeCount = activeDeposits.length;\n            \n            if (activeCount === 0) {\n                const noActiveEmbed = new EmbedBuilder()\n                    .setColor('#ffaa00')\n                    .setTitle('‚ÑπÔ∏è No Active Deposits')\n                    .setDescription('There are no active deposits to stop.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [noActiveEmbed] });\n                return;\n            }\n            \n            // Clear all active deposits\n            const success = securityManager.clearAllActiveDeposits();\n            \n            if (success) {\n                // Stop monitoring\n                const { stopSmartMonitoring } = require('../discord-bot.js');\n                stopSmartMonitoring();\n                \n                const successEmbed = new EmbedBuilder()\n                    .setColor('#00ff00')\n                    .setTitle('‚úÖ All Active Deposits Stopped')\n                    .setDescription(`Successfully stopped monitoring for **${activeCount}** active deposit(s).`)\n                    .addFields(\n                        {\n                            name: 'üõë Actions Taken',\n                            value: '‚Ä¢ All active deposits cleared\\n‚Ä¢ Smart monitoring stopped\\n‚Ä¢ Users will need to generate new addresses',\n                            inline: false\n                        },\n                        {\n                            name: '‚ö†Ô∏è Note',\n                            value: 'Users with pending deposits will need to use `/casino` again to generate new addresses.',\n                            inline: false\n                        }\n                    )\n                    .setFooter({ text: `Executed by ${interaction.user.username}` })\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [successEmbed] });\n                \n                console.log(`üõë Admin ${interaction.user.username} stopped ${activeCount} active deposits`);\n                \n            } else {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Failed to Stop')\n                    .setDescription('Failed to clear active deposits. Please try again.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n            }\n            \n        } catch (error) {\n            console.error('Erreur stopallactives:', error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Error')\n                .setDescription('An error occurred while stopping active deposits.')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};","size_bytes":3853},"attached_assets/casino/commands/testgamble.js":{"content":"const { SlashCommandBuilder, EmbedBuilder } = require('discord.js');\nconst securityManager = require('../utils/securityManager.js');\nconst userProfiles = require('../utils/userProfiles.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('testgamble')\n        .setDescription('Test gambling command to simulate wagering (requires active session)')\n        .addNumberOption(option =>\n            option.setName('amount')\n                .setDescription('Amount to wager in LTC')\n                .setRequired(true)\n                .setMinValue(0.001)\n        ),\n    \n    async execute(interaction) {\n        await interaction.deferReply({ ephemeral: true });\n        \n        try {\n            const amount = interaction.options.getNumber('amount');\n            const userId = interaction.user.id;\n            \n            // Check if user has active gambling session\n            if (!securityManager.hasActiveGamblingSession(userId)) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå No Active Session')\n                    .setDescription('You need to enable a gambling session first using `/enable`.')\n                    .addFields({\n                        name: 'üîí How to Start',\n                        value: 'Use `/enable [minutes] [password]` to start a gambling session.',\n                        inline: false\n                    })\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Check user balance\n            const profile = userProfiles.getUserProfile(userId);\n            \n            if (profile.balance < amount) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Insufficient Balance')\n                    .setDescription('You don\\'t have enough balance to wager this amount.')\n                    .addFields({\n                        name: 'üí∞ Available Balance',\n                        value: `${profile.balance.toFixed(8)} LTC`,\n                        inline: true\n                    })\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Simulate gambling result (50/50 chance for testing)\n            const won = Math.random() > 0.5;\n            const resultAmount = won ? amount * 1.8 : 0; // 1.8x payout if win\n            \n            // Update balance\n            const newBalance = profile.balance - amount + resultAmount;\n            userProfiles.updateUserProfile(userId, { balance: newBalance });\n            \n            // Add wagered amount (for cashout protection)\n            securityManager.addWageredAmount(userId, amount);\n            \n            // Check new cashout status\n            const cashoutStatus = securityManager.canUserCashout(userId);\n            \n            const resultEmbed = new EmbedBuilder()\n                .setColor(won ? '#00ff00' : '#ff0000')\n                .setTitle(won ? 'üéâ You Won!' : 'üíî You Lost!')\n                .setDescription(`Test gambling result: ${won ? 'WIN' : 'LOSS'}`)\n                .addFields(\n                    {\n                        name: 'üé≤ Game Result',\n                        value: `**Wagered:** ${amount.toFixed(8)} LTC\\n**${won ? 'Won' : 'Lost'}:** ${resultAmount.toFixed(8)} LTC\\n**Net:** ${(resultAmount - amount).toFixed(8)} LTC`,\n                        inline: true\n                    },\n                    {\n                        name: 'üí∞ Balance Update',\n                        value: `**Previous:** ${profile.balance.toFixed(8)} LTC\\n**Current:** ${newBalance.toFixed(8)} LTC`,\n                        inline: true\n                    },\n                    {\n                        name: 'üìä Cashout Status',\n                        value: `**Progress:** ${cashoutStatus.wageredPercent.toFixed(1)}%\\n**Can Cashout:** ${cashoutStatus.canCashout ? '‚úÖ Yes' : '‚ùå No'}\\n**Remaining:** ${cashoutStatus.remainingToWager.toFixed(8)} LTC`,\n                        inline: false\n                    }\n                )\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [resultEmbed] });\n            \n            console.log(`üé≤ ${interaction.user.username} ${won ? 'won' : 'lost'} ${amount} LTC - Balance: ${newBalance.toFixed(8)} LTC`);\n            \n        } catch (error) {\n            console.error('Test gamble error:', error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Game Error')\n                .setDescription('An error occurred during the game. Please try again.')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};","size_bytes":5045},"attached_assets/casino/deploy-commands.js":{"content":"const { REST, Routes } = require('discord.js');\nconst fs = require('fs');\nconst path = require('path');\n\n// Load environment variables\nrequire('dotenv').config();\n\nconst commands = [];\n\n// Load all command files\nconst commandsPath = path.join(__dirname, 'commands');\nconst commandFiles = fs.readdirSync(commandsPath).filter(file => file.endsWith('.js'));\n\nfor (const file of commandFiles) {\n    const filePath = path.join(commandsPath, file);\n    const command = require(filePath);\n    \n    if ('data' in command && 'execute' in command) {\n        commands.push(command.data.toJSON());\n        console.log(`‚úÖ Loaded command: ${command.data.name}`);\n    } else {\n        console.log(`‚ö†Ô∏è  Command ${file} is missing required properties`);\n    }\n}\n\n// Deploy commands\nasync function deployCommands() {\n    const token = process.env.DISCORD_TOKEN;\n    const clientId = process.env.DISCORD_CLIENT_ID;\n    const guildId = process.env.DISCORD_GUILD_ID; // Optional: for guild-specific commands\n    \n    if (!token) {\n        console.error('‚ùå DISCORD_TOKEN is required!');\n        process.exit(1);\n    }\n    \n    if (!clientId) {\n        console.error('‚ùå DISCORD_CLIENT_ID is required!');\n        process.exit(1);\n    }\n    \n    const rest = new REST().setToken(token);\n    \n    try {\n        console.log(`üîÑ Started refreshing ${commands.length} application (/) commands.`);\n        \n        let data;\n        \n        if (guildId) {\n            // Deploy to specific guild (faster for development)\n            data = await rest.put(\n                Routes.applicationGuildCommands(clientId, guildId),\n                { body: commands },\n            );\n            console.log(`‚úÖ Successfully reloaded ${data.length} guild commands for guild ${guildId}.`);\n        } else {\n            // Deploy globally (takes up to 1 hour to propagate)\n            data = await rest.put(\n                Routes.applicationCommands(clientId),\n                { body: commands },\n            );\n            console.log(`‚úÖ Successfully reloaded ${data.length} global application commands.`);\n        }\n        \n    } catch (error) {\n        console.error('‚ùå Error deploying commands:', error);\n    }\n}\n\n// Run deployment if this file is executed directly\nif (require.main === module) {\n    deployCommands();\n}\n\nmodule.exports = { deployCommands };","size_bytes":2341},"attached_assets/casino/discord-bot.js":{"content":"const { Client, GatewayIntentBits, Collection, EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle, Events } = require('discord.js');\nconst fs = require('fs');\nconst path = require('path');\n\n// Import Litecoin wallet system\nconst ltcWallet = require('./litecoin-casino-bot.js');\n\n// Create Discord client\nconst client = new Client({\n    intents: [\n        GatewayIntentBits.Guilds,\n        GatewayIntentBits.GuildMessages,\n        GatewayIntentBits.MessageContent,\n        GatewayIntentBits.GuildMembers\n    ]\n});\n\n// Commands collection\nclient.commands = new Collection();\n\n// Load commands\nconst commandsPath = path.join(__dirname, 'commands');\nif (fs.existsSync(commandsPath)) {\n    const commandFiles = fs.readdirSync(commandsPath).filter(file => file.endsWith('.js'));\n    \n    for (const file of commandFiles) {\n        const filePath = path.join(commandsPath, file);\n        const command = require(filePath);\n        \n        if ('data' in command && 'execute' in command) {\n            client.commands.set(command.data.name, command);\n            console.log(`‚úÖ Commande charg√©e: ${command.data.name}`);\n        } else {\n            console.log(`‚ö†Ô∏è  Commande ${file} manque des propri√©t√©s requises`);\n        }\n    }\n}\n\n// Load events\nconst eventsPath = path.join(__dirname, 'events');\nif (fs.existsSync(eventsPath)) {\n    const eventFiles = fs.readdirSync(eventsPath).filter(file => file.endsWith('.js'));\n    \n    for (const file of eventFiles) {\n        const filePath = path.join(eventsPath, file);\n        const event = require(filePath);\n        \n        if (event.once) {\n            client.once(event.name, (...args) => event.execute(...args));\n        } else {\n            client.on(event.name, (...args) => event.execute(...args));\n        }\n        console.log(`‚úÖ √âv√©nement charg√©: ${event.name}`);\n    }\n}\n\n\n// Interaction handling\nclient.on(Events.InteractionCreate, async interaction => {\n    // Handle slash commands\n    if (interaction.isChatInputCommand()) {\n        const command = client.commands.get(interaction.commandName);\n        \n        if (!command) {\n            console.error(`‚ùå Aucune commande correspondant √† ${interaction.commandName} trouv√©e.`);\n            return;\n        }\n        \n        try {\n            await command.execute(interaction);\n        } catch (error) {\n            console.error(`‚ùå Erreur lors de l'ex√©cution de ${interaction.commandName}:`, error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Error')\n                .setDescription('There was an error while executing this command!')\n                .setTimestamp();\n            \n            if (interaction.replied || interaction.deferred) {\n                await interaction.followUp({ embeds: [errorEmbed], ephemeral: true });\n            } else {\n                await interaction.reply({ embeds: [errorEmbed], ephemeral: true });\n            }\n        }\n    }\n    \n    // Handle button interactions\n    if (interaction.isButton()) {\n        console.log(`üîò Button interaction: ${interaction.customId}`);\n        try {\n            // Add Balance button\n            if (interaction.customId === 'add_balance') {\n                await handleAddBalance(interaction);\n            }\n            // Create channel button\n            else if (interaction.customId === 'create_channel') {\n                await handleCreateChannel(interaction);\n            }\n            // Re-add balance button\n            else if (interaction.customId === 'readd_balance') {\n                await handleAddBalance(interaction);\n            }\n            // Close channel button\n            else if (interaction.customId === 'close_channel') {\n                await handleCloseChannel(interaction);\n            }\n            // Blackjack game buttons\n            else if (interaction.customId.startsWith('blackjack_')) {\n                await handleBlackjackInteraction(interaction);\n            }\n            // Roulette game buttons\n            else if (interaction.customId.startsWith('roulette_')) {\n                await handleRouletteInteraction(interaction);\n            }\n            // Casino game quick start buttons\n            else if (interaction.customId === 'casino_blackjack') {\n                console.log('üÉè Casino blackjack button clicked');\n                await handleCasinoBlackjack(interaction);\n            }\n            else if (interaction.customId === 'casino_roulette') {\n                console.log('üé∞ Casino roulette button clicked');\n                await handleCasinoRoulette(interaction);\n            }\n            // Other button handlers can be added here\n            else {\n                console.log(`‚ùì Interaction bouton inconnue: ${interaction.customId}`);\n            }\n        } catch (error) {\n            console.error('‚ùå Erreur d\\'interaction bouton:', error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Error')\n                .setDescription('There was an error processing your request!')\n                .setTimestamp();\n            \n            if (interaction.replied || interaction.deferred) {\n                await interaction.followUp({ embeds: [errorEmbed], ephemeral: true });\n            } else {\n                await interaction.reply({ embeds: [errorEmbed], ephemeral: true });\n            }\n        }\n    }\n    \n    // Handle select menu interactions\n    if (interaction.isStringSelectMenu()) {\n        try {\n            // Roulette number selection\n            if (interaction.customId === 'roulette_bet_number') {\n                await handleRouletteNumberBet(interaction);\n            }\n        } catch (error) {\n            console.error('‚ùå Erreur d\\'interaction menu:', error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Error')\n                .setDescription('There was an error processing your selection!')\n                .setTimestamp();\n            \n            if (interaction.replied || interaction.deferred) {\n                await interaction.followUp({ embeds: [errorEmbed], ephemeral: true });\n            } else {\n                await interaction.reply({ embeds: [errorEmbed], ephemeral: true });\n            }\n        }\n    }\n});\n\n// Add Balance handler\nasync function handleAddBalance(interaction) {\n    await interaction.deferReply({ ephemeral: false });\n    \n    try {\n        // Generate new LTC address for each deposit request (always new address)\n        const newAddress = ltcWallet.generateAddress();\n        \n        if (!newAddress) {\n            throw new Error('Failed to generate Litecoin address');\n        }\n        \n        // Link address to user and add to active deposits monitoring\n        const userProfiles = require('./utils/userProfiles.js');\n        const securityManager = require('./utils/securityManager.js');\n        const logManager = require('./utils/logManager.js');\n        \n        await userProfiles.linkAddressToUser(interaction.user.id, newAddress.address);\n        securityManager.addActiveDeposit(interaction.user.id, newAddress.address, 0);\n        \n        // Log address generation\n        await logManager.sendBalanceLog(client, interaction.guild.id, {\n            type: 'address_generated',\n            user: interaction.user,\n            address: newAddress.address\n        });\n        \n        // Start smart monitoring for this deposit\n        startSmartMonitoring();\n        \n        const depositEmbed = new EmbedBuilder()\n            .setColor('#f7931a')\n            .setTitle('üí∞ Add Balance - New Litecoin Address')\n            .setDescription('Send the amount you want to deposit to the **new unique address** below:')\n            .addFields(\n                { name: 'üìç Deposit Address (NEW)', value: `\\`${newAddress.address}\\``, inline: false },\n                { name: '‚è±Ô∏è Smart Detection', value: 'Monitoring active - deposits detected within 30 seconds', inline: true },\n                { name: 'üîÑ Status', value: 'Waiting for deposit...', inline: true },\n                { name: 'üîí Security', value: 'This address is unique to this deposit request', inline: false }\n            )\n            .setThumbnail('https://cryptologos.cc/logos/litecoin-ltc-logo.png')\n            .setFooter({ text: 'Casino Bot ‚Ä¢ Smart Monitoring Active' })\n            .setTimestamp();\n        \n        await interaction.editReply({ \n            embeds: [depositEmbed]\n        });\n        \n        // Send address as plain text in a separate message\n        await interaction.followUp({\n            content: `**Adresse de d√©p√¥t:** \\`${newAddress.address}\\`\\n\\n‚ö†Ô∏è **Important:**\\n‚Ä¢ Votre balance sera ajout√©e une fois le paiement confirm√© √† **100%**\\n‚Ä¢ Si apr√®s **20 minutes** votre balance n'a toujours pas √©t√© ajout√©e ou qu'il y a un souci, veuillez ping un staff`,\n            ephemeral: false\n        });\n        \n        console.log(`üîç Surveillance d√©marr√©e pour l'adresse ${newAddress.address} (utilisateur ${interaction.user.username})`);\n        \n    } catch (error) {\n        console.error('‚ùå Add balance error:', error);\n        \n        const errorEmbed = new EmbedBuilder()\n            .setColor('#ff0000')\n            .setTitle('‚ùå Error')\n            .setDescription('Failed to generate deposit address. Please try again.')\n            .setTimestamp();\n        \n        await interaction.editReply({ embeds: [errorEmbed] });\n    }\n}\n\n// Create Channel handler\nasync function handleCreateChannel(interaction) {\n    await interaction.deferReply({ ephemeral: false });\n    \n    try {\n        const guild = interaction.guild;\n        const user = interaction.user;\n        \n        // Check if user already has a channel\n        const existingChannel = guild.channels.cache.find(channel => \n            channel.name === `casino-${user.username.toLowerCase()}` && \n            channel.type === 0 // Text channel\n        );\n        \n        if (existingChannel) {\n            const alreadyExistsEmbed = new EmbedBuilder()\n                .setColor('#ffaa00')\n                .setTitle('‚ö†Ô∏è Channel Already Exists')\n                .setDescription(`You already have a private channel: ${existingChannel}`)\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [alreadyExistsEmbed] });\n            return;\n        }\n        \n        // Create private channel\n        const channel = await guild.channels.create({\n            name: `casino-${user.username.toLowerCase()}`,\n            type: 0, // Text channel\n            topic: `Private casino session for ${user.username}`,\n            permissionOverwrites: [\n                {\n                    id: guild.id,\n                    deny: ['ViewChannel', 'SendMessages']\n                },\n                {\n                    id: user.id,\n                    allow: ['ViewChannel', 'SendMessages', 'ReadMessageHistory']\n                }\n                // Add staff role permissions here if needed\n                // {\n                //     id: 'STAFF_ROLE_ID',\n                //     allow: ['ViewChannel', 'SendMessages', 'ReadMessageHistory']\n                // }\n            ]\n        });\n        \n        const successEmbed = new EmbedBuilder()\n            .setColor('#00ff00')\n            .setTitle('‚úÖ Private Channel Created')\n            .setDescription(`Your private casino channel has been created: ${channel}`)\n            .addFields(\n                { name: 'üé∞ Features Available', value: '‚Ä¢ Check balance\\n‚Ä¢ Play casino games\\n‚Ä¢ Withdraw funds\\n‚Ä¢ Get support', inline: false },\n                { name: '‚è∞ Auto-Delete', value: 'Channel will be deleted after 24 hours of inactivity', inline: false }\n            )\n            .setTimestamp();\n        \n        await interaction.editReply({ embeds: [successEmbed] });\n        \n        // Send welcome message in the new channel\n        const welcomeEmbed = new EmbedBuilder()\n            .setColor('#f7931a')\n            .setTitle('üé∞ Welcome to Your Private Casino!')\n            .setDescription(`Hello ${user}! This is your private casino session.`)\n            .addFields(\n                { name: 'üí∞ Available Commands', value: '‚Ä¢ `/profile` - View your profile\\n‚Ä¢ `/balance` - Check balance\\n‚Ä¢ `/givebal` - Transfer balance\\n‚Ä¢ `/convert-eur-usd` - Currency converter', inline: false },\n                { name: 'üéÆ Coming Soon', value: '‚Ä¢ Blackjack\\n‚Ä¢ Roulette\\n‚Ä¢ Slots', inline: true },\n                { name: 'üîß Support', value: 'Need help? Staff can access this channel.', inline: true }\n            )\n            .setThumbnail(user.displayAvatarURL())\n            .setTimestamp();\n        \n        await channel.send({ embeds: [welcomeEmbed] });\n        \n        console.log(`üè† Private channel created: ${channel.name} for ${user.username}`);\n        \n        // Auto-close channel after 20 minutes\n        setTimeout(async () => {\n            try {\n                const logManager = require('./utils/logManager.js');\n                await logManager.sendBalanceLog(client, interaction.guild.id, {\n                    type: 'channel_closed',\n                    user: interaction.user,\n                    details: 'Auto-close after 20 minutes'\n                });\n                \n                await channel.delete('Auto-close after 20 minutes');\n                console.log(`üîí Auto-closed channel ${channel.name} after 20 minutes`);\n            } catch (autoCloseError) {\n                console.error('Error auto-closing channel:', autoCloseError);\n            }\n        }, 20 * 60 * 1000); // 20 minutes\n        \n    } catch (error) {\n        console.error('‚ùå Create channel error:', error);\n        \n        const errorEmbed = new EmbedBuilder()\n            .setColor('#ff0000')\n            .setTitle('‚ùå Error')\n            .setDescription('Failed to create private channel. Please contact staff.')\n            .setTimestamp();\n        \n        await interaction.editReply({ embeds: [errorEmbed] });\n    }\n}\n\n// Close Channel handler\nasync function handleCloseChannel(interaction) {\n    await interaction.deferReply({ ephemeral: false });\n    \n    try {\n        const channel = interaction.channel;\n        \n        // Log channel closure\n        const logManager = require('./utils/logManager.js');\n        await logManager.sendBalanceLog(client, interaction.guild.id, {\n            type: 'channel_closed',\n            user: interaction.user,\n            details: 'Manually closed by user'\n        });\n        \n        const confirmEmbed = new EmbedBuilder()\n            .setColor('#ff6600')\n            .setTitle('üîí Channel Closing')\n            .setDescription('This channel will be deleted in 5 seconds...')\n            .setTimestamp();\n        \n        await interaction.editReply({ embeds: [confirmEmbed] });\n        \n        // Delete channel after 5 seconds\n        setTimeout(async () => {\n            try {\n                await channel.delete('Manually closed by user');\n                console.log(`üîí Channel ${channel.name} closed by ${interaction.user.username}`);\n            } catch (deleteError) {\n                console.error('Error deleting channel:', deleteError);\n            }\n        }, 5000);\n        \n    } catch (error) {\n        console.error('‚ùå Close channel error:', error);\n        \n        const errorEmbed = new EmbedBuilder()\n            .setColor('#ff0000')\n            .setTitle('‚ùå Error')\n            .setDescription('Unable to close the channel. Please try again.')\n            .setTimestamp();\n        \n        await interaction.editReply({ embeds: [errorEmbed] });\n    }\n}\n\n// Blackjack interaction handler\nasync function handleBlackjackInteraction(interaction) {\n    const { activeGames, calculateHandValue, dealCard, createGameEmbed, createGameButtons } = require('./commands/blackjack.js');\n    const userProfiles = require('./utils/userProfiles.js');\n    const securityManager = require('./utils/securityManager.js');\n    const logManager = require('./utils/logManager.js');\n    const { formatLTC } = require('./utils/formatters.js');\n    \n    await interaction.deferUpdate();\n    \n    const userId = interaction.user.id;\n    const game = activeGames.get(userId);\n    \n    if (!game || game.status !== 'playing') {\n        return;\n    }\n    \n    try {\n        if (interaction.customId === 'blackjack_hit') {\n            // Player hits\n            game.playerHand.push(dealCard(game));\n            game.playerValue = calculateHandValue(game.playerHand);\n            game.canDoubleDown = false;\n            \n            if (game.playerValue > 21) {\n                game.status = 'lost';\n                activeGames.delete(userId);\n                \n                // Log the game\n                await logManager.sendGamblingLog(client, interaction.guild.id, {\n                    type: 'blackjack',\n                    user: interaction.user,\n                    game: 'blackjack',\n                    bet: game.bet,\n                    result: 'lose',\n                    payout: 0,\n                    details: `Player busted with ${game.playerValue}`\n                });\n            }\n            \n        } else if (interaction.customId === 'blackjack_stand') {\n            // Player stands - dealer plays\n            while (game.dealerValue < 17) {\n                game.dealerHand.push(dealCard(game));\n                game.dealerValue = calculateHandValue(game.dealerHand);\n            }\n            \n            // Determine winner\n            let payout = 0;\n            if (game.dealerValue > 21) {\n                game.status = 'won';\n                payout = game.bet * 2;\n            } else if (game.playerValue > game.dealerValue) {\n                game.status = 'won';\n                payout = game.bet * 2;\n            } else if (game.playerValue < game.dealerValue) {\n                game.status = 'lost';\n                payout = 0;\n            } else {\n                game.status = 'push';\n                payout = game.bet; // Return bet\n            }\n            \n            // Update balance\n            if (payout > 0) {\n                const profile = userProfiles.getUserProfile(userId);\n                userProfiles.updateUserProfile(userId, { \n                    balance: profile.balance + payout \n                });\n            }\n            \n            // Log the game\n            await logManager.sendGamblingLog(client, interaction.guild.id, {\n                type: 'blackjack',\n                user: interaction.user,\n                game: 'blackjack',\n                bet: game.bet,\n                result: game.status === 'won' ? 'win' : game.status === 'lost' ? 'lose' : 'push',\n                payout: payout,\n                details: `Player: ${game.playerValue}, Dealer: ${game.dealerValue}`\n            });\n            \n            activeGames.delete(userId);\n            \n        } else if (interaction.customId === 'blackjack_double') {\n            // Player doubles down\n            const profile = userProfiles.getUserProfile(userId);\n            if (profile.balance >= game.bet) {\n                userProfiles.updateUserProfile(userId, { \n                    balance: profile.balance - game.bet \n                });\n                securityManager.addWageredAmount(userId, game.bet);\n                \n                game.bet *= 2;\n                game.playerHand.push(dealCard(game));\n                game.playerValue = calculateHandValue(game.playerHand);\n                \n                if (game.playerValue > 21) {\n                    game.status = 'lost';\n                } else {\n                    // Dealer plays\n                    while (game.dealerValue < 17) {\n                        game.dealerHand.push(dealCard(game));\n                        game.dealerValue = calculateHandValue(game.dealerHand);\n                    }\n                    \n                    // Determine winner\n                    let payout = 0;\n                    if (game.dealerValue > 21 || game.playerValue > game.dealerValue) {\n                        game.status = 'won';\n                        payout = game.bet * 2;\n                    } else if (game.playerValue < game.dealerValue) {\n                        game.status = 'lost';\n                        payout = 0;\n                    } else {\n                        game.status = 'push';\n                        payout = game.bet;\n                    }\n                    \n                    if (payout > 0) {\n                        const updatedProfile = userProfiles.getUserProfile(userId);\n                        userProfiles.updateUserProfile(userId, { \n                            balance: updatedProfile.balance + payout \n                        });\n                    }\n                }\n                \n                // Log the game\n                await logManager.sendGamblingLog(client, interaction.guild.id, {\n                    type: 'blackjack',\n                    user: interaction.user,\n                    game: 'blackjack',\n                    bet: game.bet,\n                    result: game.status === 'won' ? 'win' : game.status === 'lost' ? 'lose' : 'push',\n                    payout: payout || 0,\n                    details: `Double Down - Player: ${game.playerValue}, Dealer: ${game.dealerValue}`\n                });\n                \n                activeGames.delete(userId);\n            }\n        }\n        \n        // Update the game display\n        const gameEmbed = createGameEmbed(game, interaction.user);\n        const gameButtons = createGameButtons(game);\n        \n        await interaction.editReply({ \n            embeds: [gameEmbed],\n            components: game.status === 'playing' ? [gameButtons] : []\n        });\n        \n    } catch (error) {\n        console.error('Erreur blackjack interaction:', error);\n    }\n}\n\n// Roulette interaction handler\nasync function handleRouletteInteraction(interaction) {\n    const { activeSpins, spinWheel, calculatePayout, createResultEmbed, createBettingEmbed, createBettingComponents } = require('./commands/roulette.js');\n    const userProfiles = require('./utils/userProfiles.js');\n    const securityManager = require('./utils/securityManager.js');\n    const logManager = require('./utils/logManager.js');\n    const { formatLTC } = require('./utils/formatters.js');\n    \n    await interaction.deferUpdate();\n    \n    const userId = interaction.user.id;\n    const spin = activeSpins.get(userId);\n    \n    if (!spin || spin.status !== 'betting') {\n        return;\n    }\n    \n    try {\n        if (interaction.customId === 'roulette_spin') {\n            if (spin.bets.size === 0) {\n                return; // No bets placed\n            }\n            \n            // Deduct total bet amount\n            let totalBet = 0;\n            for (const [, amount] of spin.bets) {\n                totalBet += amount;\n            }\n            \n            const profile = userProfiles.getUserProfile(userId);\n            userProfiles.updateUserProfile(userId, { \n                balance: profile.balance - totalBet \n            });\n            securityManager.addWageredAmount(userId, totalBet);\n            \n            // Spin the wheel\n            const result = spinWheel();\n            const { totalPayout, winningBets } = calculatePayout(spin.bets, result);\n            \n            // Add winnings to balance\n            if (totalPayout > 0) {\n                const updatedProfile = userProfiles.getUserProfile(userId);\n                userProfiles.updateUserProfile(userId, { \n                    balance: updatedProfile.balance + totalPayout \n                });\n            }\n            \n            // Log the game\n            await logManager.sendGamblingLog(client, interaction.guild.id, {\n                type: 'roulette',\n                user: interaction.user,\n                game: 'roulette',\n                bet: totalBet,\n                result: totalPayout > 0 ? 'win' : 'lose',\n                payout: totalPayout,\n                details: `Number ${result}, Total Bet: ${formatLTC(totalBet)} LTC`\n            });\n            \n            // Check for big win (5x or more)\n            if (totalPayout >= totalBet * 5) {\n                await logManager.sendGamblingLog(client, interaction.guild.id, {\n                    type: 'big_win',\n                    user: interaction.user,\n                    game: 'roulette',\n                    bet: totalBet,\n                    result: 'win',\n                    payout: totalPayout\n                });\n            }\n            \n            spin.status = 'finished';\n            spin.result = result;\n            spin.totalPayout = totalPayout;\n            \n            const resultEmbed = createResultEmbed(spin, result, totalPayout, winningBets, interaction.user);\n            \n            await interaction.editReply({ \n                embeds: [resultEmbed],\n                components: []\n            });\n            \n            activeSpins.delete(userId);\n            \n        } else if (interaction.customId === 'roulette_clear') {\n            spin.bets.clear();\n            const bettingEmbed = createBettingEmbed(spin, interaction.user);\n            const bettingComponents = createBettingComponents();\n            \n            await interaction.editReply({ \n                embeds: [bettingEmbed],\n                components: bettingComponents\n            });\n            \n        } else if (interaction.customId === 'roulette_cancel') {\n            activeSpins.delete(userId);\n            \n            const cancelEmbed = new EmbedBuilder()\n                .setColor('#ff6600')\n                .setTitle('üö´ Roulette Cancelled')\n                .setDescription('Your roulette game has been cancelled.')\n                .setTimestamp();\n            \n            await interaction.editReply({ \n                embeds: [cancelEmbed],\n                components: []\n            });\n            \n        } else {\n            // Handle bet buttons\n            const betType = interaction.customId.replace('roulette_bet_', '');\n            const betAmount = spin.bet / 4; // Split bet into quarters\n            \n            if (spin.bets.has(betType)) {\n                spin.bets.set(betType, spin.bets.get(betType) + betAmount);\n            } else {\n                spin.bets.set(betType, betAmount);\n            }\n            \n            const bettingEmbed = createBettingEmbed(spin, interaction.user);\n            const bettingComponents = createBettingComponents();\n            \n            await interaction.editReply({ \n                embeds: [bettingEmbed],\n                components: bettingComponents\n            });\n        }\n        \n    } catch (error) {\n        console.error('Erreur roulette interaction:', error);\n    }\n}\n\n// Roulette number bet handler\nasync function handleRouletteNumberBet(interaction) {\n    const { activeSpins, createBettingEmbed, createBettingComponents } = require('./commands/roulette.js');\n    \n    await interaction.deferUpdate();\n    \n    const userId = interaction.user.id;\n    const spin = activeSpins.get(userId);\n    \n    if (!spin || spin.status !== 'betting') {\n        return;\n    }\n    \n    try {\n        const selectedValue = interaction.values[0];\n        const betAmount = spin.bet / 4; // Split bet into quarters\n        \n        if (spin.bets.has(selectedValue)) {\n            spin.bets.set(selectedValue, spin.bets.get(selectedValue) + betAmount);\n        } else {\n            spin.bets.set(selectedValue, betAmount);\n        }\n        \n        const bettingEmbed = createBettingEmbed(spin, interaction.user);\n        const bettingComponents = createBettingComponents();\n        \n        await interaction.editReply({ \n            embeds: [bettingEmbed],\n            components: bettingComponents\n        });\n        \n    } catch (error) {\n        console.error('Erreur roulette number bet:', error);\n    }\n}\n\n// Casino game quick start handlers\nasync function handleCasinoBlackjack(interaction) {\n    await interaction.deferUpdate();\n    \n    const quickPlayEmbed = new EmbedBuilder()\n        .setColor('#9932cc')\n        .setTitle('üÉè Quick Play Blackjack')\n        .setDescription('Ready to play Blackjack? Use the command `/blackjack <bet>` to start!')\n        .addFields(\n            {\n                name: 'üéØ How to Play',\n                value: '‚Ä¢ Beat the dealer by getting closer to 21 without going over\\n‚Ä¢ Face cards are worth 10, Aces are 1 or 11\\n‚Ä¢ You can Hit, Stand, or Double Down',\n                inline: false\n            },\n            {\n                name: 'üí∞ Example Commands',\n                value: '‚Ä¢ `/blackjack bet:0.01` - Play with 0.01 LTC\\n‚Ä¢ `/blackjack bet:0.1` - Play with 0.1 LTC',\n                inline: false\n            }\n        )\n        .setFooter({ text: 'Good luck at the tables!' })\n        .setTimestamp();\n    \n    await interaction.editReply({ embeds: [quickPlayEmbed] });\n}\n\nasync function handleCasinoRoulette(interaction) {\n    await interaction.deferUpdate();\n    \n    const quickPlayEmbed = new EmbedBuilder()\n        .setColor('#9932cc')\n        .setTitle('üé∞ Quick Play Roulette')\n        .setDescription('Ready to spin the wheel? Use the command `/roulette <bet>` to start!')\n        .addFields(\n            {\n                name: 'üéØ How to Play',\n                value: '‚Ä¢ Choose your bets: numbers (35:1), colors (1:1), even/odd (1:1)\\n‚Ä¢ The ball will land on a number from 0-36\\n‚Ä¢ Multiple bets allowed per spin',\n                inline: false\n            },\n            {\n                name: 'üí∞ Example Commands',\n                value: '‚Ä¢ `/roulette bet:0.01` - Play with 0.01 LTC\\n‚Ä¢ `/roulette bet:0.1` - Play with 0.1 LTC',\n                inline: false\n            }\n        )\n        .setFooter({ text: 'Place your bets!' })\n        .setTimestamp();\n    \n    await interaction.editReply({ embeds: [quickPlayEmbed] });\n}\n\n// Smart monitoring system\nlet monitoringInterval = null;\n\n/**\n * Start smart monitoring for active deposits\n */\nfunction startSmartMonitoring() {\n    // Don't start if already running\n    if (monitoringInterval) return;\n    \n    console.log('üîç D√©marrage de la surveillance des d√©p√¥ts...');\n    \n    // Surveillance automatique toutes les 2 minutes pour respecter les limites API gratuites\n    monitoringInterval = setInterval(async () => {\n        try {\n            const securityManager = require('./utils/securityManager.js');\n            const userProfiles = require('./utils/userProfiles.js');\n            \n            // Get all active deposits\n            const activeDeposits = securityManager.getAllActiveDeposits();\n            \n            if (activeDeposits.length === 0) {\n                console.log('‚ÑπÔ∏è  Aucun d√©p√¥t actif - arr√™t de la surveillance');\n                stopSmartMonitoring();\n                return;\n            }\n            \n            // Check for new deposits\n            const detectedDeposits = await ltcWallet.smartDepositCheck(activeDeposits);\n            \n            // Process detected deposits\n            for (const deposit of detectedDeposits) {\n                try {\n                    // Add deposit to user profile\n                    userProfiles.addDeposit(deposit.userId, deposit.amount, deposit.address);\n                    \n                    // Add to deposited amount for cashout protection\n                    securityManager.addDepositedAmount(deposit.userId, deposit.amount);\n                    \n                    // Mark deposit as completed\n                    securityManager.completeDepositRequest(deposit.userId, deposit.address);\n                    \n                    // Notify user\n                    await notifyUserOfDeposit(deposit);\n                    \n                } catch (error) {\n                    console.error('Erreur traitement d√©p√¥t:', error);\n                }\n            }\n            \n        } catch (error) {\n            console.error('Erreur surveillance intelligente:', error);\n        }\n    }, 120000); // Check every 2 minutes pour respecter les limites BlockCypher gratuit\n}\n\n/**\n * Stop smart monitoring\n */\nfunction stopSmartMonitoring() {\n    if (monitoringInterval) {\n        clearInterval(monitoringInterval);\n        monitoringInterval = null;\n        console.log('üõë Surveillance intelligente arr√™t√©e');\n    }\n}\n\n/**\n * Notify user of detected deposit\n */\nasync function notifyUserOfDeposit(deposit) {\n    try {\n        const user = await client.users.fetch(deposit.userId);\n        \n        if (user) {\n            const depositEmbed = new EmbedBuilder()\n                .setColor('#00ff00')\n                .setTitle('‚úÖ Deposit Confirmed!')\n                .setDescription('Your Litecoin deposit has been confirmed and added to your balance.')\n                .addFields(\n                    {\n                        name: 'üí∞ Deposit Amount',\n                        value: `**${deposit.amount.toFixed(8)} LTC**`,\n                        inline: true\n                    },\n                    {\n                        name: 'üìç Address',\n                        value: `\\`${deposit.address}\\``,\n                        inline: false\n                    },\n                    {\n                        name: 'üé∞ Ready to Play',\n                        value: 'Use `/casino` to start playing!\\n**Note:** You must wager 100% of deposited amount before cashout.',\n                        inline: false\n                    }\n                )\n                .setThumbnail('https://cryptologos.cc/logos/litecoin-ltc-logo.png')\n                .setTimestamp();\n            \n            // Try to send DM\n            try {\n                await user.send({ embeds: [depositEmbed] });\n                console.log(`üí∞ Utilisateur ${user.username} notifi√© du d√©p√¥t de ${deposit.amount} LTC`);\n            } catch (dmError) {\n                console.log(`Impossible d'envoyer un MP √† ${user.username}:`, dmError.message);\n            }\n        }\n    } catch (error) {\n        console.log('Impossible de notifier l\\'utilisateur du d√©p√¥t:', error.message);\n    }\n}\n\n// Export for external use\nmodule.exports = {\n    client,\n    handleAddBalance,\n    handleCreateChannel,\n    startSmartMonitoring,\n    stopSmartMonitoring\n};\n\n// Gestion d'erreurs globales pour √©viter les d√©connexions\nprocess.on('uncaughtException', (error) => {\n    console.error('‚ö†Ô∏è Erreur non g√©r√©e captur√©e:', error);\n    console.log('üîÑ Le bot continue de fonctionner...');\n});\n\nprocess.on('unhandledRejection', (reason, promise) => {\n    console.error('‚ö†Ô∏è Promesse rejet√©e non g√©r√©e:', reason);\n    console.log('üîÑ Le bot continue de fonctionner...');\n});\n\n// Gestion des erreurs Discord\nclient.on('error', (error) => {\n    console.error('‚ö†Ô∏è Erreur client Discord:', error);\n    console.log('üîÑ Tentative de reconnexion...');\n});\n\nclient.on('warn', (info) => {\n    console.warn('‚ö†Ô∏è Avertissement Discord:', info);\n});\n\nclient.on('disconnect', () => {\n    console.log('‚ö†Ô∏è Bot d√©connect√©, tentative de reconnexion...');\n});\n\nclient.on('reconnecting', () => {\n    console.log('üîÑ Reconnexion en cours...');\n});\n\n// Fonction de reconnexion automatique\nasync function startBotWithRetry() {\n    const token = process.env.DISCORD_TOKEN;\n    \n    if (!token) {\n        console.error('‚ùå DISCORD_TOKEN environment variable is required!');\n        process.exit(1);\n    }\n    \n    let retryCount = 0;\n    const maxRetries = 5;\n    \n    while (retryCount < maxRetries) {\n        try {\n            await client.login(token);\n            console.log('‚úÖ Bot connect√© avec succ√®s!');\n            break;\n        } catch (error) {\n            retryCount++;\n            console.error(`‚ùå √âchec de connexion (tentative ${retryCount}/${maxRetries}):`, error.message);\n            \n            if (retryCount < maxRetries) {\n                const delay = retryCount * 5000; // D√©lai croissant: 5s, 10s, 15s...\n                console.log(`‚è≥ Nouvelle tentative dans ${delay/1000}s...`);\n                await new Promise(resolve => setTimeout(resolve, delay));\n            } else {\n                console.error('‚ùå Impossible de se connecter apr√®s plusieurs tentatives');\n                process.exit(1);\n            }\n        }\n    }\n}\n\n// Start the bot if this file is run directly\nif (require.main === module) {\n    startBotWithRetry();\n}","size_bytes":36563},"attached_assets/casino/events/interactionCreate.js":{"content":"const { Events, EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle } = require('discord.js');\n\nmodule.exports = {\n    name: Events.InteractionCreate,\n    async execute(interaction) {\n        // Handle slash commands\n        if (interaction.isChatInputCommand()) {\n            const command = interaction.client.commands.get(interaction.commandName);\n\n            if (!command) {\n                console.error(`‚ùå No command matching ${interaction.commandName} was found.`);\n                return;\n            }\n\n            try {\n                await command.execute(interaction);\n                console.log(`‚úÖ ${interaction.user.username} a utilis√© /${interaction.commandName}`);\n            } catch (error) {\n                console.error(`‚ùå Erreur lors de l'ex√©cution de ${interaction.commandName}:`, error);\n\n                try {\n                    const errorEmbed = new EmbedBuilder()\n                        .setColor('#ff0000')\n                        .setTitle('‚ùå Command Error')\n                        .setDescription('There was an error while executing this command!')\n                        .setTimestamp();\n\n                    if (interaction.replied || interaction.deferred) {\n                        await interaction.followUp({ embeds: [errorEmbed], ephemeral: true });\n                    } else {\n                        await interaction.reply({ embeds: [errorEmbed], ephemeral: true });\n                    }\n                } catch (replyError) {\n                    console.error('‚ö†Ô∏è Impossible de r√©pondre √† l\\'interaction:', replyError.message);\n                }\n            }\n        }\n\n        // Handle button interactions\n        if (interaction.isButton()) {\n            try {\n                // Check for panel interactions\n                if (interaction.customId.startsWith('panel_')) {\n                    await handlePanelInteraction(interaction);\n                } else {\n                    await handleButtonInteraction(interaction);\n                }\n            } catch (error) {\n                console.error('‚ùå Erreur d\\'interaction bouton:', error);\n\n                try {\n                    const errorEmbed = new EmbedBuilder()\n                        .setColor('#ff0000')\n                        .setTitle('‚ùå Error')\n                        .setDescription('There was an error processing your request!')\n                        .setTimestamp();\n\n                    if (interaction.replied || interaction.deferred) {\n                        await interaction.followUp({ embeds: [errorEmbed], ephemeral: true });\n                    } else {\n                        await interaction.reply({ embeds: [errorEmbed], ephemeral: true });\n                    }\n                } catch (replyError) {\n                    console.error('‚ö†Ô∏è Impossible de r√©pondre √† l\\'interaction bouton:', replyError.message);\n                }\n            }\n        }\n    },\n};\n\n/**\n * Handle button interactions\n */\nasync function handleButtonInteraction(interaction) {\n    const { customId } = interaction;\n    \n    switch (customId) {\n        case 'add_balance':\n            await handleAddBalance(interaction);\n            break;\n        case 'view_profile':\n            await handleViewProfile(interaction);\n            break;\n        case 'leaderboard':\n            await handleLeaderboard(interaction);\n            break;\n        case 'create_channel':\n            await handleCreateChannel(interaction);\n            break;\n        case 'blackjack':\n        case 'roulette':\n        case 'slots':\n            await handleGameNotAvailable(interaction);\n            break;\n        default:\n            console.log(`Interaction bouton inconnue: ${customId}`);\n    }\n}\n\n/**\n * Handle Add Balance button\n */\nasync function handleAddBalance(interaction) {\n    // Avoid duplicate calls from panel interactions\n    if (interaction.customId === 'panel_add_balance') {\n        return; // This is handled by handlePanelInteraction\n    }\n    \n    const { handleAddBalance } = require('../discord-bot.js');\n    await handleAddBalance(interaction);\n}\n\n/**\n * Handle View Profile button\n */\nasync function handleViewProfile(interaction) {\n    // Avoid duplicate calls from panel interactions\n    if (interaction.customId === 'panel_view_profile') {\n        return; // This is handled by handlePanelInteraction\n    }\n    \n    await interaction.deferReply({ ephemeral: true });\n    \n    const profileCommand = require('../commands/profile.js');\n    await profileCommand.execute(interaction);\n}\n\n/**\n * Handle Leaderboard button\n */\nasync function handleLeaderboard(interaction) {\n    await interaction.deferReply({ ephemeral: true });\n    \n    try {\n        const userProfiles = require('../utils/userProfiles.js');\n        const { formatLTC } = require('../utils/formatters.js');\n        const leaderboard = userProfiles.getLeaderboard('balance', 10);\n        \n        if (leaderboard.length === 0) {\n            const emptyEmbed = new EmbedBuilder()\n                .setColor('#ffaa00')\n                .setTitle('üèÜ Casino Leaderboard')\n                .setDescription('No players yet! Be the first to add balance.')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [emptyEmbed] });\n            return;\n        }\n        \n        let leaderboardText = '';\n        const medals = ['ü•á', 'ü•à', 'ü•â'];\n        \n        for (let i = 0; i < leaderboard.length; i++) {\n            const user = leaderboard[i];\n            const medal = i < 3 ? medals[i] : `${i + 1}.`;\n            \n            try {\n                const discordUser = await interaction.client.users.fetch(user.userId);\n                leaderboardText += `${medal} **${discordUser.username}** - ${formatLTC(user.value)} LTC\\n`;\n            } catch (error) {\n                leaderboardText += `${medal} **Unknown User** - ${formatLTC(user.value)} LTC\\n`;\n            }\n        }\n        \n        const leaderboardEmbed = new EmbedBuilder()\n            .setColor('#ffd700')\n            .setTitle('üèÜ Casino Leaderboard')\n            .setDescription('**Top Players by Balance**\\n\\n' + leaderboardText)\n            .setThumbnail('https://cryptologos.cc/logos/litecoin-ltc-logo.png')\n            .setFooter({ text: 'Rankings update in real-time' })\n            .setTimestamp();\n        \n        await interaction.editReply({ embeds: [leaderboardEmbed] });\n        \n    } catch (error) {\n        console.error('Leaderboard error:', error);\n        \n        const errorEmbed = new EmbedBuilder()\n            .setColor('#ff0000')\n            .setTitle('‚ùå Error')\n            .setDescription('Failed to load leaderboard. Please try again.')\n            .setTimestamp();\n        \n        await interaction.editReply({ embeds: [errorEmbed] });\n    }\n}\n\n/**\n * Handle Create Channel button\n */\nasync function handleCreateChannel(interaction) {\n    const { handleCreateChannel } = require('../discord-bot.js');\n    await handleCreateChannel(interaction);\n}\n\n/**\n * Handle panel interactions (creates tickets)\n */\nasync function handlePanelInteraction(interaction) {\n    // Check if interaction is too old\n    const interactionAge = Date.now() - interaction.createdTimestamp;\n    if (interactionAge > 10 * 60 * 1000) {\n        console.log('Interaction trop ancienne, ignor√©e');\n        return;\n    }\n    \n    const ticketManager = require('../utils/ticketManager.js');\n    const panelManager = require('../utils/panelManager.js');\n    \n    const { customId } = interaction;\n    \n    // Determine ticket type based on button\n    let ticketType = 'general';\n    let actionName = 'Casino';\n    \n    if (customId === 'panel_add_balance') {\n        ticketType = 'balance';\n        actionName = 'Add Balance';\n    } else if (customId === 'panel_view_profile') {\n        ticketType = 'profile';\n        actionName = 'Profile';\n    }\n    \n    await interaction.deferReply({ ephemeral: true });\n    \n    try {\n        // Get panel configuration for ticket category\n        const panelConfig = panelManager.getPanelConfig('casinoPanel');\n        const categoryId = panelConfig?.ticketCategory;\n        const staffRoleId = panelConfig?.staffRole;\n        \n        // Create ticket\n        const result = await ticketManager.createTicket(\n            interaction.guild,\n            interaction.user,\n            categoryId,\n            staffRoleId,\n            ticketType\n        );\n        \n        if (result.success) {\n            const successEmbed = new EmbedBuilder()\n                .setColor('#00ff00')\n                .setTitle('‚úÖ Private Channel Created')\n                .setDescription(`Your private ${actionName.toLowerCase()} channel has been created!`)\n                .addFields({\n                    name: 'üé´ Your Channel',\n                    value: `${result.channel}`,\n                    inline: false\n                })\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [successEmbed] });\n            \n            // Send welcome message in ticket\n            await sendTicketWelcome(result.channel, interaction.user, ticketType);\n            \n        } else if (result.error === 'existing') {\n            const existingEmbed = new EmbedBuilder()\n                .setColor('#ffaa00')\n                .setTitle('‚ö†Ô∏è Channel Already Exists')\n                .setDescription(`You already have a private ${actionName.toLowerCase()} channel!`)\n                .addFields({\n                    name: 'üé´ Your Existing Channel',\n                    value: `${result.channel}`,\n                    inline: false\n                })\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [existingEmbed] });\n            \n        } else {\n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Failed to Create Channel')\n                .setDescription('Unable to create your private channel. Please contact staff.')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n        \n    } catch (error) {\n        console.error('Erreur panel interaction:', error);\n        \n        const errorEmbed = new EmbedBuilder()\n            .setColor('#ff0000')\n            .setTitle('‚ùå Error')\n            .setDescription('An error occurred while processing your request.')\n            .setTimestamp();\n        \n        await interaction.editReply({ embeds: [errorEmbed] });\n    }\n}\n\n/**\n * Send welcome message in ticket channel\n */\nasync function sendTicketWelcome(channel, user, ticketType) {\n    try {\n        let welcomeEmbed;\n        \n        if (ticketType === 'balance') {\n            const { handleAddBalance } = require('../discord-bot.js');\n            \n            welcomeEmbed = new EmbedBuilder()\n                .setColor('#00ff00')\n                .setTitle('üí∞ Private Balance Channel')\n                .setDescription(`Welcome ${user}! This is your private channel for balance operations.`)\n                .addFields(\n                    {\n                        name: 'üìã Available Actions',\n                        value: '‚Ä¢ Click the button below to generate a deposit address\\n‚Ä¢ Check your balance with commands\\n‚Ä¢ Safe and private environment',\n                        inline: false\n                    }\n                )\n                .setThumbnail(user.displayAvatarURL())\n                .setTimestamp();\n            \n            const balanceButton = new ActionRowBuilder()\n                .addComponents(\n                    new ButtonBuilder()\n                        .setCustomId('add_balance')\n                        .setLabel('üí∞ Generate Deposit Address')\n                        .setStyle(ButtonStyle.Success)\n                        .setEmoji('üí∞')\n                );\n            \n            await channel.send({ \n                embeds: [welcomeEmbed],\n                components: [balanceButton]\n            });\n            \n        } else if (ticketType === 'profile') {\n            welcomeEmbed = new EmbedBuilder()\n                .setColor('#0099ff')\n                .setTitle('üë§ Private Profile Channel')\n                .setDescription(`Welcome ${user}! This is your private channel for profile management.`)\n                .addFields(\n                    {\n                        name: 'üìã Available Actions',\n                        value: '‚Ä¢ Use `/profile` to view your statistics\\n‚Ä¢ Use `/balance` to check your funds\\n‚Ä¢ Use `/givebal` to transfer to other users',\n                        inline: false\n                    }\n                )\n                .setThumbnail(user.displayAvatarURL())\n                .setTimestamp();\n            \n            await channel.send({ embeds: [welcomeEmbed] });\n            \n        } else {\n            welcomeEmbed = new EmbedBuilder()\n                .setColor('#f7931a')\n                .setTitle('üé∞ Private Casino Channel')\n                .setDescription(`Welcome ${user}! This is your private casino session.`)\n                .addFields(\n                    {\n                        name: 'üéÆ Available Commands',\n                        value: '‚Ä¢ `/profile` - View your profile\\n‚Ä¢ `/balance` - Check balance\\n‚Ä¢ `/casino` - Access main panel\\n‚Ä¢ `/convert-eur-usd` - Currency converter',\n                        inline: false\n                    }\n                )\n                .setThumbnail(user.displayAvatarURL())\n                .setTimestamp();\n            \n            await channel.send({ embeds: [welcomeEmbed] });\n        }\n        \n    } catch (error) {\n        console.error('Erreur envoi welcome message:', error);\n    }\n}\n\n/**\n * Handle game buttons (not yet implemented)\n */\nasync function handleGameNotAvailable(interaction) {\n    const gameNames = {\n        'blackjack': 'üÉè Blackjack',\n        'roulette': 'üé≤ Roulette',\n        'slots': 'üé∞ Slots'\n    };\n    \n    const gameName = gameNames[interaction.customId] || 'Game';\n    \n    const comingSoonEmbed = new EmbedBuilder()\n        .setColor('#ffaa00')\n        .setTitle('üöß Coming Soon!')\n        .setDescription(`${gameName} is currently under development and will be available soon!`)\n        .addFields({\n            name: 'üéÆ Available Features',\n            value: '‚Ä¢ Balance management\\n‚Ä¢ Currency conversion\\n‚Ä¢ Deposit/withdrawal system\\n‚Ä¢ User profiles',\n            inline: false\n        })\n        .setFooter({ text: 'Stay tuned for exciting casino games!' })\n        .setTimestamp();\n    \n    await interaction.reply({ embeds: [comingSoonEmbed], ephemeral: true });\n}","size_bytes":14699},"attached_assets/casino/events/ready.js":{"content":"const { Events } = require('discord.js');\n\nmodule.exports = {\n    name: Events.ClientReady,\n    once: true,\n    execute(client) {\n        console.log(`üé∞ Bot Casino Discord pr√™t! Connect√© en tant que ${client.user.tag}`);\n        console.log(`üîó Connect√© √† ${client.guilds.cache.size} serveur(s)`);\n        console.log(`üë• Au service de ${client.users.cache.size} utilisateur(s)`);\n        \n        // Set bot status\n        client.user.setActivity('üé∞ Litecoin Casino | /casino', { type: 'PLAYING' });\n        \n        // Initialize smart monitoring if there are active deposits\n        checkAndStartSmartMonitoring(client);\n    },\n};\n\n/**\n * Check for active deposits and start smart monitoring if needed\n */\nfunction checkAndStartSmartMonitoring(client) {\n    const securityManager = require('../utils/securityManager.js');\n    const { startSmartMonitoring } = require('../discord-bot.js');\n    \n    // Check if there are any active deposits\n    const activeDeposits = securityManager.getAllActiveDeposits();\n    \n    if (activeDeposits.length > 0) {\n        console.log(`üîç ${activeDeposits.length} d√©p√¥t(s) actif(s) trouv√©(s) - d√©marrage de la surveillance intelligente`);\n        startSmartMonitoring();\n    } else {\n        console.log('‚ÑπÔ∏è  Aucun d√©p√¥t actif trouv√© - la surveillance d√©marrera quand n√©cessaire');\n    }\n}","size_bytes":1355},"attached_assets/casino/index.js":{"content":"","size_bytes":0},"attached_assets/casino/litecoin-casino-bot.js":{"content":"const fs = require('fs');\nconst litecore = require('litecore-lib');\nconst litecoinDirect = require('./utils/litecoinDirect.js');\n\n// Configuration pour connexion directe (pas d'API key n√©cessaire)\nconst NETWORK = 'ltc'; // Litecoin mainnet\n\n// File to store generated addresses\nconst ADDRESSES_FILE = 'addresses.json';\n\n/**\n * Load saved addresses from JSON file\n * @returns {Array} List of addresses with their private keys\n */\nfunction loadAddresses() {\n    try {\n        if (fs.existsSync(ADDRESSES_FILE)) {\n            const data = fs.readFileSync(ADDRESSES_FILE, 'utf8');\n            return JSON.parse(data);\n        }\n    } catch (error) {\n        console.error('Error loading addresses:', error.message);\n    }\n    return [];\n}\n\n/**\n * Save addresses to JSON file\n * @param {Array} addresses - List of addresses to save\n */\nfunction saveAddresses(addresses) {\n    try {\n        fs.writeFileSync(ADDRESSES_FILE, JSON.stringify(addresses, null, 2));\n        console.log(`‚úÖ Addresses saved to ${ADDRESSES_FILE}`);\n    } catch (error) {\n        console.error('Error saving addresses:', error.message);\n    }\n}\n\n/**\n * Generate a new Litecoin address with its private key\n * This function uses litecore-lib to create a private key/public address pair\n * Perfect for later integration into a Discord bot with games like blackjack/roulette\n * @returns {Object} Object containing the address and private key\n */\nfunction generateAddress() {\n    try {\n        // Generate a new random private key\n        const privateKey = new litecore.PrivateKey();\n        \n        // Create the corresponding public address\n        const address = privateKey.toAddress();\n        \n        const newAddress = {\n            address: address.toString(),\n            privateKey: privateKey.toString(),\n            createdAt: new Date().toISOString(),\n            balance: 0 // Will be updated during checks\n        };\n        \n        // Load existing addresses\n        const addresses = loadAddresses();\n        \n        // Add the new address\n        addresses.push(newAddress);\n        \n        // Save\n        saveAddresses(addresses);\n        \n        console.log(`üîë New address generated: ${newAddress.address}`);\n        return newAddress;\n        \n    } catch (error) {\n        console.error('Error generating address:', error.message);\n        return null;\n    }\n}\n\n/**\n * V√©rifie le solde d'une adresse via connexion directe (sans API key)\n * @param {string} address - L'adresse Litecoin √† v√©rifier\n * @returns {Promise<number>} Le solde en LTC\n */\nasync function getAddressBalance(address) {\n    try {\n        return await litecoinDirect.getAddressBalance(address, false); // false = mainnet\n    } catch (error) {\n        console.error(`‚ùå Erreur v√©rification pour ${address.substring(0, 10)}...:`, error.message);\n        return 0;\n    }\n}\n\n/**\n * V√©rifie automatiquement les d√©p√¥ts sur toutes les adresses\n * Cette fonction peut √™tre appel√©e p√©riodiquement pour d√©tecter les nouveaux d√©p√¥ts\n * Id√©al pour un bot casino qui doit cr√©diter automatiquement les joueurs\n */\nasync function checkDeposits() {\n    const addresses = loadAddresses();\n    \n    if (addresses.length === 0) {\n        console.log('‚ÑπÔ∏è  Aucune adresse √† v√©rifier');\n        return;\n    }\n    \n    console.log(`üîç V√©rification de ${addresses.length} adresse(s)...`);\n    \n    for (let i = 0; i < addresses.length; i++) {\n        const addressData = addresses[i];\n        console.log(`üîç V√©rification ${i + 1}/${addresses.length}: ${addressData.address.substring(0, 10)}...`);\n        \n        const currentBalance = await getAddressBalance(addressData.address);\n        \n        // Check if there was a new deposit\n        if (currentBalance > addressData.balance) {\n            const deposit = currentBalance - addressData.balance;\n            console.log(`üí∞ Deposit detected: ${deposit} LTC on address ${addressData.address}`);\n            \n            // Update balance\n            addresses[i].balance = currentBalance;\n            addresses[i].lastChecked = new Date().toISOString();\n        } else if (currentBalance === addressData.balance) {\n            console.log(`‚ÑπÔ∏è  Aucun nouveau d√©p√¥t pour ${addressData.address.substring(0, 10)}...`);\n        }\n        \n        // D√©lai de 5 secondes pour √™tre respectueux envers les explorateurs publics\n        await new Promise(resolve => setTimeout(resolve, 5000));\n    }\n    \n    // Sauvegarde des soldes mis √† jour\n    saveAddresses(addresses);\n}\n\n/**\n * Obtient les UTXOs (unspent outputs) d'une adresse via connexion directe\n * N√©cessaire pour construire des transactions de retrait\n * @param {string} address - L'adresse Litecoin\n * @returns {Promise<Array>} Liste des UTXOs\n */\nasync function getAddressUTXOs(address) {\n    try {\n        return await litecoinDirect.getAddressUTXOs(address, false); // false = mainnet\n    } catch (error) {\n        console.error('Erreur UTXO:', error.message);\n        return [];\n    }\n}\n\n/**\n * Diffuse une transaction sur le r√©seau Litecoin via connexion directe\n * @param {string} txHex - Transaction s√©rialis√©e en hexad√©cimal\n * @returns {Promise<string|null>} L'ID de la transaction ou null en cas d'erreur\n */\nasync function broadcastTransaction(txHex) {\n    try {\n        return await litecoinDirect.broadcastTransaction(txHex, false); // false = mainnet\n    } catch (error) {\n        console.error('Erreur de diffusion:', error.message);\n        return null;\n    }\n}\n\n/**\n * Effectue un retrait depuis une adresse vers une destination\n * Fonction principale pour les retraits du casino - peut √™tre int√©gr√©e facilement\n * dans un bot Discord pour permettre aux joueurs de retirer leurs gains\n * @param {string} fromAddress - Adresse source (doit √™tre dans notre fichier)\n * @param {string} toAddress - Adresse de destination\n * @param {number} amount - Montant en LTC √† envoyer\n * @param {number} feeRate - Frais en satoshis par byte (d√©faut: 1000 sat/kb = 1 sat/byte)\n * @returns {Promise<string|null>} L'ID de la transaction ou null en cas d'erreur\n */\nasync function withdraw(fromAddress, toAddress, amount, feeRate = 1) {\n    try {\n        // Recherche de la cl√© priv√©e correspondante\n        const addresses = loadAddresses();\n        const addressData = addresses.find(addr => addr.address === fromAddress);\n        \n        if (!addressData) {\n            console.error(`‚ùå Adresse ${fromAddress} non trouv√©e dans notre portefeuille`);\n            return null;\n        }\n        \n        console.log(`üè¶ Pr√©paration du retrait de ${amount} LTC depuis ${fromAddress} vers ${toAddress}`);\n        \n        // R√©cup√©ration des UTXOs\n        const utxos = await getAddressUTXOs(fromAddress);\n        if (utxos.length === 0) {\n            console.error('‚ùå Aucun UTXO disponible pour cette adresse');\n            return null;\n        }\n        \n        // Conversion du montant en satoshis\n        const amountSatoshis = Math.round(amount * 100000000);\n        \n        // Cr√©ation de la transaction\n        const transaction = new litecore.Transaction();\n        \n        // Ajout des inputs (UTXOs) avec script P2PKH standard\n        let totalInputs = 0;\n        for (const utxo of utxos) {\n            // G√©n√©ration du script P2PKH standard pour l'adresse\n            const address = litecore.Address.fromString(fromAddress);\n            const script = litecore.Script.buildPublicKeyHashOut(address);\n            \n            transaction.from({\n                txId: utxo.txid,\n                outputIndex: utxo.outputIndex,\n                address: fromAddress,\n                script: script.toHex(),\n                satoshis: utxo.satoshis\n            });\n            totalInputs += utxo.satoshis;\n        }\n        \n        // Estimation des frais (taille approximative * fee rate)\n        const estimatedSize = 180 + (utxos.length * 180); // Estimation basique\n        const fees = estimatedSize * feeRate;\n        \n        // V√©rification que nous avons assez de fonds\n        if (totalInputs < amountSatoshis + fees) {\n            console.error(`‚ùå Fonds insuffisants. Disponible: ${totalInputs/100000000} LTC, Requis: ${(amountSatoshis + fees)/100000000} LTC`);\n            return null;\n        }\n        \n        // Ajout de l'output principal (destination)\n        transaction.to(toAddress, amountSatoshis);\n        \n        // Calcul et ajout du change (monnaie rendue)\n        const change = totalInputs - amountSatoshis - fees;\n        if (change > 5460) { // Dust limit pour Litecoin\n            transaction.to(fromAddress, change);\n        }\n        \n        // Signature de la transaction avec la cl√© priv√©e\n        const privateKey = new litecore.PrivateKey(addressData.privateKey);\n        transaction.sign(privateKey);\n        \n        // S√©rialisation de la transaction\n        const txHex = transaction.serialize();\n        console.log(`üì§ Transaction cr√©√©e (${txHex.length/2} bytes): ${txHex.substring(0, 64)}...`);\n        \n        // Diffusion sur le r√©seau\n        const txid = await broadcastTransaction(txHex);\n        \n        if (txid) {\n            // Mise √† jour du solde local (approximatif)\n            const addressIndex = addresses.findIndex(addr => addr.address === fromAddress);\n            if (addressIndex !== -1) {\n                addresses[addressIndex].balance -= amount;\n                addresses[addressIndex].lastWithdrawal = {\n                    amount: amount,\n                    to: toAddress,\n                    txid: txid,\n                    timestamp: new Date().toISOString()\n                };\n                saveAddresses(addresses);\n            }\n        }\n        \n        return txid;\n        \n    } catch (error) {\n        console.error('‚ùå Erreur lors du retrait:', error.message);\n        return null;\n    }\n}\n\n/**\n * Affiche le statut de toutes les adresses\n */\nfunction showWalletStatus() {\n    const addresses = loadAddresses();\n    \n    if (addresses.length === 0) {\n        console.log('üíº Portefeuille vide - aucune adresse g√©n√©r√©e');\n        return;\n    }\n    \n    console.log('\\nüíº === STATUT DU PORTEFEUILLE ===');\n    let totalBalance = 0;\n    \n    addresses.forEach((addr, index) => {\n        console.log(`\\n${index + 1}. Adresse: ${addr.address}`);\n        console.log(`   Solde: ${addr.balance} LTC`);\n        console.log(`   Cr√©√©e: ${new Date(addr.createdAt).toLocaleString()}`);\n        if (addr.lastChecked) {\n            console.log(`   Derni√®re v√©rif: ${new Date(addr.lastChecked).toLocaleString()}`);\n        }\n        totalBalance += addr.balance;\n    });\n    \n    console.log(`\\nüí∞ SOLDE TOTAL: ${totalBalance} LTC`);\n    console.log('===================================\\n');\n}\n\n/**\n * Smart deposit monitoring - only check active deposit requests\n * Called by Discord bot when needed\n */\nasync function smartDepositCheck(activeAddresses = []) {\n    if (activeAddresses.length === 0) {\n        console.log('‚ÑπÔ∏è  No active deposit requests to monitor');\n        return [];\n    }\n    \n    console.log(`üîç Smart monitoring ${activeAddresses.length} active deposit(s)...`);\n    const detectedDeposits = [];\n    \n    for (const addressData of activeAddresses) {\n        const currentBalance = await getAddressBalance(addressData.address);\n        \n        // Check if there was a new deposit\n        if (currentBalance > addressData.lastKnownBalance) {\n            const depositAmount = currentBalance - addressData.lastKnownBalance;\n            \n            detectedDeposits.push({\n                address: addressData.address,\n                amount: depositAmount,\n                newBalance: currentBalance,\n                userId: addressData.userId\n            });\n            \n            console.log(`üí∞ Deposit detected: ${depositAmount} LTC on address ${addressData.address}`);\n        }\n        \n        // Small delay to avoid API overload\n        await new Promise(resolve => setTimeout(resolve, 1000));\n    }\n    \n    return detectedDeposits;\n}\n\n/**\n * Initialize wallet system (no automatic monitoring)\n */\nfunction initializeWallet() {\n    console.log('üé∞ === LITECOIN CASINO WALLET SYSTEM ===');\n    console.log('‚úÖ Wallet system initialized - Smart monitoring mode');\n    console.log('üìã AVAILABLE FUNCTIONS:');\n    console.log('- generateAddress(): Create new address');\n    console.log('- smartDepositCheck(): Check active deposits only');\n    console.log('- withdraw(from, to, amount): Process withdrawal');\n    console.log('- showWalletStatus(): Display wallet status');\n}\n\n// Point d'entr√©e - initialise le syst√®me\nif (require.main === module) {\n    initializeWallet();\n}\n\n// Export des fonctions pour utilisation externe (bot Discord, etc.)\nmodule.exports = {\n    generateAddress,\n    checkDeposits,\n    smartDepositCheck,\n    withdraw,\n    showWalletStatus,\n    loadAddresses,\n    getAddressBalance,\n    initializeWallet\n};","size_bytes":12903},"attached_assets/casino/replit.md":{"content":"# Overview\n\nThis project is a complete Litecoin casino Discord bot system built with Node.js and Discord.js v14+. The application provides full wallet management including address generation, deposit monitoring, withdrawal capabilities, and a complete Discord bot interface with slash commands, interactive panels, and real-time notifications. The system integrates BlockCypher API for fast blockchain interactions and litecore-lib for cryptographic operations. The bot features automatic deposit detection, balance management, currency conversion, user profiles, and is designed as a foundation for casino gaming features like blackjack and roulette.\n\n# User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n# System Architecture\n\n## Core Application Structure\nThe application follows a modular Discord bot architecture with separate command handlers, event listeners, and utility modules. The system includes both a standalone Litecoin wallet system and a complete Discord bot integration with slash commands, interactive panels, and real-time user notifications.\n\n## Discord Bot Architecture\n- **Main Bot File**: `discord-bot.js` - Central Discord client and interaction handling\n- **Commands System**: Modular slash commands in `/commands/` directory\n- **Events System**: Discord event handlers in `/events/` directory\n- **User Profiles**: Complete user management system with balance tracking\n- **Currency Conversion**: Real-time EUR/USD exchange rates with external APIs\n\n## Address Management System\n- **Address Generation**: Uses litecore-lib to create cryptographically secure Litecoin address pairs\n- **Data Persistence**: JSON file-based storage system for addresses and private keys\n- **Address Structure**: Each address record contains the public address, private key, creation timestamp, and balance tracking\n\n## Blockchain Integration\n- **Direct Library Integration**: Uses litecore-lib and direct blockchain explorers, eliminating API rate limits and costs\n- **Network Configuration**: Configured for Litecoin mainnet (LTC) operations\n- **Real-time Monitoring**: 2-minute interval deposit detection with Discord notifications\n- **No External API Dependencies**: Completely self-contained system without third-party API costs\n\n## File System Design\n- **Configuration Management**: Environment-based API key handling with fallback defaults\n- **Data Storage**: JSON-based persistence with error handling and data validation\n- **Modular Functions**: Clear separation between address generation, loading, and saving operations\n\n## Security Considerations\n- Private keys are generated using cryptographically secure random number generation\n- Local file storage for sensitive data (suitable for development, would need enhancement for production)\n- API key configuration system for secure third-party service integration\n\n# External Dependencies\n\n## Discord Integration\n- **discord.js**: Discord API wrapper v14+ for bot functionality, slash commands, and interactions\n- **Discord Bot Features**: Slash commands, button interactions, embed messages, and real-time notifications\n\n## Blockchain Libraries\n- **litecore-lib**: Core Litecoin cryptographic library for address generation and private key management\n- **Direct Blockchain Integration**: Direct connection to blockchain explorers without paid APIs\n- **No Rate Limits**: Unlimited transactions and monitoring without API restrictions\n\n## HTTP and Utility Libraries  \n- **axios**: HTTP client for API communications with blockchain and currency services\n- **dotenv**: Environment variable management for secure API key storage\n- **Node.js fs module**: File system operations for local data persistence\n\n## Currency APIs\n- **ExchangeRate-API**: Real-time currency conversion for EUR/USD pairs\n- **CoinGecko API**: Cryptocurrency price data for Litecoin USD/EUR prices\n\n## Development Dependencies\n- **@types/node**: TypeScript definitions for Node.js development support\n\n## Implemented Features\nThe Discord bot includes complete casino functionality with:\n\n### Core Casino System\n- User profiles with balance tracking and recovery systems\n- Complete deposit detection and monitoring with direct blockchain integration\n- Currency conversion between EUR/USD with real-time exchange rates\n- Secure password protection system with recovery keys\n- Enhanced balance display (shows \"0\" instead of \"0.00000000\" for zero balances)\n\n### Panel and Ticket Management System\n- **Panel Management**: Channel-specific casino panels that can be configured with `/setpanel`\n- **Ticket System**: Private ticket channels created when users interact with panels (similar to TicketTool)\n- **Whitelist System**: Server whitelisting with `/addwhitelist` command for panel management\n- **Smart Interactions**: Panel buttons (`panel_add_balance`, `panel_view_profile`) create private channels for users\n\n### Advanced Features\n- **Rate Limit Protection**: Smart API rate limiting with 8-second delays and proper 429 error handling\n- **French Console Logs**: Console output in French while maintaining English user interface\n- **Robust Error Handling**: Automatic reconnection system preventing bot disconnections\n- **Private Channel Management**: Automatic ticket cleanup and category organization\n- **Active Deposit Management**: `/stopallactives` command to manage monitoring\n\n### Available Slash Commands (20 total)\n- `/balance`, `/profile`, `/casino` - Core user functions\n- `/setpassword`, `/changepassword`, `/recoverykey` - Security system  \n- `/givebal`, `/cashout` - Balance management\n- `/setpanel`, `/addwhitelist` - Panel and server management\n- `/convert-eur-usd`, `/convert-usd-eur` - Currency tools\n- `/enable`, `/stopallactives` - Monitoring controls\n- `/testgamble`, `/resetrecovery` - Testing and recovery\n- `/blackjack`, `/roulette` - Casino games\n- `/setlogbal`, `/setloggamble` - Logging configuration\n\n### Casino Games System (New!)\n- **Blackjack Game**: Complete blackjack implementation with hit, stand, and double down mechanics\n- **Roulette Game**: Full European roulette with number bets (35:1), color bets (1:1), and even/odd bets (1:1)\n- **Game State Management**: Active games tracking with 2-minute auto-timeout\n- **Interactive Controls**: Button-based gameplay with real-time updates\n- **Comprehensive Logging**: All game results logged to configured channels\n\n### Enhanced Deposit System\n- **Always New Addresses**: Each deposit request generates a completely new address\n- **Enhanced Channel Management**: Private channels with auto-close after 20 minutes\n- **Non-Ephemeral Messages**: Deposit addresses sent as normal messages for easy copying\n- **Staff Ping Instructions**: Clear 20-minute timeout warnings with staff ping guidance\n- **Advanced Logging**: Comprehensive logging system for all deposit and gambling activities\n\n### Logging System (New!)\n- **Balance Log Channel**: Configure with `/setlogbal` for deposit confirmations and address generations\n- **Gambling Log Channel**: Configure with `/setloggamble` for game results and big wins\n- **Automated Big Win Detection**: Special notifications for wins 5x or larger\n- **Channel Auto-Management**: Automatic ticket cleanup and category organization\n\nThe system is now production-ready with complete casino functionality including blackjack and roulette games, enhanced user experience, and comprehensive logging systems.","size_bytes":7377},"attached_assets/casino/utils/channelManager.js":{"content":"const fs = require('fs');\nconst path = require('path');\n\nconst CHANNEL_COUNTER_FILE = path.join(__dirname, '../data/channel_counter.json');\n\nclass ChannelManager {\n    constructor() {\n        this.channelData = this.loadChannelData();\n    }\n\n    loadChannelData() {\n        try {\n            if (fs.existsSync(CHANNEL_COUNTER_FILE)) {\n                return JSON.parse(fs.readFileSync(CHANNEL_COUNTER_FILE, 'utf8'));\n            }\n        } catch (error) {\n            console.error('Erreur chargement donn√©es channels:', error);\n        }\n        \n        return {\n            balanceCounter: 0,\n            activeChannels: {},\n            channelHistory: []\n        };\n    }\n\n    saveChannelData() {\n        try {\n            fs.writeFileSync(CHANNEL_COUNTER_FILE, JSON.stringify(this.channelData, null, 2));\n            console.log('‚úÖ Donn√©es channels sauvegard√©es');\n        } catch (error) {\n            console.error('Erreur sauvegarde channels:', error);\n        }\n    }\n\n    getNextBalanceChannelName() {\n        this.channelData.balanceCounter++;\n        this.saveChannelData();\n        \n        const number = this.channelData.balanceCounter.toString().padStart(3, '0');\n        return `deposit-${number}`;\n    }\n\n    registerChannel(channelId, userId, type = 'balance') {\n        this.channelData.activeChannels[channelId] = {\n            userId: userId,\n            type: type,\n            createdAt: Date.now(),\n            lastActivity: Date.now()\n        };\n        \n        this.channelData.channelHistory.push({\n            channelId: channelId,\n            userId: userId,\n            type: type,\n            createdAt: Date.now()\n        });\n        \n        this.saveChannelData();\n        console.log(`üìù Channel ${channelId} enregistr√© pour utilisateur ${userId}`);\n    }\n\n    unregisterChannel(channelId) {\n        if (this.channelData.activeChannels[channelId]) {\n            delete this.channelData.activeChannels[channelId];\n            this.saveChannelData();\n            console.log(`üóëÔ∏è Channel ${channelId} d√©senregistr√©`);\n        }\n    }\n\n    getChannelInfo(channelId) {\n        return this.channelData.activeChannels[channelId] || null;\n    }\n\n    getUserActiveChannels(userId) {\n        return Object.entries(this.channelData.activeChannels)\n            .filter(([channelId, data]) => data.userId === userId)\n            .map(([channelId, data]) => ({ channelId, ...data }));\n    }\n\n    getStats() {\n        return {\n            totalCreated: this.channelData.balanceCounter,\n            currentActive: Object.keys(this.channelData.activeChannels).length,\n            totalHistory: this.channelData.channelHistory.length\n        };\n    }\n}\n\nmodule.exports = new ChannelManager();","size_bytes":2727},"attached_assets/casino/utils/currencyConverter.js":{"content":"const axios = require('axios');\n\n// Free currency conversion API (you can change this to your preferred service)\nconst API_BASE_URL = 'https://api.exchangerate-api.com/v4/latest';\n\n/**\n * Get exchange rate between two currencies\n * @param {string} from - Source currency (e.g., 'EUR')\n * @param {string} to - Target currency (e.g., 'USD')\n * @returns {Promise<number>} Exchange rate\n */\nasync function getExchangeRate(from, to) {\n    try {\n        const response = await axios.get(`${API_BASE_URL}/${from}`, {\n            timeout: 5000\n        });\n        \n        if (response.data && response.data.rates && response.data.rates[to]) {\n            return response.data.rates[to];\n        } else {\n            throw new Error(`Exchange rate not found for ${from} to ${to}`);\n        }\n    } catch (error) {\n        console.error('Currency API error:', error.message);\n        throw new Error('Failed to fetch exchange rate. Please try again later.');\n    }\n}\n\n/**\n * Convert amount from one currency to another\n * @param {number} amount - Amount to convert\n * @param {string} from - Source currency\n * @param {string} to - Target currency\n * @returns {Promise<Object>} Conversion result\n */\nasync function convertCurrency(amount, from, to) {\n    if (amount <= 0) {\n        throw new Error('Amount must be greater than 0');\n    }\n    \n    const rate = await getExchangeRate(from, to);\n    const convertedAmount = amount * rate;\n    \n    return {\n        originalAmount: amount,\n        convertedAmount: parseFloat(convertedAmount.toFixed(2)),\n        fromCurrency: from.toUpperCase(),\n        toCurrency: to.toUpperCase(),\n        exchangeRate: rate,\n        timestamp: new Date().toISOString()\n    };\n}\n\n/**\n * Get multiple currency rates for display\n * @param {string} baseCurrency - Base currency (e.g., 'USD')\n * @returns {Promise<Object>} Multiple exchange rates\n */\nasync function getMultipleRates(baseCurrency = 'USD') {\n    try {\n        const response = await axios.get(`${API_BASE_URL}/${baseCurrency}`, {\n            timeout: 5000\n        });\n        \n        if (response.data && response.data.rates) {\n            return {\n                base: baseCurrency.toUpperCase(),\n                rates: response.data.rates,\n                lastUpdated: response.data.date || new Date().toISOString().split('T')[0]\n            };\n        } else {\n            throw new Error('Failed to fetch exchange rates');\n        }\n    } catch (error) {\n        console.error('Currency API error:', error.message);\n        throw new Error('Failed to fetch exchange rates. Please try again later.');\n    }\n}\n\n/**\n * Format currency amount for display\n * @param {number} amount - Amount to format\n * @param {string} currency - Currency code\n * @returns {string} Formatted currency string\n */\nfunction formatCurrency(amount, currency) {\n    const symbols = {\n        'USD': '$',\n        'EUR': '‚Ç¨',\n        'GBP': '¬£',\n        'JPY': '¬•',\n        'BTC': '‚Çø',\n        'LTC': '≈Å'\n    };\n    \n    const symbol = symbols[currency.toUpperCase()] || currency.toUpperCase();\n    \n    if (currency.toUpperCase() === 'JPY') {\n        return `${symbol}${Math.round(amount).toLocaleString()}`;\n    }\n    \n    return `${symbol}${amount.toLocaleString('en-US', { \n        minimumFractionDigits: 2, \n        maximumFractionDigits: 2 \n    })}`;\n}\n\n/**\n * Get current Litecoin price in specified currency\n * @param {string} currency - Target currency (default: USD)\n * @returns {Promise<Object>} LTC price data\n */\nasync function getLitecoinPrice(currency = 'USD') {\n    try {\n        // Using CoinGecko API for crypto prices (free tier)\n        const response = await axios.get(`https://api.coingecko.com/api/v3/simple/price?ids=litecoin&vs_currencies=${currency.toLowerCase()}`, {\n            timeout: 5000\n        });\n        \n        if (response.data && response.data.litecoin) {\n            const price = response.data.litecoin[currency.toLowerCase()];\n            return {\n                price: price,\n                currency: currency.toUpperCase(),\n                symbol: 'LTC',\n                timestamp: new Date().toISOString()\n            };\n        } else {\n            throw new Error('Litecoin price not found');\n        }\n    } catch (error) {\n        console.error('Crypto price API error:', error.message);\n        throw new Error('Failed to fetch Litecoin price. Please try again later.');\n    }\n}\n\nmodule.exports = {\n    getExchangeRate,\n    convertCurrency,\n    getMultipleRates,\n    formatCurrency,\n    getLitecoinPrice\n};","size_bytes":4527},"attached_assets/casino/utils/formatters.js":{"content":"/**\n * Utilities for formatting numbers and currencies\n */\n\n/**\n * Format LTC amount to remove unnecessary trailing zeros\n * @param {number} amount - LTC amount\n * @returns {string} - Formatted LTC string\n */\nfunction formatLTC(amount) {\n    if (amount === 0) {\n        return '0';\n    }\n    \n    // Convert to fixed 8 decimal places first\n    const fixed = amount.toFixed(8);\n    \n    // Remove trailing zeros and unnecessary decimal point\n    const formatted = parseFloat(fixed).toString();\n    \n    // If the number is very small, show scientific notation\n    if (amount < 0.00001 && amount > 0) {\n        return amount.toExponential(3);\n    }\n    \n    return formatted;\n}\n\n/**\n * Format USD amount with 2 decimal places\n * @param {number} amount - USD amount\n * @returns {string} - Formatted USD string\n */\nfunction formatUSD(amount) {\n    return amount.toFixed(2);\n}\n\n/**\n * Format percentage with 1 decimal place\n * @param {number} percentage - Percentage value\n * @returns {string} - Formatted percentage string\n */\nfunction formatPercentage(percentage) {\n    return percentage.toFixed(1);\n}\n\nmodule.exports = {\n    formatLTC,\n    formatUSD,\n    formatPercentage\n};","size_bytes":1172},"attached_assets/casino/utils/litecoinDirect.js":{"content":"/**\n * Litecoin Direct Connection - No API Keys Required\n * Uses public blockchain explorers and direct libraries\n */\n\nconst axios = require('axios');\nconst bitcoin = require('bitcoinjs-lib');\n\n// Public Litecoin explorer APIs (no API key required)\nconst EXPLORERS = {\n    mainnet: {\n        base: 'https://litecoinspace.org/api',\n        fallback: 'https://insight.litecore.io/api'\n    },\n    testnet: {\n        base: 'https://litecoinspace.org/testnet/api',\n        fallback: 'https://testnet.litecore.io/api'\n    }\n};\n\n// Network configuration\nconst NETWORK = bitcoin.networks.bitcoin; // Litecoin uses Bitcoin network params\n\n/**\n * Get address balance using public explorer\n * @param {string} address - Litecoin address\n * @param {boolean} testnet - Use testnet (default: false)\n * @returns {Promise<number>} Balance in LTC\n */\nasync function getAddressBalance(address, testnet = false) {\n    const explorer = testnet ? EXPLORERS.testnet : EXPLORERS.mainnet;\n    \n    try {\n        // Try primary explorer\n        const response = await axios.get(`${explorer.base}/address/${address}`, {\n            timeout: 10000\n        });\n        \n        if (response.data && typeof response.data.chain_stats !== 'undefined') {\n            // Litecoin Space format\n            const confirmedBalance = response.data.chain_stats.funded_txo_sum || 0;\n            const spentBalance = response.data.chain_stats.spent_txo_sum || 0;\n            const balance = (confirmedBalance - spentBalance) / 100000000; // Convert satoshis to LTC\n            \n            if (balance > 0) {\n                console.log(`‚úÖ ${address.substring(0, 10)}...: ${balance} LTC`);\n            }\n            return balance;\n        }\n        \n        return 0;\n        \n    } catch (error) {\n        console.log(`‚ö†Ô∏è Erreur explorer principal pour ${address.substring(0, 10)}...: ${error.message}`);\n        \n        // Try fallback explorer\n        try {\n            const fallbackResponse = await axios.get(`${explorer.fallback}/addr/${address}`, {\n                timeout: 10000\n            });\n            \n            if (fallbackResponse.data && typeof fallbackResponse.data.balance !== 'undefined') {\n                // Insight API format\n                const balance = parseFloat(fallbackResponse.data.balance);\n                \n                if (balance > 0) {\n                    console.log(`‚úÖ ${address.substring(0, 10)}... (fallback): ${balance} LTC`);\n                }\n                return balance;\n            }\n            \n        } catch (fallbackError) {\n            console.log(`‚ö†Ô∏è Fallback √©galement √©chou√© pour ${address.substring(0, 10)}...: ${fallbackError.message}`);\n        }\n        \n        return 0;\n    }\n}\n\n/**\n * Get UTXO list for address\n * @param {string} address - Litecoin address\n * @param {boolean} testnet - Use testnet (default: false)\n * @returns {Promise<Array>} Array of UTXOs\n */\nasync function getAddressUTXOs(address, testnet = false) {\n    const explorer = testnet ? EXPLORERS.testnet : EXPLORERS.mainnet;\n    \n    try {\n        // Get UTXOs from Litecoin Space\n        const response = await axios.get(`${explorer.base}/address/${address}/utxo`, {\n            timeout: 10000\n        });\n        \n        if (response.data && Array.isArray(response.data)) {\n            return response.data.map(utxo => ({\n                txid: utxo.txid,\n                outputIndex: utxo.vout,\n                script: utxo.scriptpubkey || '',\n                satoshis: utxo.value\n            }));\n        }\n        \n        return [];\n        \n    } catch (error) {\n        console.error(`Erreur UTXO pour ${address}:`, error.message);\n        return [];\n    }\n}\n\n/**\n * Get transaction details\n * @param {string} txid - Transaction ID\n * @param {boolean} testnet - Use testnet (default: false)\n * @returns {Promise<Object|null>} Transaction details\n */\nasync function getTransaction(txid, testnet = false) {\n    const explorer = testnet ? EXPLORERS.testnet : EXPLORERS.mainnet;\n    \n    try {\n        const response = await axios.get(`${explorer.base}/tx/${txid}`, {\n            timeout: 10000\n        });\n        \n        return response.data;\n        \n    } catch (error) {\n        console.error(`Erreur transaction ${txid}:`, error.message);\n        return null;\n    }\n}\n\n/**\n * Broadcast transaction to network\n * @param {string} txHex - Raw transaction hex\n * @param {boolean} testnet - Use testnet (default: false)\n * @returns {Promise<string|null>} Transaction ID if successful\n */\nasync function broadcastTransaction(txHex, testnet = false) {\n    const explorer = testnet ? EXPLORERS.testnet : EXPLORERS.mainnet;\n    \n    try {\n        const response = await axios.post(`${explorer.base}/tx`, txHex, {\n            headers: { 'Content-Type': 'text/plain' },\n            timeout: 15000\n        });\n        \n        if (typeof response.data === 'string') {\n            console.log(`‚úÖ Transaction diffus√©e avec succ√®s: ${response.data}`);\n            return response.data; // Transaction ID\n        }\n        \n        return null;\n        \n    } catch (error) {\n        console.error('Erreur diffusion transaction:', error.message);\n        return null;\n    }\n}\n\n/**\n * Check for new transactions on an address\n * @param {string} address - Litecoin address\n * @param {number} lastCheckedTimestamp - Last check timestamp\n * @param {boolean} testnet - Use testnet (default: false)\n * @returns {Promise<Array>} Array of new transactions\n */\nasync function getNewTransactions(address, lastCheckedTimestamp, testnet = false) {\n    const explorer = testnet ? EXPLORERS.testnet : EXPLORERS.mainnet;\n    \n    try {\n        const response = await axios.get(`${explorer.base}/address/${address}/txs`, {\n            timeout: 10000\n        });\n        \n        if (response.data && Array.isArray(response.data)) {\n            // Filter transactions newer than last check\n            const newTxs = response.data.filter(tx => {\n                const txTimestamp = tx.status?.block_time ? tx.status.block_time * 1000 : Date.now();\n                return txTimestamp > lastCheckedTimestamp;\n            });\n            \n            return newTxs;\n        }\n        \n        return [];\n        \n    } catch (error) {\n        console.error(`Erreur nouvelles transactions pour ${address}:`, error.message);\n        return [];\n    }\n}\n\n/**\n * Check multiple addresses efficiently\n * @param {Array<string>} addresses - Array of addresses to check\n * @param {boolean} testnet - Use testnet (default: false)\n * @returns {Promise<Object>} Object with address -> balance mapping\n */\nasync function checkMultipleAddresses(addresses, testnet = false) {\n    const results = {};\n    \n    // Process addresses with delay to avoid rate limiting\n    for (let i = 0; i < addresses.length; i++) {\n        const address = addresses[i];\n        \n        try {\n            results[address] = await getAddressBalance(address, testnet);\n        } catch (error) {\n            console.error(`Erreur pour ${address}:`, error.message);\n            results[address] = 0;\n        }\n        \n        // Small delay between requests to be respectful to public APIs\n        if (i < addresses.length - 1) {\n            await new Promise(resolve => setTimeout(resolve, 1000)); // 1 second delay\n        }\n    }\n    \n    return results;\n}\n\n/**\n * Health check for explorer APIs\n * @param {boolean} testnet - Use testnet (default: false)\n * @returns {Promise<boolean>} True if APIs are responsive\n */\nasync function healthCheck(testnet = false) {\n    const explorer = testnet ? EXPLORERS.testnet : EXPLORERS.mainnet;\n    \n    try {\n        // Test with a known address (Litecoin Foundation donation address)\n        const testAddress = testnet ? 'mkYY3QRCJKJHZczVz6mJ6ztNKYZrn4s7hS' : 'LTC1QH7KYTQZ9ZXQX3Y8ZGX7ZXQX3Y8ZGX7ZXQX3Y8ZGX7Z';\n        \n        const response = await axios.get(`${explorer.base}/address/${testAddress}`, {\n            timeout: 5000\n        });\n        \n        return response.status === 200;\n        \n    } catch (error) {\n        console.error('Health check failed:', error.message);\n        return false;\n    }\n}\n\nmodule.exports = {\n    getAddressBalance,\n    getAddressUTXOs,\n    getTransaction,\n    broadcastTransaction,\n    getNewTransactions,\n    checkMultipleAddresses,\n    healthCheck,\n    NETWORK\n};","size_bytes":8312},"attached_assets/casino/utils/logManager.js":{"content":"const fs = require('fs');\nconst path = require('path');\nconst { EmbedBuilder } = require('discord.js');\n\nconst CONFIG_FILE = path.join(__dirname, '../data/log_config.json');\n\nfunction loadLogConfig() {\n    try {\n        if (fs.existsSync(CONFIG_FILE)) {\n            const data = fs.readFileSync(CONFIG_FILE, 'utf8');\n            return JSON.parse(data);\n        }\n    } catch (error) {\n        console.error('Error loading log config:', error.message);\n    }\n    return {};\n}\n\n/**\n * Send balance log to configured channel\n * @param {Object} client - Discord client\n * @param {string} serverId - Server ID\n * @param {Object} logData - Log data\n */\nasync function sendBalanceLog(client, serverId, logData) {\n    try {\n        const config = loadLogConfig();\n        const channelId = config[serverId]?.balanceLogChannel;\n        \n        if (!channelId) {\n            console.log('No balance log channel configured for server:', serverId);\n            return;\n        }\n        \n        const channel = await client.channels.fetch(channelId);\n        if (!channel) {\n            console.log('Balance log channel not found:', channelId);\n            return;\n        }\n        \n        const embed = createBalanceLogEmbed(logData);\n        await channel.send({ embeds: [embed] });\n        \n    } catch (error) {\n        console.error('Error sending balance log:', error.message);\n    }\n}\n\n/**\n * Send gambling log to configured channel\n * @param {Object} client - Discord client\n * @param {string} serverId - Server ID\n * @param {Object} logData - Log data\n */\nasync function sendGamblingLog(client, serverId, logData) {\n    try {\n        const config = loadLogConfig();\n        const channelId = config[serverId]?.gamblingLogChannel;\n        \n        if (!channelId) {\n            console.log('No gambling log channel configured for server:', serverId);\n            return;\n        }\n        \n        const channel = await client.channels.fetch(channelId);\n        if (!channel) {\n            console.log('Gambling log channel not found:', channelId);\n            return;\n        }\n        \n        const embed = createGamblingLogEmbed(logData);\n        await channel.send({ embeds: [embed] });\n        \n    } catch (error) {\n        console.error('Error sending gambling log:', error.message);\n    }\n}\n\n/**\n * Create balance log embed\n * @param {Object} logData - Log data\n * @returns {EmbedBuilder} Embed\n */\nfunction createBalanceLogEmbed(logData) {\n    const { type, user, amount, address, details } = logData;\n    \n    let embed = new EmbedBuilder()\n        .setTimestamp();\n    \n    switch (type) {\n        case 'deposit':\n            embed\n                .setColor('#00ff00')\n                .setTitle('üí∞ Deposit Confirmed')\n                .setDescription(`User ${user.username} deposited **${amount} LTC**`)\n                .addFields(\n                    {\n                        name: 'üë§ User',\n                        value: `${user} (${user.id})`,\n                        inline: true\n                    },\n                    {\n                        name: 'üí∞ Amount',\n                        value: `${amount} LTC`,\n                        inline: true\n                    },\n                    {\n                        name: 'üìç Address',\n                        value: `\\`${address}\\``,\n                        inline: false\n                    }\n                );\n            break;\n            \n        case 'address_generated':\n            embed\n                .setColor('#0099ff')\n                .setTitle('üîë Deposit Address Generated')\n                .setDescription(`New deposit address created for ${user.username}`)\n                .addFields(\n                    {\n                        name: 'üë§ User',\n                        value: `${user} (${user.id})`,\n                        inline: true\n                    },\n                    {\n                        name: 'üìç Address',\n                        value: `\\`${address}\\``,\n                        inline: false\n                    }\n                );\n            break;\n            \n        case 'channel_closed':\n            embed\n                .setColor('#ffaa00')\n                .setTitle('üîí Deposit Channel Closed')\n                .setDescription(`Deposit channel closed for ${user.username}`)\n                .addFields(\n                    {\n                        name: 'üë§ User',\n                        value: `${user} (${user.id})`,\n                        inline: true\n                    },\n                    {\n                        name: '‚è±Ô∏è Reason',\n                        value: details || 'Auto-close after 20 minutes',\n                        inline: true\n                    }\n                );\n            break;\n    }\n    \n    return embed;\n}\n\n/**\n * Create gambling log embed\n * @param {Object} logData - Log data\n * @returns {EmbedBuilder} Embed\n */\nfunction createGamblingLogEmbed(logData) {\n    const { type, user, game, bet, result, payout, details } = logData;\n    \n    let embed = new EmbedBuilder()\n        .setTimestamp();\n    \n    switch (type) {\n        case 'blackjack':\n            embed\n                .setColor(result === 'win' ? '#00ff00' : result === 'lose' ? '#ff0000' : '#ffaa00')\n                .setTitle('üÉè Blackjack Game')\n                .setDescription(`${user.username} ${result === 'win' ? 'won' : result === 'lose' ? 'lost' : 'tied'} ${bet} LTC`)\n                .addFields(\n                    {\n                        name: 'üë§ Player',\n                        value: `${user} (${user.id})`,\n                        inline: true\n                    },\n                    {\n                        name: 'üí∞ Bet',\n                        value: `${bet} LTC`,\n                        inline: true\n                    },\n                    {\n                        name: 'üé∞ Result',\n                        value: result.toUpperCase(),\n                        inline: true\n                    },\n                    {\n                        name: 'üíµ Payout',\n                        value: `${payout || 0} LTC`,\n                        inline: true\n                    }\n                );\n            \n            if (details) {\n                embed.addFields({\n                    name: 'üìã Game Details',\n                    value: details,\n                    inline: false\n                });\n            }\n            break;\n            \n        case 'roulette':\n            embed\n                .setColor(result === 'win' ? '#00ff00' : '#ff0000')\n                .setTitle('üé∞ Roulette Spin')\n                .setDescription(`${user.username} ${result === 'win' ? 'won' : 'lost'} ${bet} LTC`)\n                .addFields(\n                    {\n                        name: 'üë§ Player',\n                        value: `${user} (${user.id})`,\n                        inline: true\n                    },\n                    {\n                        name: 'üí∞ Bet',\n                        value: `${bet} LTC`,\n                        inline: true\n                    },\n                    {\n                        name: 'üé∞ Result',\n                        value: result.toUpperCase(),\n                        inline: true\n                    },\n                    {\n                        name: 'üíµ Payout',\n                        value: `${payout || 0} LTC`,\n                        inline: true\n                    }\n                );\n            \n            if (details) {\n                embed.addFields({\n                    name: 'üìã Spin Details',\n                    value: details,\n                    inline: false\n                });\n            }\n            break;\n            \n        case 'big_win':\n            embed\n                .setColor('#ffd700')\n                .setTitle('üèÜ BIG WIN!')\n                .setDescription(`${user.username} hit a big win of **${payout} LTC**!`)\n                .addFields(\n                    {\n                        name: 'üë§ Winner',\n                        value: `${user} (${user.id})`,\n                        inline: true\n                    },\n                    {\n                        name: 'üéÆ Game',\n                        value: game.toUpperCase(),\n                        inline: true\n                    },\n                    {\n                        name: 'üí∞ Bet',\n                        value: `${bet} LTC`,\n                        inline: true\n                    },\n                    {\n                        name: 'üèÜ Win Amount',\n                        value: `${payout} LTC`,\n                        inline: true\n                    }\n                );\n            break;\n    }\n    \n    return embed;\n}\n\nmodule.exports = {\n    sendBalanceLog,\n    sendGamblingLog,\n    createBalanceLogEmbed,\n    createGamblingLogEmbed\n};","size_bytes":8851},"attached_assets/casino/utils/panelManager.js":{"content":"/**\n * Panel Manager for Casino Bot\n * Manages channel configurations and panel systems\n */\n\nconst fs = require('fs');\n\nconst CONFIG_FILE = './data/panel_config.json';\n\n/**\n * Get default configuration\n */\nfunction getDefaultConfig() {\n    return {\n        panels: {\n            casinoPanel: {\n                channelId: null,\n                messageId: null,\n                ticketCategory: null,\n                staffRole: null\n            },\n            addBalancePanel: {\n                channelId: null,\n                messageId: null,\n                ticketCategory: null,\n                staffRole: null\n            }\n        },\n        whitelist: {\n            serverIds: [],\n            adminRoles: []\n        }\n    };\n}\n\n/**\n * Load panel configuration\n */\nfunction loadConfig() {\n    try {\n        if (!fs.existsSync('./data')) {\n            fs.mkdirSync('./data', { recursive: true });\n        }\n        \n        if (fs.existsSync(CONFIG_FILE)) {\n            const data = fs.readFileSync(CONFIG_FILE, 'utf8');\n            return JSON.parse(data);\n        }\n    } catch (error) {\n        console.error('Erreur lors du chargement de la config des panels:', error);\n    }\n    \n    return getDefaultConfig();\n}\n\n/**\n * Save panel configuration\n */\nfunction saveConfig(config) {\n    try {\n        if (!fs.existsSync('./data')) {\n            fs.mkdirSync('./data', { recursive: true });\n        }\n        \n        fs.writeFileSync(CONFIG_FILE, JSON.stringify(config, null, 2));\n        console.log('‚úÖ Configuration des panels sauvegard√©e');\n        return true;\n    } catch (error) {\n        console.error('Erreur lors de la sauvegarde config panels:', error);\n        return false;\n    }\n}\n\n/**\n * Set channel for a specific panel type\n */\nfunction setPanelChannel(panelType, channelId, categoryId = null, staffRole = null) {\n    const config = loadConfig();\n    \n    if (!config.panels[panelType]) {\n        config.panels[panelType] = {\n            channelId: null,\n            messageId: null,\n            ticketCategory: null,\n            staffRole: null\n        };\n    }\n    \n    config.panels[panelType].channelId = channelId;\n    if (categoryId) config.panels[panelType].ticketCategory = categoryId;\n    if (staffRole) config.panels[panelType].staffRole = staffRole;\n    \n    return saveConfig(config);\n}\n\n/**\n * Get panel configuration for a specific type\n */\nfunction getPanelConfig(panelType) {\n    const config = loadConfig();\n    return config.panels[panelType] || null;\n}\n\n/**\n * Check if user/server is whitelisted for panel management\n */\nfunction isWhitelisted(serverId, userId, userRoles) {\n    const config = loadConfig();\n    \n    // Check server whitelist\n    if (!config.whitelist.serverIds.includes(serverId)) {\n        return false;\n    }\n    \n    // Check admin roles\n    if (config.whitelist.adminRoles.length > 0) {\n        const hasAdminRole = config.whitelist.adminRoles.some(roleId => \n            userRoles.includes(roleId)\n        );\n        return hasAdminRole;\n    }\n    \n    return true; // If no admin roles defined, allow all users in whitelisted servers\n}\n\n/**\n * Add server to whitelist\n */\nfunction addToWhitelist(serverId, adminRoleId = null) {\n    const config = loadConfig();\n    \n    if (!config.whitelist.serverIds.includes(serverId)) {\n        config.whitelist.serverIds.push(serverId);\n    }\n    \n    if (adminRoleId && !config.whitelist.adminRoles.includes(adminRoleId)) {\n        config.whitelist.adminRoles.push(adminRoleId);\n    }\n    \n    return saveConfig(config);\n}\n\n/**\n * Remove server from whitelist\n */\nfunction removeFromWhitelist(serverId) {\n    const config = loadConfig();\n    \n    config.whitelist.serverIds = config.whitelist.serverIds.filter(id => id !== serverId);\n    \n    return saveConfig(config);\n}\n\n/**\n * Set message ID for panel (after sending)\n */\nfunction setPanelMessageId(panelType, messageId) {\n    const config = loadConfig();\n    \n    if (config.panels[panelType]) {\n        config.panels[panelType].messageId = messageId;\n        return saveConfig(config);\n    }\n    \n    return false;\n}\n\n/**\n * Get all panel configurations\n */\nfunction getAllPanels() {\n    const config = loadConfig();\n    return config.panels;\n}\n\nmodule.exports = {\n    loadConfig,\n    saveConfig,\n    setPanelChannel,\n    getPanelConfig,\n    isWhitelisted,\n    addToWhitelist,\n    removeFromWhitelist,\n    setPanelMessageId,\n    getAllPanels\n};","size_bytes":4405},"attached_assets/casino/utils/securityManager.js":{"content":"const fs = require('fs');\nconst path = require('path');\nconst crypto = require('crypto');\n\nconst SECURITY_FILE = path.join(__dirname, '../data/user_security.json');\nconst ACTIVE_DEPOSITS_FILE = path.join(__dirname, '../data/active_deposits.json');\nconst GAMBLING_SESSIONS_FILE = path.join(__dirname, '../data/gambling_sessions.json');\n\n// Ensure data directory exists\nconst dataDir = path.join(__dirname, '../data');\nif (!fs.existsSync(dataDir)) {\n    fs.mkdirSync(dataDir, { recursive: true });\n}\n\n/**\n * Load user security data\n * @returns {Object} Security data\n */\nfunction loadSecurityData() {\n    try {\n        if (fs.existsSync(SECURITY_FILE)) {\n            const data = fs.readFileSync(SECURITY_FILE, 'utf8');\n            return JSON.parse(data);\n        }\n    } catch (error) {\n        console.error('Error loading security data:', error.message);\n    }\n    return {};\n}\n\n/**\n * Save user security data\n * @param {Object} data - Security data to save\n */\nfunction saveSecurityData(data) {\n    try {\n        fs.writeFileSync(SECURITY_FILE, JSON.stringify(data, null, 2));\n        console.log('‚úÖ Security data saved');\n    } catch (error) {\n        console.error('Error saving security data:', error.message);\n    }\n}\n\n/**\n * Load active deposits\n * @returns {Object} Active deposits data\n */\nfunction loadActiveDeposits() {\n    try {\n        if (fs.existsSync(ACTIVE_DEPOSITS_FILE)) {\n            const data = fs.readFileSync(ACTIVE_DEPOSITS_FILE, 'utf8');\n            return JSON.parse(data);\n        }\n    } catch (error) {\n        console.error('Error loading active deposits:', error.message);\n    }\n    return {};\n}\n\n/**\n * Save active deposits\n * @param {Object} data - Active deposits data to save\n */\nfunction saveActiveDeposits(data) {\n    try {\n        fs.writeFileSync(ACTIVE_DEPOSITS_FILE, JSON.stringify(data, null, 2));\n        console.log('‚úÖ Active deposits saved');\n    } catch (error) {\n        console.error('Error saving active deposits:', error.message);\n    }\n}\n\n/**\n * Load gambling sessions\n * @returns {Object} Gambling sessions data\n */\nfunction loadGamblingSessions() {\n    try {\n        if (fs.existsSync(GAMBLING_SESSIONS_FILE)) {\n            const data = fs.readFileSync(GAMBLING_SESSIONS_FILE, 'utf8');\n            return JSON.parse(data);\n        }\n    } catch (error) {\n        console.error('Error loading gambling sessions:', error.message);\n    }\n    return {};\n}\n\n/**\n * Save gambling sessions\n * @param {Object} data - Gambling sessions data to save\n */\nfunction saveGamblingSessions(data) {\n    try {\n        fs.writeFileSync(GAMBLING_SESSIONS_FILE, JSON.stringify(data, null, 2));\n        console.log('‚úÖ Gambling sessions saved');\n    } catch (error) {\n        console.error('Error saving gambling sessions:', error.message);\n    }\n}\n\n/**\n * Generate secure recovery key\n * @returns {string} Recovery key\n */\nfunction generateRecoveryKey() {\n    return crypto.randomBytes(16).toString('hex').toUpperCase();\n}\n\n/**\n * Hash password securely\n * @param {string} password - Plain text password\n * @returns {string} Hashed password\n */\nfunction hashPassword(password) {\n    const salt = crypto.randomBytes(16).toString('hex');\n    const hash = crypto.pbkdf2Sync(password, salt, 10000, 64, 'sha512').toString('hex');\n    return `${salt}:${hash}`;\n}\n\n/**\n * Verify password\n * @param {string} password - Plain text password\n * @param {string} hashedPassword - Stored hashed password\n * @returns {boolean} True if password matches\n */\nfunction verifyPassword(password, hashedPassword) {\n    try {\n        const [salt, hash] = hashedPassword.split(':');\n        const verifyHash = crypto.pbkdf2Sync(password, salt, 10000, 64, 'sha512').toString('hex');\n        return hash === verifyHash;\n    } catch (error) {\n        return false;\n    }\n}\n\n/**\n * Get or create user security profile\n * @param {string} userId - Discord user ID\n * @returns {Object} Security profile\n */\nfunction getUserSecurity(userId) {\n    const security = loadSecurityData();\n    \n    if (!security[userId]) {\n        security[userId] = {\n            userId: userId,\n            hasPassword: false,\n            passwordHash: null,\n            recoveryKey: null,\n            depositRequests: [],\n            lastGamblingSession: null,\n            wageredAmount: 0,\n            depositedAmount: 0,\n            canCashout: true,\n            createdAt: new Date().toISOString()\n        };\n        saveSecurityData(security);\n    }\n    \n    return security[userId];\n}\n\n/**\n * Set user password and generate recovery key\n * @param {string} userId - Discord user ID\n * @param {string} password - New password\n * @returns {string} Recovery key\n */\nfunction setUserPassword(userId, password) {\n    const security = loadSecurityData();\n    const userSec = getUserSecurity(userId);\n    \n    const recoveryKey = generateRecoveryKey();\n    \n    userSec.hasPassword = true;\n    userSec.passwordHash = hashPassword(password);\n    userSec.recoveryKey = recoveryKey;\n    \n    security[userId] = userSec;\n    saveSecurityData(security);\n    \n    return recoveryKey;\n}\n\n/**\n * Change user password\n * @param {string} userId - Discord user ID\n * @param {string} oldPassword - Current password\n * @param {string} newPassword - New password\n * @returns {boolean} Success\n */\nfunction changeUserPassword(userId, oldPassword, newPassword) {\n    const security = loadSecurityData();\n    const userSec = getUserSecurity(userId);\n    \n    if (!userSec.hasPassword || !verifyPassword(oldPassword, userSec.passwordHash)) {\n        return false;\n    }\n    \n    userSec.passwordHash = hashPassword(newPassword);\n    security[userId] = userSec;\n    saveSecurityData(security);\n    \n    return true;\n}\n\n/**\n * Verify user password\n * @param {string} userId - Discord user ID\n * @param {string} password - Password to verify\n * @returns {boolean} True if password is correct\n */\nfunction verifyUserPassword(userId, password) {\n    const userSec = getUserSecurity(userId);\n    \n    if (!userSec.hasPassword) {\n        return false;\n    }\n    \n    return verifyPassword(password, userSec.passwordHash);\n}\n\n/**\n * Reset recovery key with old key + password\n * @param {string} userId - Discord user ID\n * @param {string} oldRecoveryKey - Old recovery key\n * @param {string} password - Current password\n * @returns {string|null} New recovery key or null if failed\n */\nfunction resetRecoveryKey(userId, oldRecoveryKey, password) {\n    const security = loadSecurityData();\n    const userSec = getUserSecurity(userId);\n    \n    if (!userSec.hasPassword || \n        userSec.recoveryKey !== oldRecoveryKey.toUpperCase() ||\n        !verifyPassword(password, userSec.passwordHash)) {\n        return null;\n    }\n    \n    const newRecoveryKey = generateRecoveryKey();\n    userSec.recoveryKey = newRecoveryKey;\n    \n    security[userId] = userSec;\n    saveSecurityData(security);\n    \n    return newRecoveryKey;\n}\n\n/**\n * Reset user password and recovery key (Admin function)\n * @param {string} userId - Discord user ID  \n * @param {string} newRecoveryKey - New recovery key to set\n * @returns {Object} Result with success status\n */\nfunction resetPassword(userId, newRecoveryKey) {\n    try {\n        const security = loadSecurityData();\n        const userSec = getUserSecurity(userId);\n        \n        // Reset password to null (user will need to set new one)\n        userSec.hasPassword = false;\n        userSec.passwordHash = null;\n        userSec.recoveryKey = newRecoveryKey;\n        \n        security[userId] = userSec;\n        saveSecurityData(security);\n        \n        console.log(`üîê Admin reset password for user ${userId}`);\n        return { success: true };\n        \n    } catch (error) {\n        console.error('Error resetting password:', error);\n        return { success: false, error: error.message };\n    }\n}\n\n/**\n * Add active deposit request\n * @param {string} userId - Discord user ID\n * @param {string} address - LTC address\n * @param {number} initialBalance - Initial balance of address\n */\nfunction addActiveDeposit(userId, address, initialBalance = 0) {\n    const activeDeposits = loadActiveDeposits();\n    \n    if (!activeDeposits[userId]) {\n        activeDeposits[userId] = [];\n    }\n    \n    activeDeposits[userId].push({\n        address: address,\n        userId: userId,\n        lastKnownBalance: initialBalance,\n        createdAt: new Date().toISOString(),\n        active: true\n    });\n    \n    saveActiveDeposits(activeDeposits);\n}\n\n/**\n * Get active deposits for user\n * @param {string} userId - Discord user ID\n * @returns {Array} Active deposit requests\n */\nfunction getActiveDeposits(userId) {\n    const activeDeposits = loadActiveDeposits();\n    return activeDeposits[userId] || [];\n}\n\n/**\n * Get all active deposits across all users\n * @returns {Array} All active deposit requests\n */\nfunction getAllActiveDeposits() {\n    const activeDeposits = loadActiveDeposits();\n    const allDeposits = [];\n    \n    for (const userId in activeDeposits) {\n        allDeposits.push(...activeDeposits[userId].filter(deposit => deposit.active));\n    }\n    \n    return allDeposits;\n}\n\n/**\n * Complete deposit request\n * @param {string} userId - Discord user ID\n * @param {string} address - LTC address\n */\nfunction completeDepositRequest(userId, address) {\n    const activeDeposits = loadActiveDeposits();\n    \n    if (activeDeposits[userId]) {\n        const deposit = activeDeposits[userId].find(d => d.address === address);\n        if (deposit) {\n            deposit.active = false;\n            deposit.completedAt = new Date().toISOString();\n        }\n    }\n    \n    saveActiveDeposits(activeDeposits);\n}\n\n/**\n * Start gambling session\n * @param {string} userId - Discord user ID\n * @param {number} minutes - Session duration in minutes\n * @returns {Date} Session end time\n */\nfunction startGamblingSession(userId, minutes) {\n    const sessions = loadGamblingSessions();\n    const endTime = new Date(Date.now() + minutes * 60 * 1000);\n    \n    sessions[userId] = {\n        userId: userId,\n        startTime: new Date().toISOString(),\n        endTime: endTime.toISOString(),\n        durationMinutes: minutes,\n        active: true\n    };\n    \n    saveGamblingSessions(sessions);\n    \n    // Update user security\n    const security = loadSecurityData();\n    const userSec = getUserSecurity(userId);\n    userSec.lastGamblingSession = sessions[userId];\n    security[userId] = userSec;\n    saveSecurityData(security);\n    \n    return endTime;\n}\n\n/**\n * Check if user has active gambling session\n * @param {string} userId - Discord user ID\n * @returns {boolean} True if session is active\n */\nfunction hasActiveGamblingSession(userId) {\n    const sessions = loadGamblingSessions();\n    \n    if (!sessions[userId] || !sessions[userId].active) {\n        return false;\n    }\n    \n    const now = new Date();\n    const endTime = new Date(sessions[userId].endTime);\n    \n    if (now > endTime) {\n        // Session expired\n        sessions[userId].active = false;\n        saveGamblingSessions(sessions);\n        return false;\n    }\n    \n    return true;\n}\n\n/**\n * Add wagered amount for user\n * @param {string} userId - Discord user ID\n * @param {number} amount - Amount wagered\n */\nfunction addWageredAmount(userId, amount) {\n    const security = loadSecurityData();\n    const userSec = getUserSecurity(userId);\n    \n    userSec.wageredAmount += amount;\n    security[userId] = userSec;\n    saveSecurityData(security);\n}\n\n/**\n * Add deposited amount for user\n * @param {string} userId - Discord user ID\n * @param {number} amount - Amount deposited\n */\nfunction addDepositedAmount(userId, amount) {\n    const security = loadSecurityData();\n    const userSec = getUserSecurity(userId);\n    \n    userSec.depositedAmount += amount;\n    // Check if user can cashout (wagered >= deposited)\n    userSec.canCashout = userSec.wageredAmount >= userSec.depositedAmount;\n    \n    security[userId] = userSec;\n    saveSecurityData(security);\n}\n\n/**\n * Clear all active deposits (Admin function)\n * @returns {boolean} Success status\n */\nfunction clearAllActiveDeposits() {\n    try {\n        const emptyDeposits = {};\n        saveActiveDeposits(emptyDeposits);\n        console.log('üóØÔ∏è All active deposits cleared');\n        return true;\n    } catch (error) {\n        console.error('Error clearing active deposits:', error);\n        return false;\n    }\n}\n\n/**\n * Check if user can cashout\n * @param {string} userId - Discord user ID\n * @returns {Object} Cashout status and info\n */\nfunction canUserCashout(userId) {\n    const userSec = getUserSecurity(userId);\n    \n    const wageredPercent = userSec.depositedAmount > 0 ? \n        (userSec.wageredAmount / userSec.depositedAmount) * 100 : 100;\n    \n    return {\n        canCashout: userSec.canCashout,\n        wageredAmount: userSec.wageredAmount,\n        depositedAmount: userSec.depositedAmount,\n        wageredPercent: wageredPercent,\n        remainingToWager: Math.max(0, userSec.depositedAmount - userSec.wageredAmount)\n    };\n}\n\nmodule.exports = {\n    getUserSecurity,\n    setUserPassword,\n    changeUserPassword,\n    verifyUserPassword,\n    resetRecoveryKey,\n    resetPassword,\n    addActiveDeposit,\n    getActiveDeposits,\n    getAllActiveDeposits,\n    completeDepositRequest,\n    clearAllActiveDeposits,\n    startGamblingSession,\n    hasActiveGamblingSession,\n    addWageredAmount,\n    addDepositedAmount,\n    canUserCashout,\n    generateRecoveryKey\n};","size_bytes":13379},"attached_assets/casino/utils/sessionManager.js":{"content":"const { EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle, PermissionFlagsBits } = require('discord.js');\nconst fs = require('fs');\nconst path = require('path');\n\nconst SESSIONS_FILE = path.join(__dirname, '../data/gaming_sessions.json');\n\nclass SessionManager {\n    constructor() {\n        this.activeSessions = new Map();\n        this.loadSessions();\n    }\n\n    loadSessions() {\n        try {\n            if (fs.existsSync(SESSIONS_FILE)) {\n                const data = JSON.parse(fs.readFileSync(SESSIONS_FILE, 'utf8'));\n                // Convert array to Map and check for expired sessions\n                const now = Date.now();\n                data.forEach(session => {\n                    if (session.expiresAt > now) {\n                        this.activeSessions.set(session.id, session);\n                    }\n                });\n                console.log(`‚úÖ Loaded ${this.activeSessions.size} active gaming sessions`);\n            }\n        } catch (error) {\n            console.error('Error loading sessions:', error);\n            this.activeSessions = new Map();\n        }\n    }\n\n    saveSessions() {\n        try {\n            const sessionsArray = Array.from(this.activeSessions.values());\n            fs.writeFileSync(SESSIONS_FILE, JSON.stringify(sessionsArray, null, 2));\n        } catch (error) {\n            console.error('Error saving sessions:', error);\n        }\n    }\n\n    generateSessionId() {\n        return `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    }\n\n    async createPrivateSession(guild, host, sessionType = 'general', options = {}) {\n        const sessionId = this.generateSessionId();\n        const channelName = `üé∞-${host.username}-${sessionType}`.toLowerCase().replace(/[^a-z0-9-]/g, '');\n        \n        try {\n            // Create private channel\n            const channel = await guild.channels.create({\n                name: channelName,\n                type: 0, // Text channel\n                topic: `üé∞ Private Gaming Session | Host: ${host.username} | Type: ${sessionType}`,\n                permissionOverwrites: [\n                    {\n                        id: guild.id,\n                        deny: [PermissionFlagsBits.ViewChannel]\n                    },\n                    {\n                        id: host.id,\n                        allow: [\n                            PermissionFlagsBits.ViewChannel,\n                            PermissionFlagsBits.SendMessages,\n                            PermissionFlagsBits.ReadMessageHistory,\n                            PermissionFlagsBits.ManageMessages\n                        ]\n                    }\n                ]\n            });\n\n            // Create session object\n            const session = {\n                id: sessionId,\n                channelId: channel.id,\n                hostId: host.id,\n                guildId: guild.id,\n                sessionType: sessionType,\n                participants: [host.id],\n                createdAt: Date.now(),\n                expiresAt: Date.now() + (options.duration || 60) * 60 * 1000, // Default 1 hour\n                settings: {\n                    maxParticipants: options.maxParticipants || 10,\n                    isPublic: options.isPublic || false,\n                    allowSpectators: options.allowSpectators || true,\n                    minBet: options.minBet || 0.001,\n                    maxBet: options.maxBet || 1.0\n                },\n                stats: {\n                    totalGames: 0,\n                    totalWagers: 0,\n                    participantCount: 1\n                }\n            };\n\n            this.activeSessions.set(sessionId, session);\n            this.saveSessions();\n\n            // Send welcome message\n            await this.sendSessionWelcome(channel, session, host);\n\n            return { success: true, session, channel };\n\n        } catch (error) {\n            console.error('Error creating private session:', error);\n            return { success: false, error: error.message };\n        }\n    }\n\n    async sendSessionWelcome(channel, session, host) {\n        const welcomeEmbed = new EmbedBuilder()\n            .setColor('#9b59b6')\n            .setTitle('üéâ Private Gaming Session Created!')\n            .setDescription(`Welcome to your exclusive gaming room, ${host}!`)\n            .addFields(\n                {\n                    name: 'üéÆ Session Details',\n                    value: `**Type:** ${session.sessionType.charAt(0).toUpperCase() + session.sessionType.slice(1)}\\n**Host:** ${host.username}\\n**Max Players:** ${session.settings.maxParticipants}\\n**Duration:** ${Math.round((session.expiresAt - session.createdAt) / 60000)} minutes`,\n                    inline: true\n                },\n                {\n                    name: 'üí∞ Betting Limits',\n                    value: `**Minimum:** ${session.settings.minBet} LTC\\n**Maximum:** ${session.settings.maxBet} LTC\\n**Spectators:** ${session.settings.allowSpectators ? 'Allowed' : 'Not Allowed'}`,\n                    inline: true\n                },\n                {\n                    name: 'üéØ Available Games',\n                    value: 'üÉè Blackjack\\nüé∞ Roulette\\nüé≤ Dice Games\\nüéÆ Group Games',\n                    inline: false\n                }\n            )\n            .setThumbnail(host.displayAvatarURL({ dynamic: true }))\n            .setFooter({ text: `Session ID: ${session.id}` })\n            .setTimestamp();\n\n        const controlRow = new ActionRowBuilder()\n            .addComponents(\n                new ButtonBuilder()\n                    .setCustomId(`session_invite_${session.id}`)\n                    .setLabel('üë• Invite Players')\n                    .setStyle(ButtonStyle.Primary)\n                    .setEmoji('üë•'),\n                new ButtonBuilder()\n                    .setCustomId(`session_settings_${session.id}`)\n                    .setLabel('‚öôÔ∏è Settings')\n                    .setStyle(ButtonStyle.Secondary)\n                    .setEmoji('‚öôÔ∏è'),\n                new ButtonBuilder()\n                    .setCustomId(`session_stats_${session.id}`)\n                    .setLabel('üìä Stats')\n                    .setStyle(ButtonStyle.Secondary)\n                    .setEmoji('üìä')\n            );\n\n        const gamesRow = new ActionRowBuilder()\n            .addComponents(\n                new ButtonBuilder()\n                    .setCustomId(`session_blackjack_${session.id}`)\n                    .setLabel('üÉè Blackjack')\n                    .setStyle(ButtonStyle.Success)\n                    .setEmoji('üÉè'),\n                new ButtonBuilder()\n                    .setCustomId(`session_roulette_${session.id}`)\n                    .setLabel('üé∞ Roulette')\n                    .setStyle(ButtonStyle.Success)\n                    .setEmoji('üé∞'),\n                new ButtonBuilder()\n                    .setCustomId(`session_close_${session.id}`)\n                    .setLabel('üö™ Close Session')\n                    .setStyle(ButtonStyle.Danger)\n                    .setEmoji('üö™')\n            );\n\n        await channel.send({\n            embeds: [welcomeEmbed],\n            components: [controlRow, gamesRow]\n        });\n    }\n\n    async addParticipant(sessionId, userId, guild) {\n        const session = this.activeSessions.get(sessionId);\n        if (!session) return { success: false, reason: 'Session not found' };\n\n        if (session.participants.includes(userId)) {\n            return { success: false, reason: 'User already in session' };\n        }\n\n        if (session.participants.length >= session.settings.maxParticipants) {\n            return { success: false, reason: 'Session is full' };\n        }\n\n        try {\n            const channel = guild.channels.cache.get(session.channelId);\n            if (!channel) return { success: false, reason: 'Channel not found' };\n\n            // Add permissions for the new participant\n            await channel.permissionOverwrites.create(userId, {\n                ViewChannel: true,\n                SendMessages: true,\n                ReadMessageHistory: true\n            });\n\n            // Update session\n            session.participants.push(userId);\n            session.stats.participantCount = session.participants.length;\n            this.saveSessions();\n\n            // Announce new participant\n            const user = await guild.members.fetch(userId);\n            const joinEmbed = new EmbedBuilder()\n                .setColor('#2ecc71')\n                .setTitle('üéä New Player Joined!')\n                .setDescription(`${user} has joined the gaming session!`)\n                .addFields({\n                    name: 'üë• Current Players',\n                    value: `${session.participants.length}/${session.settings.maxParticipants}`,\n                    inline: true\n                })\n                .setThumbnail(user.displayAvatarURL({ dynamic: true }))\n                .setTimestamp();\n\n            await channel.send({ embeds: [joinEmbed] });\n\n            return { success: true };\n        } catch (error) {\n            console.error('Error adding participant:', error);\n            return { success: false, reason: error.message };\n        }\n    }\n\n    async removeParticipant(sessionId, userId, guild, removedBy = null) {\n        const session = this.activeSessions.get(sessionId);\n        if (!session) return { success: false, reason: 'Session not found' };\n\n        if (!session.participants.includes(userId)) {\n            return { success: false, reason: 'User not in session' };\n        }\n\n        try {\n            const channel = guild.channels.cache.get(session.channelId);\n            if (!channel) return { success: false, reason: 'Channel not found' };\n\n            // Remove permissions\n            await channel.permissionOverwrites.delete(userId);\n\n            // Update session\n            session.participants = session.participants.filter(id => id !== userId);\n            session.stats.participantCount = session.participants.length;\n\n            // If host left, transfer ownership or close session\n            if (userId === session.hostId) {\n                if (session.participants.length > 0) {\n                    session.hostId = session.participants[0];\n                    const newHost = await guild.members.fetch(session.hostId);\n                    \n                    const transferEmbed = new EmbedBuilder()\n                        .setColor('#f39c12')\n                        .setTitle('üëë Host Transfer')\n                        .setDescription(`${newHost} is now the session host!`)\n                        .setTimestamp();\n\n                    await channel.send({ embeds: [transferEmbed] });\n                } else {\n                    // Close session if no participants left\n                    await this.closeSession(sessionId, guild);\n                    return { success: true, sessionClosed: true };\n                }\n            } else {\n                // Announce participant left\n                const user = await guild.members.fetch(userId);\n                const leaveEmbed = new EmbedBuilder()\n                    .setColor('#e74c3c')\n                    .setTitle('üëã Player Left')\n                    .setDescription(`${user.username} has left the gaming session`)\n                    .addFields({\n                        name: 'üë• Remaining Players',\n                        value: `${session.participants.length}/${session.settings.maxParticipants}`,\n                        inline: true\n                    })\n                    .setTimestamp();\n\n                if (removedBy && removedBy !== userId) {\n                    const remover = await guild.members.fetch(removedBy);\n                    leaveEmbed.setFooter({ text: `Removed by ${remover.username}` });\n                }\n\n                await channel.send({ embeds: [leaveEmbed] });\n            }\n\n            this.saveSessions();\n            return { success: true };\n        } catch (error) {\n            console.error('Error removing participant:', error);\n            return { success: false, reason: error.message };\n        }\n    }\n\n    async closeSession(sessionId, guild) {\n        const session = this.activeSessions.get(sessionId);\n        if (!session) return { success: false, reason: 'Session not found' };\n\n        try {\n            const channel = guild.channels.cache.get(session.channelId);\n            \n            if (channel) {\n                // Send closing message\n                const closeEmbed = new EmbedBuilder()\n                    .setColor('#95a5a6')\n                    .setTitle('üîí Session Ending')\n                    .setDescription('This gaming session is being closed...')\n                    .addFields(\n                        {\n                            name: 'üìä Session Stats',\n                            value: `**Total Games:** ${session.stats.totalGames}\\n**Total Wagers:** ${session.stats.totalWagers.toFixed(8)} LTC\\n**Participants:** ${session.stats.participantCount}`,\n                            inline: true\n                        },\n                        {\n                            name: '‚è∞ Duration',\n                            value: `${Math.round((Date.now() - session.createdAt) / 60000)} minutes`,\n                            inline: true\n                        }\n                    )\n                    .setTimestamp();\n\n                await channel.send({ embeds: [closeEmbed] });\n\n                // Delete channel after 10 seconds\n                setTimeout(async () => {\n                    try {\n                        await channel.delete('Gaming session ended');\n                    } catch (error) {\n                        console.error('Error deleting session channel:', error);\n                    }\n                }, 10000);\n            }\n\n            // Remove from active sessions\n            this.activeSessions.delete(sessionId);\n            this.saveSessions();\n\n            return { success: true };\n        } catch (error) {\n            console.error('Error closing session:', error);\n            return { success: false, reason: error.message };\n        }\n    }\n\n    getSession(sessionId) {\n        return this.activeSessions.get(sessionId);\n    }\n\n    isUserInSession(userId) {\n        for (const session of this.activeSessions.values()) {\n            if (session.participants.includes(userId)) {\n                return session;\n            }\n        }\n        return null;\n    }\n\n    async cleanExpiredSessions(guild) {\n        const now = Date.now();\n        const expiredSessions = [];\n\n        for (const [sessionId, session] of this.activeSessions) {\n            if (session.expiresAt <= now) {\n                expiredSessions.push(sessionId);\n            }\n        }\n\n        for (const sessionId of expiredSessions) {\n            await this.closeSession(sessionId, guild);\n            console.log(`üßπ Cleaned expired session: ${sessionId}`);\n        }\n\n        return expiredSessions.length;\n    }\n}\n\nmodule.exports = new SessionManager();","size_bytes":15054},"attached_assets/casino/utils/ticketManager.js":{"content":"/**\n * Ticket Manager for Casino Bot\n * Handles creation and management of private ticket channels\n */\n\nconst fs = require('fs');\nconst TICKETS_FILE = './data/tickets.json';\n\n/**\n * Get default tickets data\n */\nfunction getDefaultData() {\n    return {\n        activeTickets: {},\n        ticketCounter: 0\n    };\n}\n\n/**\n * Load tickets data\n */\nfunction loadTickets() {\n    try {\n        if (!fs.existsSync('./data')) {\n            fs.mkdirSync('./data', { recursive: true });\n        }\n        \n        if (fs.existsSync(TICKETS_FILE)) {\n            const data = fs.readFileSync(TICKETS_FILE, 'utf8');\n            return JSON.parse(data);\n        }\n    } catch (error) {\n        console.error('Erreur lors du chargement des tickets:', error);\n    }\n    \n    return getDefaultData();\n}\n\n/**\n * Save tickets data\n */\nfunction saveTickets(data) {\n    try {\n        if (!fs.existsSync('./data')) {\n            fs.mkdirSync('./data', { recursive: true });\n        }\n        \n        fs.writeFileSync(TICKETS_FILE, JSON.stringify(data, null, 2));\n        return true;\n    } catch (error) {\n        console.error('Erreur lors de la sauvegarde des tickets:', error);\n        return false;\n    }\n}\n\n/**\n * Create a private ticket channel for user\n */\nasync function createTicket(guild, user, categoryId, staffRoleId, ticketType = 'general') {\n    try {\n        const data = loadTickets();\n        \n        // Check if user already has an active ticket\n        const existingTicket = Object.values(data.activeTickets).find(ticket => \n            ticket.userId === user.id && ticket.type === ticketType\n        );\n        \n        if (existingTicket) {\n            try {\n                const existingChannel = guild.channels.cache.get(existingTicket.channelId);\n                if (existingChannel) {\n                    return { \n                        success: false, \n                        error: 'existing',\n                        channel: existingChannel \n                    };\n                } else {\n                    // Channel doesn't exist anymore, remove from data\n                    delete data.activeTickets[existingTicket.ticketId];\n                    saveTickets(data);\n                }\n            } catch (error) {\n                console.log('Erreur v√©rification channel existant:', error);\n            }\n        }\n        \n        // Increment counter and create ticket ID\n        data.ticketCounter++;\n        const ticketId = `ticket-${data.ticketCounter}`;\n        \n        // Determine ticket name based on type\n        const ticketNames = {\n            'balance': 'üí∞-balance',\n            'profile': 'üë§-profile', \n            'general': 'üé´-casino'\n        };\n        \n        const channelName = `${ticketNames[ticketType] || 'üé´-casino'}-${user.username}`.toLowerCase();\n        \n        // Set up permissions\n        const permissionOverwrites = [\n            {\n                id: guild.id, // @everyone\n                deny: ['ViewChannel', 'SendMessages', 'ReadMessageHistory']\n            },\n            {\n                id: user.id,\n                allow: ['ViewChannel', 'SendMessages', 'ReadMessageHistory', 'AttachFiles', 'EmbedLinks']\n            }\n        ];\n        \n        // Add staff role permissions if provided\n        if (staffRoleId) {\n            permissionOverwrites.push({\n                id: staffRoleId,\n                allow: ['ViewChannel', 'SendMessages', 'ReadMessageHistory', 'AttachFiles', 'EmbedLinks', 'ManageMessages']\n            });\n        }\n        \n        // Create the channel\n        const channel = await guild.channels.create({\n            name: channelName,\n            type: 0, // Text channel\n            topic: `Private ${ticketType} session for ${user.username} ‚Ä¢ Ticket ID: ${ticketId}`,\n            parent: categoryId,\n            permissionOverwrites: permissionOverwrites\n        });\n        \n        // Save ticket data\n        data.activeTickets[ticketId] = {\n            ticketId,\n            channelId: channel.id,\n            userId: user.id,\n            username: user.username,\n            type: ticketType,\n            createdAt: Date.now(),\n            staffRoleId\n        };\n        \n        saveTickets(data);\n        \n        return {\n            success: true,\n            channel,\n            ticketId\n        };\n        \n    } catch (error) {\n        console.error('Erreur cr√©ation ticket:', error);\n        return {\n            success: false,\n            error: 'create_failed'\n        };\n    }\n}\n\n/**\n * Close a ticket channel\n */\nasync function closeTicket(ticketId, guild) {\n    try {\n        const data = loadTickets();\n        const ticket = data.activeTickets[ticketId];\n        \n        if (!ticket) {\n            return { success: false, error: 'not_found' };\n        }\n        \n        // Try to delete the channel\n        try {\n            const channel = guild.channels.cache.get(ticket.channelId);\n            if (channel) {\n                await channel.delete();\n            }\n        } catch (error) {\n            console.log('Erreur suppression channel:', error);\n        }\n        \n        // Remove from data\n        delete data.activeTickets[ticketId];\n        saveTickets(data);\n        \n        return { success: true };\n        \n    } catch (error) {\n        console.error('Erreur fermeture ticket:', error);\n        return { success: false, error: 'close_failed' };\n    }\n}\n\n/**\n * Get ticket by channel ID\n */\nfunction getTicketByChannel(channelId) {\n    const data = loadTickets();\n    return Object.values(data.activeTickets).find(ticket => \n        ticket.channelId === channelId\n    );\n}\n\n/**\n * Get ticket by user ID and type\n */\nfunction getTicketByUser(userId, ticketType = null) {\n    const data = loadTickets();\n    return Object.values(data.activeTickets).find(ticket => \n        ticket.userId === userId && (ticketType ? ticket.type === ticketType : true)\n    );\n}\n\n/**\n * Get all active tickets\n */\nfunction getAllTickets() {\n    const data = loadTickets();\n    return data.activeTickets;\n}\n\n/**\n * Clean up old/invalid tickets\n */\nasync function cleanupTickets(guild) {\n    try {\n        const data = loadTickets();\n        let cleanedCount = 0;\n        \n        for (const [ticketId, ticket] of Object.entries(data.activeTickets)) {\n            try {\n                const channel = guild.channels.cache.get(ticket.channelId);\n                if (!channel) {\n                    // Channel doesn't exist, remove ticket\n                    delete data.activeTickets[ticketId];\n                    cleanedCount++;\n                }\n            } catch (error) {\n                // Error checking channel, remove ticket\n                delete data.activeTickets[ticketId];\n                cleanedCount++;\n            }\n        }\n        \n        if (cleanedCount > 0) {\n            saveTickets(data);\n            console.log(`üßπ Nettoy√© ${cleanedCount} ticket(s) invalide(s)`);\n        }\n        \n        return cleanedCount;\n        \n    } catch (error) {\n        console.error('Erreur nettoyage tickets:', error);\n        return 0;\n    }\n}\n\nmodule.exports = {\n    createTicket,\n    closeTicket,\n    getTicketByChannel,\n    getTicketByUser,\n    getAllTickets,\n    cleanupTickets\n};","size_bytes":7231},"attached_assets/casino/utils/treasuryManager.js":{"content":"const fs = require('fs');\nconst path = require('path');\nconst ltcWallet = require('../litecoin-casino-bot.js');\n\nconst TREASURY_FILE = path.join(__dirname, '../data/treasury.json');\nconst TREASURY_ADDRESS = 'LTC_TREASURY_ADDRESS_PLACEHOLDER'; // This should be a real LTC address\n\nclass TreasuryManager {\n    constructor() {\n        this.treasuryData = this.loadTreasuryData();\n    }\n\n    loadTreasuryData() {\n        try {\n            if (fs.existsSync(TREASURY_FILE)) {\n                return JSON.parse(fs.readFileSync(TREASURY_FILE, 'utf8'));\n            }\n        } catch (error) {\n            console.error('Error loading treasury data:', error);\n        }\n        \n        return {\n            address: TREASURY_ADDRESS,\n            totalCollected: 0,\n            totalPaidOut: 0,\n            currentBalance: 0,\n            transactions: [],\n            lastUpdated: Date.now()\n        };\n    }\n\n    saveTreasuryData() {\n        try {\n            fs.writeFileSync(TREASURY_FILE, JSON.stringify(this.treasuryData, null, 2));\n            console.log('‚úÖ Treasury data saved');\n        } catch (error) {\n            console.error('Error saving treasury data:', error);\n        }\n    }\n\n    /**\n     * Get current treasury balance (estimated)\n     * This should ideally query the blockchain for the real balance\n     */\n    getCurrentBalance() {\n        return this.treasuryData.currentBalance;\n    }\n\n    /**\n     * Calculate maximum bet allowed (30% of treasury balance)\n     */\n    getMaxBetLimit() {\n        const balance = this.getCurrentBalance();\n        return balance * 0.30; // 30% limit\n    }\n\n    /**\n     * Record a house win (money collected from players)\n     */\n    recordHouseWin(amount, userId, gameType, details = {}) {\n        const transaction = {\n            type: 'house_win',\n            amount: amount,\n            userId: userId,\n            gameType: gameType,\n            details: details,\n            timestamp: Date.now(),\n            id: `win_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`\n        };\n\n        this.treasuryData.transactions.push(transaction);\n        this.treasuryData.totalCollected += amount;\n        this.treasuryData.currentBalance += amount;\n        this.treasuryData.lastUpdated = Date.now();\n\n        this.saveTreasuryData();\n\n        console.log(`üè† House win recorded: ${amount.toFixed(8)} LTC from ${userId} in ${gameType}`);\n        return transaction;\n    }\n\n    /**\n     * Record a payout to a winner\n     */\n    recordPayout(amount, userId, gameType, details = {}) {\n        const transaction = {\n            type: 'payout',\n            amount: amount,\n            userId: userId,\n            gameType: gameType,\n            details: details,\n            timestamp: Date.now(),\n            id: `payout_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`\n        };\n\n        this.treasuryData.transactions.push(transaction);\n        this.treasuryData.totalPaidOut += amount;\n        this.treasuryData.currentBalance -= amount;\n        this.treasuryData.lastUpdated = Date.now();\n\n        this.saveTreasuryData();\n\n        console.log(`üí∞ Payout recorded: ${amount.toFixed(8)} LTC to ${userId} from ${gameType}`);\n        return transaction;\n    }\n\n    /**\n     * Check if a bet amount is within limits\n     */\n    isBetAllowed(betAmount) {\n        const maxBet = this.getMaxBetLimit();\n        return betAmount <= maxBet;\n    }\n\n    /**\n     * Get treasury statistics\n     */\n    getStats() {\n        return {\n            address: this.treasuryData.address,\n            currentBalance: this.treasuryData.currentBalance,\n            totalCollected: this.treasuryData.totalCollected,\n            totalPaidOut: this.treasuryData.totalPaidOut,\n            netProfit: this.treasuryData.totalCollected - this.treasuryData.totalPaidOut,\n            maxBetLimit: this.getMaxBetLimit(),\n            transactionCount: this.treasuryData.transactions.length,\n            lastUpdated: this.treasuryData.lastUpdated\n        };\n    }\n\n    /**\n     * Get recent transactions\n     */\n    getRecentTransactions(limit = 10) {\n        return this.treasuryData.transactions\n            .sort((a, b) => b.timestamp - a.timestamp)\n            .slice(0, limit);\n    }\n\n    /**\n     * Manual balance adjustment (owner only)\n     */\n    adjustBalance(amount, reason, adminUserId) {\n        const transaction = {\n            type: 'manual_adjustment',\n            amount: amount,\n            reason: reason,\n            adminUserId: adminUserId,\n            timestamp: Date.now(),\n            id: `adj_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`\n        };\n\n        this.treasuryData.transactions.push(transaction);\n        this.treasuryData.currentBalance += amount;\n        this.treasuryData.lastUpdated = Date.now();\n\n        this.saveTreasuryData();\n\n        console.log(`‚öñÔ∏è Manual balance adjustment: ${amount.toFixed(8)} LTC by ${adminUserId} - ${reason}`);\n        return transaction;\n    }\n}\n\nmodule.exports = new TreasuryManager();","size_bytes":5017},"attached_assets/casino/utils/userProfiles.js":{"content":"const fs = require('fs');\nconst path = require('path');\n\nconst PROFILES_FILE = path.join(__dirname, '../data/user_profiles.json');\nconst ADDRESS_MAPPING_FILE = path.join(__dirname, '../data/address_mapping.json');\n\n// Ensure data directory exists\nconst dataDir = path.join(__dirname, '../data');\nif (!fs.existsSync(dataDir)) {\n    fs.mkdirSync(dataDir, { recursive: true });\n}\n\n/**\n * Load user profiles from JSON file\n * @returns {Object} User profiles object\n */\nfunction loadProfiles() {\n    try {\n        if (fs.existsSync(PROFILES_FILE)) {\n            const data = fs.readFileSync(PROFILES_FILE, 'utf8');\n            return JSON.parse(data);\n        }\n    } catch (error) {\n        console.error('Error loading user profiles:', error.message);\n    }\n    return {};\n}\n\n/**\n * Save user profiles to JSON file\n * @param {Object} profiles - User profiles to save\n */\nfunction saveProfiles(profiles) {\n    try {\n        fs.writeFileSync(PROFILES_FILE, JSON.stringify(profiles, null, 2));\n        console.log('‚úÖ User profiles saved');\n    } catch (error) {\n        console.error('Error saving user profiles:', error.message);\n    }\n}\n\n/**\n * Load address mapping from JSON file\n * @returns {Object} Address mapping object\n */\nfunction loadAddressMapping() {\n    try {\n        if (fs.existsSync(ADDRESS_MAPPING_FILE)) {\n            const data = fs.readFileSync(ADDRESS_MAPPING_FILE, 'utf8');\n            return JSON.parse(data);\n        }\n    } catch (error) {\n        console.error('Error loading address mapping:', error.message);\n    }\n    return {};\n}\n\n/**\n * Save address mapping to JSON file\n * @param {Object} mapping - Address mapping to save\n */\nfunction saveAddressMapping(mapping) {\n    try {\n        fs.writeFileSync(ADDRESS_MAPPING_FILE, JSON.stringify(mapping, null, 2));\n        console.log('‚úÖ Address mapping saved');\n    } catch (error) {\n        console.error('Error saving address mapping:', error.message);\n    }\n}\n\n/**\n * Get or create user profile\n * @param {string} userId - Discord user ID\n * @returns {Object} User profile\n */\nfunction getUserProfile(userId) {\n    const profiles = loadProfiles();\n    \n    if (!profiles[userId]) {\n        profiles[userId] = {\n            userId: userId,\n            balance: 0,\n            totalDeposited: 0,\n            totalWithdrawn: 0,\n            depositHistory: [],\n            withdrawalHistory: [],\n            gameHistory: [],\n            addresses: [],\n            createdAt: new Date().toISOString(),\n            lastActivity: new Date().toISOString()\n        };\n        saveProfiles(profiles);\n    }\n    \n    return profiles[userId];\n}\n\n/**\n * Update user profile\n * @param {string} userId - Discord user ID\n * @param {Object} updates - Updates to apply to profile\n */\nfunction updateUserProfile(userId, updates) {\n    const profiles = loadProfiles();\n    \n    if (!profiles[userId]) {\n        profiles[userId] = getUserProfile(userId);\n    }\n    \n    // Merge updates\n    profiles[userId] = { ...profiles[userId], ...updates };\n    profiles[userId].lastActivity = new Date().toISOString();\n    \n    saveProfiles(profiles);\n    return profiles[userId];\n}\n\n/**\n * Add deposit to user profile\n * @param {string} userId - Discord user ID\n * @param {number} amount - Deposit amount in LTC\n * @param {string} address - Deposit address\n * @param {string} txid - Transaction ID\n */\nfunction addDeposit(userId, amount, address, txid = null) {\n    const profile = getUserProfile(userId);\n    \n    const deposit = {\n        amount: amount,\n        address: address,\n        txid: txid,\n        timestamp: new Date().toISOString(),\n        confirmed: txid !== null\n    };\n    \n    profile.depositHistory.push(deposit);\n    profile.balance += amount;\n    profile.totalDeposited += amount;\n    \n    updateUserProfile(userId, profile);\n    \n    console.log(`üí∞ Added deposit: ${amount} LTC for user ${userId}`);\n    return deposit;\n}\n\n/**\n * Add withdrawal to user profile\n * @param {string} userId - Discord user ID\n * @param {number} amount - Withdrawal amount in LTC\n * @param {string} toAddress - Destination address\n * @param {string} txid - Transaction ID\n */\nfunction addWithdrawal(userId, amount, toAddress, txid) {\n    const profile = getUserProfile(userId);\n    \n    if (profile.balance < amount) {\n        throw new Error('Insufficient balance');\n    }\n    \n    const withdrawal = {\n        amount: amount,\n        toAddress: toAddress,\n        txid: txid,\n        timestamp: new Date().toISOString()\n    };\n    \n    profile.withdrawalHistory.push(withdrawal);\n    profile.balance -= amount;\n    profile.totalWithdrawn += amount;\n    \n    updateUserProfile(userId, profile);\n    \n    console.log(`üí∏ Added withdrawal: ${amount} LTC for user ${userId}`);\n    return withdrawal;\n}\n\n/**\n * Transfer balance between users\n * @param {string} fromUserId - Sender user ID\n * @param {string} toUserId - Receiver user ID\n * @param {number} amount - Amount to transfer\n */\nfunction transferBalance(fromUserId, toUserId, amount) {\n    const fromProfile = getUserProfile(fromUserId);\n    const toProfile = getUserProfile(toUserId);\n    \n    if (fromProfile.balance < amount) {\n        throw new Error('Insufficient balance');\n    }\n    \n    fromProfile.balance -= amount;\n    toProfile.balance += amount;\n    \n    const transfer = {\n        amount: amount,\n        from: fromUserId,\n        to: toUserId,\n        timestamp: new Date().toISOString(),\n        type: 'transfer'\n    };\n    \n    // Add to both users' histories\n    fromProfile.gameHistory.push({ ...transfer, action: 'sent' });\n    toProfile.gameHistory.push({ ...transfer, action: 'received' });\n    \n    updateUserProfile(fromUserId, fromProfile);\n    updateUserProfile(toUserId, toProfile);\n    \n    console.log(`üîÑ Transfer: ${amount} LTC from ${fromUserId} to ${toUserId}`);\n    return transfer;\n}\n\n/**\n * Link a Litecoin address to a Discord user\n * @param {string} userId - Discord user ID\n * @param {string} address - Litecoin address\n */\nfunction linkAddressToUser(userId, address) {\n    const mapping = loadAddressMapping();\n    const profile = getUserProfile(userId);\n    \n    mapping[address] = userId;\n    profile.addresses.push(address);\n    \n    saveAddressMapping(mapping);\n    updateUserProfile(userId, profile);\n    \n    console.log(`üîó Linked address ${address} to user ${userId}`);\n}\n\n/**\n * Get user ID from Litecoin address\n * @param {string} address - Litecoin address\n * @returns {string|null} Discord user ID or null if not found\n */\nfunction getUserFromAddress(address) {\n    const mapping = loadAddressMapping();\n    return mapping[address] || null;\n}\n\n/**\n * Get all user profiles\n * @returns {Object} All user profiles\n */\nfunction getAllProfiles() {\n    return loadProfiles();\n}\n\n/**\n * Get leaderboard data\n * @param {string} type - 'balance', 'deposited', 'withdrawn'\n * @param {number} limit - Number of users to return\n * @returns {Array} Sorted user data\n */\nfunction getLeaderboard(type = 'balance', limit = 10) {\n    const profiles = loadProfiles();\n    const users = Object.values(profiles);\n    \n    let sortKey;\n    switch (type) {\n        case 'deposited':\n            sortKey = 'totalDeposited';\n            break;\n        case 'withdrawn':\n            sortKey = 'totalWithdrawn';\n            break;\n        default:\n            sortKey = 'balance';\n    }\n    \n    return users\n        .sort((a, b) => b[sortKey] - a[sortKey])\n        .slice(0, limit)\n        .map(user => ({\n            userId: user.userId,\n            value: user[sortKey],\n            balance: user.balance\n        }));\n}\n\n/**\n * Reset user security (password and recovery key) - Admin function\n * @param {string} userId - Discord user ID\n * @returns {Object} Result with success status and new recovery key\n */\nfunction resetUserSecurity(userId) {\n    try {\n        const securityManager = require('./securityManager.js');\n        const profiles = loadProfiles();\n        \n        if (!profiles[userId]) {\n            return { success: false, error: 'User profile not found' };\n        }\n        \n        // Generate new recovery key using securityManager\n        const newRecoveryKey = securityManager.generateRecoveryKey();\n        \n        // Reset password to null (forces user to create new one)\n        const resetResult = securityManager.resetPassword(userId, newRecoveryKey);\n        \n        if (resetResult.success) {\n            console.log(`üîê Admin reset security for user ${userId}`);\n            \n            return {\n                success: true,\n                newRecoveryKey: newRecoveryKey\n            };\n        } else {\n            return { success: false, error: 'Security reset failed' };\n        }\n        \n    } catch (error) {\n        console.error('Error resetting user security:', error);\n        return { success: false, error: 'Reset failed' };\n    }\n}\n\nmodule.exports = {\n    getUserProfile,\n    updateUserProfile,\n    addDeposit,\n    addWithdrawal,\n    transferBalance,\n    linkAddressToUser,\n    getUserFromAddress,\n    getAllProfiles,\n    getLeaderboard,\n    loadProfiles,\n    saveProfiles,\n    resetUserSecurity\n};","size_bytes":9095},"commands/addwhitelist.js":{"content":"const { SlashCommandBuilder, EmbedBuilder, PermissionFlagsBits } = require('discord.js');\nconst panelManager = require('../utils/panelManager.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('addwhitelist')\n        .setDescription('Add this server to panel management whitelist (Bot Owner only)')\n        .addRoleOption(option =>\n            option.setName('admin_role')\n                .setDescription('Role that can manage panels (optional)')\n                .setRequired(false)\n        ),\n    \n    async execute(interaction) {\n        // Check if interaction is too old\n        const interactionAge = Date.now() - interaction.createdTimestamp;\n        if (interactionAge > 10 * 60 * 1000) {\n            console.log('Interaction too old, ignored');\n            return;\n        }\n        \n        // Check if user is bot owner (you can change this logic)\n        const botOwnerIds = ['1409315903937449994']; // Add your user ID here\n        \n        if (!botOwnerIds.includes(interaction.user.id)) {\n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Access Denied')\n                .setDescription('Only the bot owner can manage the whitelist.')\n                .setTimestamp();\n            \n            await interaction.reply({ embeds: [errorEmbed], ephemeral: true });\n            return;\n        }\n        \n        await interaction.deferReply({ ephemeral: true });\n        \n        try {\n            const adminRole = interaction.options.getRole('admin_role');\n            const serverId = interaction.guild.id;\n            \n            // Add to whitelist\n            const success = panelManager.addToWhitelist(serverId, adminRole?.id);\n            \n            if (success) {\n                const successEmbed = new EmbedBuilder()\n                    .setColor('#00ff00')\n                    .setTitle('‚úÖ Server Whitelisted')\n                    .setDescription(`Server **${interaction.guild.name}** has been added to the whitelist.`)\n                    .addFields(\n                        {\n                            name: 'üèõÔ∏è Server',\n                            value: interaction.guild.name,\n                            inline: true\n                        },\n                        {\n                            name: 'üëë Admin Role',\n                            value: adminRole ? adminRole.name : 'None (all members can manage)',\n                            inline: true\n                        },\n                        {\n                            name: 'üìã Available Commands',\n                            value: '‚Ä¢ `/setpanel` - Configure casino panels\\n‚Ä¢ `/stopallactives` - Stop active deposits',\n                            inline: false\n                        }\n                    )\n                    .setFooter({ text: `Server ID: ${serverId}` })\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [successEmbed] });\n                \n                console.log(`‚úÖ Serveur ${interaction.guild.name} ajout√© √† la whitelist par ${interaction.user.username}`);\n                \n            } else {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Whitelist Failed')\n                    .setDescription('Failed to add server to whitelist.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n            }\n            \n        } catch (error) {\n            console.error('Erreur addwhitelist:', error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Error')\n                .setDescription('An error occurred while adding server to whitelist.')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};","size_bytes":4021},"commands/admintransfer.js":{"content":"const { SlashCommandBuilder, EmbedBuilder } = require('discord.js');\nconst userProfiles = require('../utils/userProfiles.js');\nconst { formatLTC } = require('../utils/formatters.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('admintransfer')\n        .setDescription('[ADMIN] Transfer balance between any users')\n        .addUserOption(option =>\n            option.setName('from')\n                .setDescription('User to transfer balance from')\n                .setRequired(true)\n        )\n        .addUserOption(option =>\n            option.setName('to')\n                .setDescription('User to transfer balance to')\n                .setRequired(true)\n        )\n        .addNumberOption(option =>\n            option.setName('amount')\n                .setDescription('Amount to transfer (in LTC)')\n                .setRequired(true)\n                .setMinValue(0.00000001)\n        ),\n    \n    async execute(interaction) {\n        await interaction.deferReply();\n        \n        try {\n            // Check if user is the bot owner\n            const ownerId = process.env.OWNER_ID;\n            \n            if (!ownerId || interaction.user.id !== ownerId) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Access Denied')\n                    .setDescription('Only the bot owner can perform admin transfers.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n\n            const fromUser = interaction.options.getUser('from');\n            const toUser = interaction.options.getUser('to');\n            const amount = interaction.options.getNumber('amount');\n            const fromUserId = fromUser.id;\n            const toUserId = toUser.id;\n            \n            // Validation checks\n            if (fromUserId === toUserId) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Invalid Transfer')\n                    .setDescription('Cannot transfer balance to the same user!')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            if (amount <= 0) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Invalid Amount')\n                    .setDescription('Amount must be greater than 0!')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Check sender's balance\n            const senderProfile = userProfiles.getUserProfile(fromUserId);\n            \n            if (senderProfile.balance < amount) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Insufficient Balance')\n                    .setDescription(`${fromUser.username} doesn't have enough balance!\\n\\n**Current Balance:** ${formatLTC(senderProfile.balance)} LTC\\n**Required:** ${formatLTC(amount)} LTC`)\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Perform the admin transfer\n            const transfer = userProfiles.transferBalance(fromUserId, toUserId, amount);\n            \n            // Get updated profiles\n            const updatedSenderProfile = userProfiles.getUserProfile(fromUserId);\n            const updatedReceiverProfile = userProfiles.getUserProfile(toUserId);\n            \n            const successEmbed = new EmbedBuilder()\n                .setColor('#ff6600')\n                .setTitle('‚úÖ Admin Transfer Successful')\n                .setDescription(`Successfully transferred **${formatLTC(amount)} LTC** from ${fromUser} to ${toUser}`)\n                .addFields(\n                    {\n                        name: 'üë§ From',\n                        value: `${fromUser.username}\\n**New Balance:** ${formatLTC(updatedSenderProfile.balance)} LTC`,\n                        inline: true\n                    },\n                    {\n                        name: 'üë§ To',\n                        value: `${toUser.username}\\n**New Balance:** ${formatLTC(updatedReceiverProfile.balance)} LTC`,\n                        inline: true\n                    },\n                    {\n                        name: 'üõ°Ô∏è Admin Details',\n                        value: `**Executed by:** ${interaction.user.username}\\n**Amount:** ${formatLTC(amount)} LTC\\n**Date:** ${new Date(transfer.timestamp).toLocaleString()}\\n**ID:** ${transfer.timestamp}`,\n                        inline: false\n                    }\n                )\n                .setThumbnail('https://cryptologos.cc/logos/litecoin-ltc-logo.png')\n                .setFooter({ text: 'Admin Transfer - Owner Command' })\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [successEmbed] });\n            \n            // Try to notify both users\n            try {\n                // Notify the sender\n                const senderDM = await fromUser.createDM();\n                const senderNotification = new EmbedBuilder()\n                    .setColor('#ff6600')\n                    .setTitle('‚ö†Ô∏è Admin Transfer Notice')\n                    .setDescription(`An admin has transferred **${formatLTC(amount)} LTC** from your account to ${toUser.username}`)\n                    .addFields({\n                        name: 'üí≥ Your New Balance',\n                        value: `${formatLTC(updatedSenderProfile.balance)} LTC`,\n                        inline: true\n                    })\n                    .setThumbnail('https://cryptologos.cc/logos/litecoin-ltc-logo.png')\n                    .setTimestamp();\n                \n                await senderDM.send({ embeds: [senderNotification] });\n            } catch (dmError) {\n                console.log('Could not send DM to sender:', dmError.message);\n            }\n\n            try {\n                // Notify the receiver\n                const receiverDM = await toUser.createDM();\n                const receiverNotification = new EmbedBuilder()\n                    .setColor('#00ff00')\n                    .setTitle('üí∞ Admin Transfer Received')\n                    .setDescription(`You received **${formatLTC(amount)} LTC** via admin transfer from ${fromUser.username}`)\n                    .addFields({\n                        name: 'üí≥ Your New Balance',\n                        value: `${formatLTC(updatedReceiverProfile.balance)} LTC`,\n                        inline: true\n                    })\n                    .setThumbnail('https://cryptologos.cc/logos/litecoin-ltc-logo.png')\n                    .setTimestamp();\n                \n                await receiverDM.send({ embeds: [receiverNotification] });\n            } catch (dmError) {\n                console.log('Could not send DM to receiver:', dmError.message);\n            }\n            \n        } catch (error) {\n            console.error('Admin transfer command error:', error);\n            \n            let errorMessage = 'Failed to process admin transfer. Please try again.';\n            \n            if (error.message === 'Insufficient balance') {\n                errorMessage = 'Insufficient balance for this transfer.';\n            }\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Admin Transfer Failed')\n                .setDescription(errorMessage)\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};","size_bytes":7974},"commands/balance.js":{"content":"const { SlashCommandBuilder, EmbedBuilder } = require('discord.js');\nconst userProfiles = require('../utils/userProfiles.js');\nconst currencyConverter = require('../utils/currencyConverter.js');\nconst { formatLTC, formatUSD } = require('../utils/formatters.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('balance')\n        .setDescription('Check your current balance')\n        .addUserOption(option =>\n            option.setName('user')\n                .setDescription('User to check balance for (optional)')\n                .setRequired(false)\n        ),\n    \n    async execute(interaction) {\n        // Check if interaction is too old\n        const interactionAge = Date.now() - interaction.createdTimestamp;\n        if (interactionAge > 10 * 60 * 1000) {\n            console.log('Interaction too old, ignored');\n            return;\n        }\n        \n        await interaction.deferReply();\n        \n        try {\n            const targetUser = interaction.options.getUser('user') || interaction.user;\n            const profile = userProfiles.getUserProfile(targetUser.id);\n            \n            // Get LTC price for USD conversion\n            let ltcPrice = null;\n            let eurPrice = null;\n            \n            try {\n                const [usdData, eurData] = await Promise.all([\n                    currencyConverter.getLitecoinPrice('USD'),\n                    currencyConverter.getLitecoinPrice('EUR')\n                ]);\n                ltcPrice = usdData.price;\n                eurPrice = eurData.price;\n            } catch (error) {\n                console.log('Could not fetch crypto prices:', error.message);\n            }\n            \n            const balanceEmbed = new EmbedBuilder()\n                .setColor('#f7931a')\n                .setTitle('üí∞ Balance Information')\n                .setAuthor({ \n                    name: targetUser.username, \n                    iconURL: targetUser.displayAvatarURL() \n                })\n                .addFields({\n                    name: 'ü™ô Litecoin Balance',\n                    value: `**${formatLTC(profile.balance)} LTC**`,\n                    inline: false\n                })\n                .setThumbnail('https://cryptologos.cc/logos/litecoin-ltc-logo.png')\n                .setTimestamp();\n            \n            // Add USD and EUR conversions if available\n            if (ltcPrice && eurPrice) {\n                const usdValue = profile.balance * ltcPrice;\n                const eurValue = profile.balance * eurPrice;\n                \n                balanceEmbed.addFields(\n                    {\n                        name: 'üíµ USD Equivalent',\n                        value: `$${formatUSD(usdValue)}`,\n                        inline: true\n                    },\n                    {\n                        name: 'üí∂ EUR Equivalent',\n                        value: `‚Ç¨${formatUSD(eurValue)}`,\n                        inline: true\n                    }\n                );\n            }\n            \n            // Add quick stats\n            if (profile.depositHistory.length > 0 || profile.withdrawalHistory.length > 0) {\n                balanceEmbed.addFields({\n                    name: 'üìä Quick Stats',\n                    value: `**Total Deposited:** ${formatLTC(profile.totalDeposited)} LTC\\n**Total Withdrawn:** ${formatLTC(profile.totalWithdrawn)} LTC\\n**Net Gain/Loss:** ${formatLTC(profile.totalDeposited - profile.totalWithdrawn - profile.balance)} LTC`,\n                    inline: false\n                });\n            }\n            \n            // Check if viewing someone else's balance\n            if (targetUser.id !== interaction.user.id) {\n                balanceEmbed.setFooter({ text: `Balance requested by ${interaction.user.username}` });\n            }\n            \n            await interaction.editReply({ embeds: [balanceEmbed] });\n            \n        } catch (error) {\n            console.error('Balance command error:', error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Error')\n                .setDescription('Failed to fetch balance information. Please try again.')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};","size_bytes":4354},"commands/blackjack.js":{"content":"const { SlashCommandBuilder, EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle } = require('discord.js');\nconst userProfiles = require('../utils/userProfiles.js');\nconst securityManager = require('../utils/securityManager.js');\nconst logManager = require('../utils/logManager.js');\nconst { formatLTC } = require('../utils/formatters.js');\n\n// Card deck\nconst suits = ['‚ô†Ô∏è', '‚ô•Ô∏è', '‚ô¶Ô∏è', '‚ô£Ô∏è'];\nconst ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];\n\n// Active games storage\nconst activeGames = new Map();\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('blackjack')\n        .setDescription('Play Blackjack against the dealer')\n        .addNumberOption(option =>\n            option.setName('bet')\n                .setDescription('Amount to bet in LTC')\n                .setRequired(true)\n                .setMinValue(0.001)\n        ),\n    \n    async execute(interaction) {\n        // Check if interaction is too old\n        const interactionAge = Date.now() - interaction.createdTimestamp;\n        if (interactionAge > 10 * 60 * 1000) {\n            console.log('Interaction too old, ignored');\n            return;\n        }\n        \n        await interaction.deferReply({ ephemeral: false });\n        \n        try {\n            const bet = interaction.options.getNumber('bet');\n            const userId = interaction.user.id;\n            \n            // Check if user has active game\n            if (activeGames.has(userId)) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Game Already Active')\n                    .setDescription('You already have an active blackjack game. Finish it first!')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Get user profile and verify balance\n            const profile = userProfiles.getUserProfile(userId);\n            \n            if (profile.balance < bet) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Insufficient Balance')\n                    .setDescription(`You need **${formatLTC(bet)} LTC** to play but only have **${formatLTC(profile.balance)} LTC**.`)\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Check password protection\n            const userSec = securityManager.getUserSecurity(userId);\n            if (!userSec.hasPassword) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ffaa00')\n                    .setTitle('üîí Password Required')\n                    .setDescription('You need to set a password before gambling. Use `/setpassword` first.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Deduct bet from balance\n            userProfiles.updateUserProfile(userId, { \n                balance: profile.balance - bet \n            });\n            \n            // Add wagered amount\n            securityManager.addWageredAmount(userId, bet);\n            \n            // Create new game\n            const game = createNewGame(bet, userId);\n            activeGames.set(userId, game);\n            \n            // Show card dealing animation\n            await showCardDealingAnimation(interaction, game);\n            \n            // Auto-timeout after 2 minutes\n            setTimeout(() => {\n                if (activeGames.has(userId)) {\n                    const timeoutGame = activeGames.get(userId);\n                    if (timeoutGame.status === 'playing') {\n                        timeoutGame.status = 'timeout';\n                        activeGames.delete(userId);\n                        console.log(`üïê Blackjack game timed out for ${interaction.user.username}`);\n                    }\n                }\n            }, 120000); // 2 minutes\n            \n        } catch (error) {\n            console.error('Erreur blackjack:', error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Error')\n                .setDescription('An error occurred while starting the blackjack game.')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};\n\nfunction createNewGame(bet, userId) {\n    return {\n        userId: userId,\n        bet: bet,\n        deck: createDeck(),\n        playerHand: [],\n        dealerHand: [],\n        playerValue: 0,\n        dealerValue: 0,\n        status: 'playing', // playing, won, lost, push, timeout\n        canDoubleDown: true,\n        startTime: Date.now()\n    };\n}\n\nfunction createDeck() {\n    const deck = [];\n    for (const suit of suits) {\n        for (const rank of ranks) {\n            deck.push({ suit, rank });\n        }\n    }\n    return shuffleDeck(deck);\n}\n\nfunction shuffleDeck(deck) {\n    for (let i = deck.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        [deck[i], deck[j]] = [deck[j], deck[i]];\n    }\n    return deck;\n}\n\nfunction dealCard(game) {\n    return game.deck.pop();\n}\n\nfunction dealInitialCards(game) {\n    // Deal 2 cards to player and dealer\n    game.playerHand.push(dealCard(game));\n    game.dealerHand.push(dealCard(game));\n    game.playerHand.push(dealCard(game));\n    game.dealerHand.push(dealCard(game));\n    \n    game.playerValue = calculateHandValue(game.playerHand);\n    game.dealerValue = calculateHandValue(game.dealerHand);\n    \n    // Check for natural blackjack\n    if (game.playerValue === 21) {\n        if (game.dealerValue === 21) {\n            game.status = 'push'; // Tie\n        } else {\n            game.status = 'blackjack'; // Player blackjack\n        }\n    }\n}\n\nfunction calculateHandValue(hand) {\n    let value = 0;\n    let aces = 0;\n    \n    for (const card of hand) {\n        if (card.rank === 'A') {\n            aces++;\n            value += 11;\n        } else if (['J', 'Q', 'K'].includes(card.rank)) {\n            value += 10;\n        } else {\n            value += parseInt(card.rank);\n        }\n    }\n    \n    // Handle aces\n    while (value > 21 && aces > 0) {\n        value -= 10;\n        aces--;\n    }\n    \n    return value;\n}\n\nfunction formatHand(hand, hideFirst = false) {\n    return hand.map((card, index) => {\n        if (hideFirst && index === 0) {\n            return 'üÉè';\n        }\n        return `${card.rank}${card.suit}`;\n    }).join(' ');\n}\n\n// Card dealing animation function\nasync function showCardDealingAnimation(interaction, game) {\n    const user = interaction.user;\n    \n    // Step 1: Show initial betting state\n    const bettingEmbed = new EmbedBuilder()\n        .setColor('#f7931a')\n        .setTitle('üé∞ Blackjack - Partie Commenc√©e!')\n        .setDescription(`**Mise:** ${formatLTC(game.bet)} LTC`)\n        .addFields(\n            { name: 'üÉè Statut', value: 'Distribution des cartes en cours...', inline: false }\n        )\n        .setImage('https://media.giphy.com/media/3o7qDEq2bMbcbPRQ2c/giphy.gif')\n        .setTimestamp();\n    \n    await interaction.editReply({ embeds: [bettingEmbed] });\n    await new Promise(resolve => setTimeout(resolve, 1500));\n    \n    // Step 2: Deal initial cards\n    dealInitialCards(game);\n    \n    // Step 3: Show cards being dealt animation\n    const dealingEmbed = new EmbedBuilder()\n        .setColor('#ff9900')\n        .setTitle('üÉè Distribution des Cartes')\n        .setDescription('üé¥ **CARTES DISTRIBU√âES** üé¥')\n        .setImage('https://media.giphy.com/media/l0ErO0YVpzRGVQfIs/giphy.gif')\n        .addFields(\n            { name: 'üéØ Action', value: 'Le croupier distribue vos cartes...', inline: false }\n        )\n        .setTimestamp();\n    \n    await interaction.editReply({ embeds: [dealingEmbed] });\n    await new Promise(resolve => setTimeout(resolve, 2000));\n    \n    // Step 4: Show final game state\n    const gameEmbed = createGameEmbed(game, user);\n    const gameButtons = createGameButtons(game);\n    \n    await interaction.editReply({ \n        embeds: [gameEmbed],\n        components: [gameButtons]\n    });\n}\n\nfunction createGameEmbed(game, user) {\n    const playerHandStr = formatHand(game.playerHand);\n    const dealerHandStr = formatHand(game.dealerHand, game.status === 'playing');\n    \n    let title = 'üÉè Partie de Blackjack';\n    let color = '#f7931a';\n    let description = `Mise: **${formatLTC(game.bet)} LTC**`;\n    \n    if (game.status === 'won') {\n        title = 'üéâ Vous avez gagn√©!';\n        color = '#00ff00';\n        description = `Vous avez gagn√© **${formatLTC(game.bet * 2)} LTC**!`;\n    } else if (game.status === 'lost') {\n        title = 'üí∏ Vous avez perdu';\n        color = '#ff0000';\n        description = `Vous avez perdu **${formatLTC(game.bet)} LTC**`;\n    } else if (game.status === 'push') {\n        title = 'ü§ù √âgalit√©';\n        color = '#ffaa00';\n        description = `Votre mise de **${formatLTC(game.bet)} LTC** vous a √©t√© rendue`;\n    } else if (game.status === 'blackjack') {\n        title = 'üéØ BLACKJACK!';\n        color = '#ffd700';\n        description = `Vous avez gagn√© **${formatLTC(game.bet * 2.5)} LTC** avec un Blackjack!`;\n    }\n    \n    const embed = new EmbedBuilder()\n        .setColor(color)\n        .setTitle(title)\n        .setDescription(description)\n        .addFields(\n            {\n                name: `üë§ Main de ${user.username} (${game.playerValue})`,\n                value: playerHandStr,\n                inline: false\n            },\n            {\n                name: `üé∞ Main du Croupier ${game.status === 'playing' ? '(?)' : `(${game.dealerValue})`}`,\n                value: dealerHandStr,\n                inline: false\n            }\n        )\n        .setFooter({ text: 'Bonne chance!' })\n        .setTimestamp();\n    \n    // Add GIF for game outcomes\n    if (game.status === 'won' || game.status === 'blackjack') {\n        embed.setImage('https://media.giphy.com/media/g9582DNuQppxC/giphy.gif');\n    } else if (game.status === 'lost') {\n        embed.setImage('https://media.giphy.com/media/l2Je66zG6mAAZxgqI/giphy.gif');\n    }\n    \n    if (game.status !== 'playing') {\n        const profile = userProfiles.getUserProfile(game.userId);\n        embed.addFields({\n            name: 'üí∞ Nouveau Solde',\n            value: `${formatLTC(profile.balance)} LTC`,\n            inline: true\n        });\n    }\n    \n    return embed;\n}\n\nfunction createGameButtons(game) {\n    const row = new ActionRowBuilder();\n    \n    if (game.status === 'playing') {\n        row.addComponents(\n            new ButtonBuilder()\n                .setCustomId('blackjack_hit')\n                .setLabel('Hit')\n                .setStyle(ButtonStyle.Primary)\n                .setEmoji('üéØ'),\n            new ButtonBuilder()\n                .setCustomId('blackjack_stand')\n                .setLabel('Stand')\n                .setStyle(ButtonStyle.Secondary)\n                .setEmoji('‚úã')\n        );\n        \n        if (game.canDoubleDown && game.playerHand.length === 2) {\n            const profile = userProfiles.getUserProfile(game.userId);\n            if (profile.balance >= game.bet) {\n                row.addComponents(\n                    new ButtonBuilder()\n                        .setCustomId('blackjack_double')\n                        .setLabel('Double Down')\n                        .setStyle(ButtonStyle.Success)\n                        .setEmoji('üí∞')\n                );\n            }\n        }\n    }\n    \n    return row;\n}\n\n// Export game functions for button handlers\nmodule.exports.activeGames = activeGames;\nmodule.exports.calculateHandValue = calculateHandValue;\nmodule.exports.dealCard = dealCard;\nmodule.exports.createGameEmbed = createGameEmbed;\nmodule.exports.createGameButtons = createGameButtons;\nmodule.exports.formatHand = formatHand;","size_bytes":12174},"commands/cashout.js":{"content":"const { SlashCommandBuilder, EmbedBuilder } = require('discord.js');\nconst securityManager = require('../utils/securityManager.js');\nconst userProfiles = require('../utils/userProfiles.js');\nconst ltcWallet = require('../litecoin-casino-bot.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('cashout')\n        .setDescription('Withdraw your LTC balance (requires password and 100% wagering)')\n        .addStringOption(option =>\n            option.setName('address')\n                .setDescription('Your LTC address to withdraw to')\n                .setRequired(true)\n        )\n        .addNumberOption(option =>\n            option.setName('amount')\n                .setDescription('Amount to withdraw in LTC')\n                .setRequired(true)\n                .setMinValue(0.001)\n        )\n        .addStringOption(option =>\n            option.setName('password')\n                .setDescription('Your account password')\n                .setRequired(true)\n        ),\n    \n    async execute(interaction) {\n        await interaction.deferReply({ ephemeral: true });\n        \n        try {\n            const toAddress = interaction.options.getString('address');\n            const amount = interaction.options.getNumber('amount');\n            const password = interaction.options.getString('password');\n            const userId = interaction.user.id;\n            \n            // Check if user has a password set\n            const userSec = securityManager.getUserSecurity(userId);\n            if (!userSec.hasPassword) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå No Password Set')\n                    .setDescription('You need to set a password first using `/setpassword` to cashout.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Verify password\n            if (!securityManager.verifyUserPassword(userId, password)) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Wrong Password')\n                    .setDescription('The password you entered is incorrect.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Check cashout eligibility (100% wagering requirement)\n            const cashoutStatus = securityManager.canUserCashout(userId);\n            \n            if (!cashoutStatus.canCashout) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Cashout Not Allowed')\n                    .setDescription('You must wager at least 100% of your deposited amount before cashing out.')\n                    .addFields(\n                        {\n                            name: 'üìä Wagering Status',\n                            value: `**Deposited:** ${cashoutStatus.depositedAmount.toFixed(8)} LTC\\n**Wagered:** ${cashoutStatus.wageredAmount.toFixed(8)} LTC\\n**Progress:** ${cashoutStatus.wageredPercent.toFixed(1)}%`,\n                            inline: true\n                        },\n                        {\n                            name: 'üéØ Remaining to Wager',\n                            value: `${cashoutStatus.remainingToWager.toFixed(8)} LTC`,\n                            inline: true\n                        },\n                        {\n                            name: 'üí° How to Unlock Cashout',\n                            value: 'Play casino games to increase your wagered amount to 100% of deposits.',\n                            inline: false\n                        }\n                    )\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Check user balance\n            const profile = userProfiles.getUserProfile(userId);\n            \n            if (profile.balance < amount) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Insufficient Balance')\n                    .setDescription(`You don't have enough balance to withdraw.`)\n                    .addFields({\n                        name: 'üí∞ Available Balance',\n                        value: `${profile.balance.toFixed(8)} LTC`,\n                        inline: true\n                    })\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Find a source address with sufficient balance\n            const addresses = ltcWallet.loadAddresses();\n            let fromAddress = null;\n            \n            for (const addr of addresses) {\n                if (addr.balance >= amount) {\n                    fromAddress = addr.address;\n                    break;\n                }\n            }\n            \n            if (!fromAddress) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå No Suitable Address')\n                    .setDescription('No address found with sufficient balance for withdrawal.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Process withdrawal\n            const processingEmbed = new EmbedBuilder()\n                .setColor('#ffaa00')\n                .setTitle('‚è≥ Processing Withdrawal')\n                .setDescription('Your withdrawal is being processed...')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [processingEmbed] });\n            \n            // Execute withdrawal\n            const txid = await ltcWallet.withdraw(fromAddress, toAddress, amount);\n            \n            if (!txid) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Withdrawal Failed')\n                    .setDescription('Failed to process withdrawal. Please try again or contact support.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Update user profile\n            userProfiles.addWithdrawal(userId, amount, toAddress, txid);\n            \n            const successEmbed = new EmbedBuilder()\n                .setColor('#00ff00')\n                .setTitle('‚úÖ Withdrawal Successful')\n                .setDescription('Your withdrawal has been processed and broadcasted to the Litecoin network.')\n                .addFields(\n                    {\n                        name: 'üí∞ Amount',\n                        value: `${amount.toFixed(8)} LTC`,\n                        inline: true\n                    },\n                    {\n                        name: 'üìç Destination',\n                        value: `\\`${toAddress}\\``,\n                        inline: false\n                    },\n                    {\n                        name: 'üîó Transaction ID',\n                        value: `\\`${txid}\\``,\n                        inline: false\n                    },\n                    {\n                        name: '‚è∞ Status',\n                        value: 'Transaction broadcasted - confirmations pending',\n                        inline: false\n                    }\n                )\n                .setThumbnail('https://cryptologos.cc/logos/litecoin-ltc-logo.png')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [successEmbed] });\n            \n            console.log(`üí∏ Processed withdrawal: ${amount} LTC for user ${interaction.user.username} - TXID: ${txid}`);\n            \n        } catch (error) {\n            console.error('Cashout error:', error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Cashout Error')\n                .setDescription('An error occurred while processing your withdrawal. Please try again.')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};","size_bytes":8639},"commands/changepassword.js":{"content":"const { SlashCommandBuilder, EmbedBuilder } = require('discord.js');\nconst securityManager = require('../utils/securityManager.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('changepassword')\n        .setDescription('Change your account password')\n        .addStringOption(option =>\n            option.setName('oldpassword')\n                .setDescription('Your current password')\n                .setRequired(true)\n        )\n        .addStringOption(option =>\n            option.setName('newpassword')\n                .setDescription('Your new password (minimum 6 characters)')\n                .setRequired(true)\n        ),\n    \n    async execute(interaction) {\n        await interaction.deferReply({ ephemeral: true });\n        \n        try {\n            const oldPassword = interaction.options.getString('oldpassword');\n            const newPassword = interaction.options.getString('newpassword');\n            \n            // Validate new password\n            if (newPassword.length < 6) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Invalid Password')\n                    .setDescription('New password must be at least 6 characters long.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Check if user has a password set\n            const userSec = securityManager.getUserSecurity(interaction.user.id);\n            if (!userSec.hasPassword) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå No Password Set')\n                    .setDescription('You need to set a password first using `/setpassword`.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Try to change password\n            const success = securityManager.changeUserPassword(interaction.user.id, oldPassword, newPassword);\n            \n            if (!success) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Wrong Password')\n                    .setDescription('Your current password is incorrect.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            const successEmbed = new EmbedBuilder()\n                .setColor('#00ff00')\n                .setTitle('‚úÖ Password Changed')\n                .setDescription('Your password has been successfully changed.')\n                .addFields({\n                    name: 'üîí Security',\n                    value: 'Your recovery key remains the same and is still valid.',\n                    inline: false\n                })\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [successEmbed] });\n            \n        } catch (error) {\n            console.error('Change password error:', error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Error')\n                .setDescription('Failed to change password. Please try again.')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};","size_bytes":3608},"commands/coinflip.js":{"content":"const { SlashCommandBuilder, EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle } = require('discord.js');\nconst securityManager = require('../utils/securityManager.js');\nconst userProfiles = require('../utils/userProfiles.js');\nconst treasuryManager = require('../utils/treasuryManager.js');\n\n// Active coinflip sessions for progression system\nconst activeSessions = new Map();\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('coinflip')\n        .setDescription('ü™ô Play coin flip - Choose heads or tails and double your bet!')\n        .addNumberOption(option =>\n            option.setName('amount')\n                .setDescription('Amount to bet in LTC')\n                .setRequired(true)\n                .setMinValue(0.001)\n                .setMaxValue(10)\n        )\n        .addStringOption(option =>\n            option.setName('choice')\n                .setDescription('Choose heads, tails, or random')\n                .setRequired(true)\n                .addChoices(\n                    { name: 'ü¶Ö Heads', value: 'heads' },\n                    { name: '‚ö° Tails', value: 'tails' },\n                    { name: 'üé≤ Random Side', value: 'random' }\n                )\n        ),\n\n    async execute(interaction) {\n        await interaction.deferReply({ ephemeral: false });\n\n        try {\n            const amount = interaction.options.getNumber('amount');\n            let playerChoice = interaction.options.getString('choice');\n            const userId = interaction.user.id;\n            \n            // Handle random choice\n            if (playerChoice === 'random') {\n                playerChoice = Math.random() < 0.5 ? 'heads' : 'tails';\n            }\n\n            // Check if user has active gambling session\n            if (!securityManager.hasActiveGamblingSession(userId)) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#e74c3c')\n                    .setTitle('üîí No Active Session')\n                    .setDescription('You need to enable a gambling session first using `/enable`.')\n                    .addFields({\n                        name: 'üéÆ How to Start',\n                        value: 'Use `/enable [minutes] [password]` to start a gambling session.',\n                        inline: false\n                    })\n                    .setTimestamp();\n\n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n\n            // Check treasury bet limits\n            const maxBet = treasuryManager.getMaxBetLimit();\n            if (amount > maxBet) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#e74c3c')\n                    .setTitle('‚ùå Bet Too High')\n                    .setDescription(`Maximum bet allowed is ${maxBet.toFixed(8)} LTC (30% of casino funds).`)\n                    .addFields({\n                        name: 'üí∞ Current Limits',\n                        value: `**Your bet:** ${amount.toFixed(8)} LTC\\n**Maximum allowed:** ${maxBet.toFixed(8)} LTC\\n**Casino funds:** ${treasuryManager.getCurrentBalance().toFixed(8)} LTC`,\n                        inline: false\n                    })\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n\n            // Check user balance\n            const profile = userProfiles.getUserProfile(userId);\n            if (profile.balance < amount) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#e74c3c')\n                    .setTitle('‚ùå Insufficient Balance')\n                    .setDescription('You don\\'t have enough balance to place this bet.')\n                    .addFields({\n                        name: 'üí∞ Available Balance',\n                        value: `${profile.balance.toFixed(8)} LTC`,\n                        inline: true\n                    })\n                    .setTimestamp();\n\n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n\n            // Deduct bet amount upfront\n            userProfiles.updateUserProfile(userId, { \n                balance: profile.balance - amount \n            });\n\n            // Show coinflip animation\n            await this.showCoinflipAnimation(interaction, amount, playerChoice);\n\n\n        } catch (error) {\n            console.error('Coin flip error:', error);\n\n            const errorEmbed = new EmbedBuilder()\n                .setColor('#e74c3c')\n                .setTitle('‚ùå Game Error')\n                .setDescription('An error occurred during the coin flip. Please try again.')\n                .setTimestamp();\n\n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    },\n\n    // Animation function for coinflip\n    async showCoinflipAnimation(interaction, amount, playerChoice) {\n        const userId = interaction.user.id;\n        \n        // Step 1: Show betting summary\n        const bettingEmbed = new EmbedBuilder()\n            .setColor('#f39c12')\n            .setTitle('ü™ô Coinflip - Pari Lanc√©!')\n            .setDescription(`**Mise:** ${amount.toFixed(8)} LTC`)\n            .addFields(\n                { name: 'üéØ Votre Choix', value: playerChoice === 'heads' ? 'ü¶Ö Pile' : '‚ö° Face', inline: true },\n                { name: 'üé≤ Statut', value: 'Lancement de la pi√®ce...', inline: true }\n            )\n            .setTimestamp();\n        \n        await interaction.editReply({ embeds: [bettingEmbed] });\n        await new Promise(resolve => setTimeout(resolve, 1000));\n        \n        // Step 2: Coin spinning animation\n        const spinningEmbed = new EmbedBuilder()\n            .setColor('#e67e22')\n            .setTitle('ü™ô La Pi√®ce Tourne!')\n            .setDescription('üåÄ **SPIN EN COURS** üåÄ')\n            .setImage('https://media.giphy.com/media/3o6fJ1BM7R2EBRDnxK/giphy.gif')\n            .addFields(\n                { name: 'üé≤ Animation', value: 'La pi√®ce tourne dans les airs...', inline: false }\n            )\n            .setTimestamp();\n        \n        await interaction.editReply({ embeds: [spinningEmbed] });\n        await new Promise(resolve => setTimeout(resolve, 2500));\n        \n        // Step 3: Coin slowing down\n        const slowingEmbed = new EmbedBuilder()\n            .setColor('#d35400')\n            .setTitle('ü™ô La Pi√®ce Ralentit!')\n            .setDescription('‚è≥ **PRESQUE FINI** ‚è≥')\n            .setImage('https://media.giphy.com/media/l0ErFafpUCQTQFMSk/giphy.gif')\n            .addFields(\n                { name: 'üéØ Statut', value: 'La pi√®ce va bient√¥t atterrir...', inline: false }\n            )\n            .setTimestamp();\n        \n        await interaction.editReply({ embeds: [slowingEmbed] });\n        await new Promise(resolve => setTimeout(resolve, 1500));\n        \n        // Step 4: Generate result and show final result\n        const coinResult = Math.random() < 0.5 ? 'heads' : 'tails';\n        const won = playerChoice === coinResult;\n        \n        // Handle progression system\n        let currentSession = activeSessions.get(userId);\n        if (!currentSession) {\n            currentSession = {\n                currentBet: amount,\n                totalWinnings: 0,\n                streak: 0,\n                canCashout: false,\n                lastChoice: playerChoice\n            };\n        }\n        \n        // Update last choice\n        currentSession.lastChoice = playerChoice;\n        \n        if (won) {\n            const winAmount = currentSession.currentBet * 2;\n            currentSession.totalWinnings += winAmount;\n            currentSession.currentBet = winAmount; // Double for next round\n            currentSession.streak++;\n            currentSession.canCashout = true;\n            \n            // Don't credit balance yet - keep in session until cashout\n            activeSessions.set(userId, currentSession);\n            \n            // Record treasury transaction\n            treasuryManager.recordPayout(amount, userId, 'coinflip', {\n                originalAmount: amount,\n                winAmount: winAmount,\n                choice: playerChoice,\n                result: coinResult\n            });\n        } else {\n            // Lost - reset session (bet already deducted)\n            activeSessions.delete(userId);\n            \n            // Record house win\n            treasuryManager.recordHouseWin(amount, userId, 'coinflip', {\n                lostAmount: amount,\n                choice: playerChoice,\n                result: coinResult\n            });\n        }\n        \n        // Add wagered amount\n        securityManager.addWageredAmount(userId, amount);\n        \n        // Create result embed\n        const resultEmbed = this.createProgressionResultEmbed(interaction.user, amount, playerChoice, coinResult, won, currentSession);\n        const actionButtons = won ? this.createProgressionButtons(currentSession) : null;\n        \n        await interaction.editReply({\n            embeds: [resultEmbed],\n            components: actionButtons ? [actionButtons] : []\n        });\n        \n        console.log(`ü™ô ${interaction.user.username} played coinflip: ${playerChoice} vs ${coinResult} - ${won ? 'WON' : 'LOST'} ${amount.toFixed(8)} LTC`);\n    },\n\n    createProgressionResultEmbed(user, betAmount, playerChoice, coinResult, won, session) {\n        const resultEmbed = new EmbedBuilder()\n            .setColor(won ? '#27ae60' : '#e74c3c')\n            .setTitle(won ? 'üéâ GAGN√â!' : 'üíî PERDU!')\n            .setDescription(`**${user.username}** a choisi **${playerChoice === 'heads' ? 'ü¶Ö Pile' : '‚ö° Face'}**`)\n            .addFields(\n                {\n                    name: 'üéØ R√©sultat',\n                    value: `**La pi√®ce est tomb√©e sur:** ${coinResult === 'heads' ? 'ü¶Ö **PILE**' : '‚ö° **FACE**'}\\\\n**Votre choix:** ${playerChoice === 'heads' ? 'ü¶Ö Pile' : '‚ö° Face'}\\\\n**R√©sultat:** ${won ? 'üéâ **VICTOIRE!**' : 'üíî **D√âFAITE**'}`,\n                    inline: false\n                }\n            )\n            .setTimestamp();\n        \n        if (won) {\n            resultEmbed.addFields(\n                {\n                    name: 'üí∞ Gains',\n                    value: `**Mise:** ${betAmount.toFixed(8)} LTC\\\\n**Gains:** ${(betAmount * 2).toFixed(8)} LTC\\\\n**S√©rie:** ${session.streak} victoire(s)`,\n                    inline: true\n                },\n                {\n                    name: 'üöÄ Prochaine Mise',\n                    value: `**Double ou Rien:** ${session.currentBet.toFixed(8)} LTC\\\\n**Gains totaux:** ${session.totalWinnings.toFixed(8)} LTC`,\n                    inline: true\n                }\n            );\n            \n            // Add celebration GIF for wins\n            resultEmbed.setImage('https://media.giphy.com/media/g9582DNuQppxC/giphy.gif');\n        } else {\n            resultEmbed.addFields(\n                {\n                    name: 'üí∏ Pertes',\n                    value: `**Mise perdue:** ${betAmount.toFixed(8)} LTC\\\\n**S√©rie interrompue**`,\n                    inline: false\n                }\n            );\n            \n            // Add sad GIF for losses\n            resultEmbed.setImage('https://media.giphy.com/media/l2Je66zG6mAAZxgqI/giphy.gif');\n        }\n        \n        // Add balance info\n        const profile = userProfiles.getUserProfile(user.id);\n        resultEmbed.addFields({\n            name: 'üí≥ Solde Actuel',\n            value: `${profile.balance.toFixed(8)} LTC`,\n            inline: true\n        });\n        \n        return resultEmbed;\n    },\n\n    createProgressionButtons(session) {\n        const actionRow = new ActionRowBuilder()\n            .addComponents(\n                new ButtonBuilder()\n                    .setCustomId(`coinflip_double_${session.currentBet}`)\n                    .setLabel(`üé≤ Double ou Rien (${session.currentBet.toFixed(8)} LTC)`)\n                    .setStyle(ButtonStyle.Danger)\n                    .setEmoji('üé≤'),\n                new ButtonBuilder()\n                    .setCustomId('coinflip_cashout')\n                    .setLabel(`üí∞ Encaisser (${session.totalWinnings.toFixed(8)} LTC)`)\n                    .setStyle(ButtonStyle.Success)\n                    .setEmoji('üí∞')\n            );\n        \n        return actionRow;\n    },\n\n    createGameActionButtons(balance, canCashout) {\n        if (balance < 0.001) return null;\n\n        const actionRow = new ActionRowBuilder()\n            .addComponents(\n                new ButtonBuilder()\n                    .setCustomId('coinflip_again_small')\n                    .setLabel('ü™ô Flip Again (0.001)')\n                    .setStyle(ButtonStyle.Primary)\n                    .setEmoji('ü™ô'),\n                new ButtonBuilder()\n                    .setCustomId('coinflip_again_medium')\n                    .setLabel('üéØ Medium Bet (0.01)')\n                    .setStyle(ButtonStyle.Secondary)\n                    .setEmoji('üéØ')\n                    .setDisabled(balance < 0.01),\n                new ButtonBuilder()\n                    .setCustomId('coinflip_again_big')\n                    .setLabel('üíé High Roller (0.1)')\n                    .setStyle(ButtonStyle.Danger)\n                    .setEmoji('üíé')\n                    .setDisabled(balance < 0.1)\n            );\n\n        if (canCashout) {\n            actionRow.addComponents(\n                new ButtonBuilder()\n                    .setCustomId('quick_cashout')\n                    .setLabel('üí∞ Cashout')\n                    .setStyle(ButtonStyle.Success)\n                    .setEmoji('üí∞')\n            );\n        }\n\n        return actionRow;\n    }\n};\n\n// Export activeSessions for button handlers\nmodule.exports.activeSessions = activeSessions;","size_bytes":13826},"commands/convert-eur-usd.js":{"content":"const { SlashCommandBuilder, EmbedBuilder } = require('discord.js');\nconst currencyConverter = require('../utils/currencyConverter.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('convert-eur-usd')\n        .setDescription('Convert EUR to USD')\n        .addNumberOption(option =>\n            option.setName('amount')\n                .setDescription('Amount in EUR to convert')\n                .setRequired(true)\n                .setMinValue(0.01)\n        ),\n    \n    async execute(interaction) {\n        await interaction.deferReply();\n        \n        try {\n            const amount = interaction.options.getNumber('amount');\n            \n            // Perform currency conversion\n            const conversion = await currencyConverter.convertCurrency(amount, 'EUR', 'USD');\n            \n            const conversionEmbed = new EmbedBuilder()\n                .setColor('#4CAF50')\n                .setTitle('üí± Currency Conversion')\n                .setDescription('**EUR ‚Üí USD**')\n                .addFields(\n                    {\n                        name: 'üá™üá∫ Euro Amount',\n                        value: `‚Ç¨${conversion.originalAmount.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`,\n                        inline: true\n                    },\n                    {\n                        name: 'üá∫üá∏ US Dollar Equivalent',\n                        value: `$${conversion.convertedAmount.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`,\n                        inline: true\n                    },\n                    {\n                        name: 'üìä Exchange Rate',\n                        value: `1 EUR = $${conversion.exchangeRate.toFixed(4)} USD`,\n                        inline: false\n                    }\n                )\n                .setFooter({ \n                    text: 'Exchange rates are updated in real-time' \n                })\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [conversionEmbed] });\n            \n        } catch (error) {\n            console.error('EUR to USD conversion error:', error);\n            \n            let errorMessage = 'Failed to convert currency. Please try again later.';\n            \n            if (error.message.includes('Amount must be greater than 0')) {\n                errorMessage = 'Please enter a valid amount greater than 0.';\n            } else if (error.message.includes('Failed to fetch exchange rate')) {\n                errorMessage = 'Currency conversion service is temporarily unavailable.';\n            }\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Conversion Failed')\n                .setDescription(errorMessage)\n                .addFields({\n                    name: 'üí° Tip',\n                    value: 'Exchange rates are fetched from external APIs. Please try again in a few moments.',\n                    inline: false\n                })\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};","size_bytes":3206},"commands/convert-usd-eur.js":{"content":"const { SlashCommandBuilder, EmbedBuilder } = require('discord.js');\nconst currencyConverter = require('../utils/currencyConverter.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('convert-usd-eur')\n        .setDescription('Convert USD to EUR')\n        .addNumberOption(option =>\n            option.setName('amount')\n                .setDescription('Amount in USD to convert')\n                .setRequired(true)\n                .setMinValue(0.01)\n        ),\n    \n    async execute(interaction) {\n        await interaction.deferReply();\n        \n        try {\n            const amount = interaction.options.getNumber('amount');\n            \n            // Perform currency conversion\n            const conversion = await currencyConverter.convertCurrency(amount, 'USD', 'EUR');\n            \n            const conversionEmbed = new EmbedBuilder()\n                .setColor('#4CAF50')\n                .setTitle('üí± Currency Conversion')\n                .setDescription('**USD ‚Üí EUR**')\n                .addFields(\n                    {\n                        name: 'üá∫üá∏ US Dollar Amount',\n                        value: `$${conversion.originalAmount.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`,\n                        inline: true\n                    },\n                    {\n                        name: 'üá™üá∫ Euro Equivalent',\n                        value: `‚Ç¨${conversion.convertedAmount.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`,\n                        inline: true\n                    },\n                    {\n                        name: 'üìä Exchange Rate',\n                        value: `1 USD = ‚Ç¨${conversion.exchangeRate.toFixed(4)} EUR`,\n                        inline: false\n                    }\n                )\n                .setFooter({ \n                    text: 'Exchange rates are updated in real-time' \n                })\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [conversionEmbed] });\n            \n        } catch (error) {\n            console.error('USD to EUR conversion error:', error);\n            \n            let errorMessage = 'Failed to convert currency. Please try again later.';\n            \n            if (error.message.includes('Amount must be greater than 0')) {\n                errorMessage = 'Please enter a valid amount greater than 0.';\n            } else if (error.message.includes('Failed to fetch exchange rate')) {\n                errorMessage = 'Currency conversion service is temporarily unavailable.';\n            }\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Conversion Failed')\n                .setDescription(errorMessage)\n                .addFields({\n                    name: 'üí° Tip',\n                    value: 'Exchange rates are fetched from external APIs. Please try again in a few moments.',\n                    inline: false\n                })\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};","size_bytes":3208},"commands/createsession.js":{"content":"const { SlashCommandBuilder, EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle, StringSelectMenuBuilder } = require('discord.js');\nconst sessionManager = require('../utils/sessionManager.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('createsession')\n        .setDescription('Create a private gaming session with friends')\n        .addStringOption(option =>\n            option.setName('type')\n                .setDescription('Type of gaming session')\n                .setRequired(true)\n                .addChoices(\n                    { name: 'üé∞ General Casino', value: 'general' },\n                    { name: 'üÉè Blackjack Tournament', value: 'blackjack' },\n                    { name: 'üéØ Roulette Party', value: 'roulette' },\n                    { name: 'üé≤ High Stakes', value: 'highstakes' },\n                    { name: 'üë• Group Games', value: 'group' }\n                )\n        )\n        .addIntegerOption(option =>\n            option.setName('duration')\n                .setDescription('Session duration in minutes (15-360)')\n                .setMinValue(15)\n                .setMaxValue(360)\n        )\n        .addIntegerOption(option =>\n            option.setName('maxplayers')\n                .setDescription('Maximum number of players (2-20)')\n                .setMinValue(2)\n                .setMaxValue(20)\n        )\n        .addNumberOption(option =>\n            option.setName('minbet')\n                .setDescription('Minimum bet amount in LTC')\n                .setMinValue(0.001)\n                .setMaxValue(1.0)\n        )\n        .addNumberOption(option =>\n            option.setName('maxbet')\n                .setDescription('Maximum bet amount in LTC')\n                .setMinValue(0.001)\n                .setMaxValue(100.0)\n        ),\n\n    async execute(interaction) {\n        await interaction.deferReply({ ephemeral: false });\n\n        try {\n            const sessionType = interaction.options.getString('type');\n            const duration = interaction.options.getInteger('duration') || 60;\n            const maxParticipants = interaction.options.getInteger('maxplayers') || 6;\n            const minBet = interaction.options.getNumber('minbet') || 0.001;\n            const maxBet = interaction.options.getNumber('maxbet') || 1.0;\n\n            // Check if user is already in a session\n            const existingSession = sessionManager.isUserInSession(interaction.user.id);\n            if (existingSession) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#e74c3c')\n                    .setTitle('‚ùå Already in Session')\n                    .setDescription('You are already in an active gaming session!')\n                    .addFields({\n                        name: 'üéÆ Current Session',\n                        value: `**Type:** ${existingSession.sessionType}\\n**Channel:** <#${existingSession.channelId}>`,\n                        inline: false\n                    })\n                    .setTimestamp();\n\n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n\n            // Validate bet limits\n            if (minBet >= maxBet) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#e74c3c')\n                    .setTitle('‚ùå Invalid Bet Limits')\n                    .setDescription('Minimum bet must be less than maximum bet!')\n                    .setTimestamp();\n\n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n\n            const options = {\n                duration,\n                maxParticipants,\n                minBet,\n                maxBet,\n                isPublic: false,\n                allowSpectators: true\n            };\n\n            // Create the session\n            const result = await sessionManager.createPrivateSession(\n                interaction.guild,\n                interaction.user,\n                sessionType,\n                options\n            );\n\n            if (result.success) {\n                const successEmbed = new EmbedBuilder()\n                    .setColor('#2ecc71')\n                    .setTitle('üéâ Gaming Session Created!')\n                    .setDescription(`Your private ${sessionType} session has been created successfully!`)\n                    .addFields(\n                        {\n                            name: 'üè† Your Private Room',\n                            value: `${result.channel}\\nClick the link to enter your session!`,\n                            inline: false\n                        },\n                        {\n                            name: 'üéÆ Session Details',\n                            value: `**Type:** ${sessionType.charAt(0).toUpperCase() + sessionType.slice(1)}\\n**Duration:** ${duration} minutes\\n**Max Players:** ${maxParticipants}`,\n                            inline: true\n                        },\n                        {\n                            name: 'üí∞ Betting Limits',\n                            value: `**Min Bet:** ${minBet} LTC\\n**Max Bet:** ${maxBet} LTC`,\n                            inline: true\n                        },\n                        {\n                            name: 'üéØ Next Steps',\n                            value: '‚Ä¢ Invite friends to your session\\n‚Ä¢ Configure additional settings\\n‚Ä¢ Start playing games!\\n‚Ä¢ Have fun! üéä',\n                            inline: false\n                        }\n                    )\n                    .setThumbnail(interaction.user.displayAvatarURL({ dynamic: true }))\n                    .setFooter({ text: `Session ID: ${result.session.id}` })\n                    .setTimestamp();\n\n                const actionRow = new ActionRowBuilder()\n                    .addComponents(\n                        new ButtonBuilder()\n                            .setLabel('üöÄ Go to Session')\n                            .setStyle(ButtonStyle.Link)\n                            .setURL(`https://discord.com/channels/${interaction.guild.id}/${result.channel.id}`)\n                            .setEmoji('üöÄ'),\n                        new ButtonBuilder()\n                            .setCustomId(`session_invite_${result.session.id}`)\n                            .setLabel('üë• Invite Friends')\n                            .setStyle(ButtonStyle.Primary)\n                            .setEmoji('üë•')\n                    );\n\n                await interaction.editReply({ \n                    embeds: [successEmbed],\n                    components: [actionRow]\n                });\n\n                console.log(`üéÆ New gaming session created by ${interaction.user.username}: ${result.session.id}`);\n\n            } else {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#e74c3c')\n                    .setTitle('‚ùå Session Creation Failed')\n                    .setDescription(`Failed to create gaming session: ${result.error}`)\n                    .setTimestamp();\n\n                await interaction.editReply({ embeds: [errorEmbed] });\n            }\n\n        } catch (error) {\n            console.error('Create session error:', error);\n\n            const errorEmbed = new EmbedBuilder()\n                .setColor('#e74c3c')\n                .setTitle('‚ùå Unexpected Error')\n                .setDescription('An error occurred while creating your gaming session. Please try again.')\n                .setTimestamp();\n\n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};","size_bytes":7586},"commands/enable.js":{"content":"const { SlashCommandBuilder, EmbedBuilder } = require('discord.js');\nconst securityManager = require('../utils/securityManager.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('enable')\n        .setDescription('Enable gambling session with time limit (requires password)')\n        .addIntegerOption(option =>\n            option.setName('minutes')\n                .setDescription('Session duration in minutes (1-60)')\n                .setRequired(true)\n                .setMinValue(1)\n                .setMaxValue(60)\n        )\n        .addStringOption(option =>\n            option.setName('password')\n                .setDescription('Your account password')\n                .setRequired(true)\n        ),\n    \n    async execute(interaction) {\n        await interaction.deferReply({ ephemeral: true });\n        \n        try {\n            const minutes = interaction.options.getInteger('minutes');\n            const password = interaction.options.getString('password');\n            \n            // Check if user has a password set\n            const userSec = securityManager.getUserSecurity(interaction.user.id);\n            if (!userSec.hasPassword) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå No Password Set')\n                    .setDescription('You need to set a password first using `/setpassword` to enable gambling sessions.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Verify password\n            if (!securityManager.verifyUserPassword(interaction.user.id, password)) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Wrong Password')\n                    .setDescription('The password you entered is incorrect.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Check if user already has an active session\n            if (securityManager.hasActiveGamblingSession(interaction.user.id)) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ffaa00')\n                    .setTitle('‚ö†Ô∏è Session Already Active')\n                    .setDescription('You already have an active gambling session. Wait for it to expire before starting a new one.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Start gambling session\n            const endTime = securityManager.startGamblingSession(interaction.user.id, minutes);\n            \n            const successEmbed = new EmbedBuilder()\n                .setColor('#00ff00')\n                .setTitle('üé∞ Gambling Session Enabled')\n                .setDescription(`Your gambling session is now active for **${minutes} minute${minutes > 1 ? 's' : ''}**.`)\n                .addFields(\n                    {\n                        name: '‚è∞ Session Details',\n                        value: `**Started:** <t:${Math.floor(Date.now()/1000)}:T>\\n**Ends:** <t:${Math.floor(endTime.getTime()/1000)}:T>\\n**Duration:** ${minutes} minute${minutes > 1 ? 's' : ''}`,\n                        inline: false\n                    },\n                    {\n                        name: 'üéÆ What you can do now',\n                        value: '‚Ä¢ Play casino games\\n‚Ä¢ Place bets\\n‚Ä¢ Use gambling features\\n‚Ä¢ All protected by your session',\n                        inline: true\n                    },\n                    {\n                        name: 'üîí Security',\n                        value: '‚Ä¢ Session auto-expires\\n‚Ä¢ Password protected\\n‚Ä¢ Secure gambling environment',\n                        inline: true\n                    }\n                )\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [successEmbed] });\n            \n        } catch (error) {\n            console.error('Enable gambling session error:', error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Error')\n                .setDescription('Failed to enable gambling session. Please try again.')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};","size_bytes":4646},"commands/givebal.js":{"content":"const { SlashCommandBuilder, EmbedBuilder } = require('discord.js');\nconst userProfiles = require('../utils/userProfiles.js');\nconst { formatLTC } = require('../utils/formatters.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('givebal')\n        .setDescription('Transfer balance to another user')\n        .addUserOption(option =>\n            option.setName('user')\n                .setDescription('User to transfer balance to')\n                .setRequired(true)\n        )\n        .addNumberOption(option =>\n            option.setName('amount')\n                .setDescription('Amount to transfer (in LTC)')\n                .setRequired(true)\n                .setMinValue(0.00000001)\n        ),\n    \n    async execute(interaction) {\n        await interaction.deferReply();\n        \n        try {\n            const targetUser = interaction.options.getUser('user');\n            const amount = interaction.options.getNumber('amount');\n            const fromUserId = interaction.user.id;\n            const toUserId = targetUser.id;\n            \n            // Validation checks\n            if (fromUserId === toUserId) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Invalid Transfer')\n                    .setDescription('You cannot transfer balance to yourself!')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            if (amount <= 0) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Invalid Amount')\n                    .setDescription('Amount must be greater than 0!')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Check sender's balance\n            const senderProfile = userProfiles.getUserProfile(fromUserId);\n            \n            if (senderProfile.balance < amount) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Insufficient Balance')\n                    .setDescription(`You don't have enough balance!\\n\\n**Your Balance:** ${formatLTC(senderProfile.balance)} LTC\\n**Required:** ${formatLTC(amount)} LTC`)\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Perform the transfer\n            const transfer = userProfiles.transferBalance(fromUserId, toUserId, amount);\n            \n            // Get updated profiles\n            const updatedSenderProfile = userProfiles.getUserProfile(fromUserId);\n            const updatedReceiverProfile = userProfiles.getUserProfile(toUserId);\n            \n            const successEmbed = new EmbedBuilder()\n                .setColor('#00ff00')\n                .setTitle('‚úÖ Transfer Successful')\n                .setDescription(`Successfully transferred **${formatLTC(amount)} LTC** to ${targetUser}`)\n                .addFields(\n                    {\n                        name: 'üë§ From',\n                        value: `${interaction.user}\\n**New Balance:** ${formatLTC(updatedSenderProfile.balance)} LTC`,\n                        inline: true\n                    },\n                    {\n                        name: 'üë§ To',\n                        value: `${targetUser}\\n**New Balance:** ${formatLTC(updatedReceiverProfile.balance)} LTC`,\n                        inline: true\n                    },\n                    {\n                        name: 'üìã Transaction Details',\n                        value: `**Amount:** ${formatLTC(amount)} LTC\\n**Date:** ${new Date(transfer.timestamp).toLocaleString()}\\n**ID:** ${transfer.timestamp}`,\n                        inline: false\n                    }\n                )\n                .setThumbnail('https://cryptologos.cc/logos/litecoin-ltc-logo.png')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [successEmbed] });\n            \n            // Try to notify the receiver (if they share a server)\n            try {\n                const receiverDM = await targetUser.createDM();\n                \n                const notificationEmbed = new EmbedBuilder()\n                    .setColor('#00ff00')\n                    .setTitle('üí∞ Balance Received')\n                    .setDescription(`You received **${amount.toFixed(8)} LTC** from ${interaction.user.username}!`)\n                    .addFields({\n                        name: 'üí≥ Your New Balance',\n                        value: `${updatedReceiverProfile.balance.toFixed(8)} LTC`,\n                        inline: true\n                    })\n                    .setThumbnail('https://cryptologos.cc/logos/litecoin-ltc-logo.png')\n                    .setTimestamp();\n                \n                await receiverDM.send({ embeds: [notificationEmbed] });\n            } catch (dmError) {\n                console.log('Could not send DM notification:', dmError.message);\n                // This is not critical, so we don't show error to user\n            }\n            \n        } catch (error) {\n            console.error('Transfer command error:', error);\n            \n            let errorMessage = 'Failed to process transfer. Please try again.';\n            \n            if (error.message === 'Insufficient balance') {\n                errorMessage = 'Insufficient balance for this transfer.';\n            }\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Transfer Failed')\n                .setDescription(errorMessage)\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};","size_bytes":6057},"commands/ownertransfer.js":{"content":"const { SlashCommandBuilder, EmbedBuilder } = require('discord.js');\nconst userProfiles = require('../utils/userProfiles.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('ownertransfer')\n        .setDescription('üîë Owner only: Transfer balance between any users')\n        .addUserOption(option =>\n            option.setName('fromuser')\n                .setDescription('User to transfer FROM')\n                .setRequired(true)\n        )\n        .addUserOption(option =>\n            option.setName('touser')\n                .setDescription('User to transfer TO')\n                .setRequired(true)\n        )\n        .addNumberOption(option =>\n            option.setName('amount')\n                .setDescription('Amount to transfer (in LTC)')\n                .setRequired(true)\n                .setMinValue(0.00000001)\n                .setMaxValue(100)\n        ),\n\n    async execute(interaction) {\n        await interaction.deferReply({ ephemeral: false });\n\n        try {\n            // Check if user is owner\n            if (interaction.user.id !== process.env.OWNER_ID) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#e74c3c')\n                    .setTitle('‚ùå Acc√®s Refus√©')\n                    .setDescription('Cette commande est r√©serv√©e au propri√©taire du bot.')\n                    .setTimestamp();\n\n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n\n            const fromUser = interaction.options.getUser('fromuser');\n            const toUser = interaction.options.getUser('touser');\n            const amount = parseFloat(interaction.options.getNumber('amount'));\n\n            // Validate amount\n            if (amount <= 0 || isNaN(amount)) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#e74c3c')\n                    .setTitle('‚ùå Montant Invalide')\n                    .setDescription('Le montant doit √™tre sup√©rieur √† 0.')\n                    .setTimestamp();\n\n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n\n            // Get user profiles\n            const fromProfile = userProfiles.getUserProfile(fromUser.id);\n            const toProfile = userProfiles.getUserProfile(toUser.id);\n\n            // Check if fromUser has sufficient balance\n            if (fromProfile.balance < amount) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#e74c3c')\n                    .setTitle('‚ùå Fonds Insuffisants')\n                    .setDescription(`${fromUser.username} n'a que ${fromProfile.balance.toFixed(8)} LTC disponible.`)\n                    .addFields({\n                        name: 'üí∞ D√©tails',\n                        value: `**Demand√©:** ${amount.toFixed(8)} LTC\\n**Disponible:** ${fromProfile.balance.toFixed(8)} LTC\\n**Manquant:** ${(amount - fromProfile.balance).toFixed(8)} LTC`,\n                        inline: false\n                    })\n                    .setTimestamp();\n\n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n\n            // Perform the transfer\n            const oldFromBalance = fromProfile.balance;\n            const oldToBalance = toProfile.balance;\n\n            fromProfile.balance -= amount;\n            toProfile.balance += amount;\n\n            // Update profiles\n            userProfiles.updateUserProfile(fromUser.id, fromProfile);\n            userProfiles.updateUserProfile(toUser.id, toProfile);\n\n            // Create success embed\n            const successEmbed = new EmbedBuilder()\n                .setColor('#2ecc71')\n                .setTitle('‚úÖ Transfert R√©alis√©')\n                .setDescription(`**${amount.toFixed(8)} LTC** transf√©r√© avec succ√®s!`)\n                .addFields(\n                    {\n                        name: 'üì§ √âmetteur',\n                        value: `**${fromUser.username}**\\n*Ancien:* ${oldFromBalance.toFixed(8)} LTC\\n*Nouveau:* ${fromProfile.balance.toFixed(8)} LTC`,\n                        inline: true\n                    },\n                    {\n                        name: 'üì• Destinataire',\n                        value: `**${toUser.username}**\\n*Ancien:* ${oldToBalance.toFixed(8)} LTC\\n*Nouveau:* ${toProfile.balance.toFixed(8)} LTC`,\n                        inline: true\n                    },\n                    {\n                        name: 'üîó Transaction',\n                        value: `**Montant:** ${amount.toFixed(8)} LTC\\n**Par:** ${interaction.user.username}\\n**Type:** Transfert Owner`,\n                        inline: false\n                    }\n                )\n                .setThumbnail('https://cryptologos.cc/logos/litecoin-ltc-logo.png')\n                .setFooter({ text: `üîë Transfert autoris√© par le propri√©taire` })\n                .setTimestamp();\n\n            await interaction.editReply({ embeds: [successEmbed] });\n\n            console.log(`üí∏ Owner transfer: ${amount.toFixed(8)} LTC from ${fromUser.username} to ${toUser.username} by ${interaction.user.username}`);\n\n        } catch (error) {\n            console.error('Owner transfer error:', error);\n\n            const errorEmbed = new EmbedBuilder()\n                .setColor('#e74c3c')\n                .setTitle('‚ùå Erreur de Transfert')\n                .setDescription('Une erreur est survenue lors du transfert.')\n                .setTimestamp();\n\n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};","size_bytes":5596},"commands/profile.js":{"content":"const { SlashCommandBuilder, EmbedBuilder } = require('discord.js');\nconst userProfiles = require('../utils/userProfiles.js');\nconst currencyConverter = require('../utils/currencyConverter.js');\nconst { formatLTC, formatUSD } = require('../utils/formatters.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('profile')\n        .setDescription('View your casino profile and balance'),\n    \n    async execute(interaction) {\n        // Check if interaction is too old (Discord timeout is 15 minutes)\n        const interactionAge = Date.now() - interaction.createdTimestamp;\n        if (interactionAge > 10 * 60 * 1000) { // 10 minutes safety margin\n            console.log('Interaction too old, ignored');\n            return;\n        }\n        \n        await interaction.deferReply();\n        \n        try {\n            const profile = userProfiles.getUserProfile(interaction.user.id);\n            \n            // Get recent deposit and withdrawal\n            const recentDeposit = profile.depositHistory.slice(-1)[0];\n            const recentWithdrawal = profile.withdrawalHistory.slice(-1)[0];\n            \n            // Try to get LTC price for reference\n            let ltcPrice = null;\n            try {\n                const priceData = await currencyConverter.getLitecoinPrice('USD');\n                ltcPrice = priceData.price;\n            } catch (error) {\n                console.log('Could not fetch LTC price:', error.message);\n            }\n            \n            const profileEmbed = new EmbedBuilder()\n                .setColor('#f7931a')\n                .setTitle('üé∞ Casino Profile')\n                .setAuthor({ \n                    name: interaction.user.username, \n                    iconURL: interaction.user.displayAvatarURL() \n                })\n                .addFields(\n                    { \n                        name: 'üí∞ Current Balance', \n                        value: `**${formatLTC(profile.balance)} LTC**${ltcPrice ? `\\n‚âà $${formatUSD(profile.balance * ltcPrice)} USD` : ''}`, \n                        inline: true \n                    },\n                    { \n                        name: 'üìä Statistics', \n                        value: `**Deposited:** ${formatLTC(profile.totalDeposited)} LTC\\n**Withdrawn:** ${formatLTC(profile.totalWithdrawn)} LTC\\n**Net:** ${formatLTC(profile.totalDeposited - profile.totalWithdrawn)} LTC`, \n                        inline: true \n                    },\n                    { \n                        name: 'üéÆ Activity', \n                        value: `**Deposits:** ${profile.depositHistory.length}\\n**Withdrawals:** ${profile.withdrawalHistory.length}\\n**Games Played:** ${profile.gameHistory.length}`, \n                        inline: true \n                    }\n                )\n                .setThumbnail('https://cryptologos.cc/logos/litecoin-ltc-logo.png')\n                .setFooter({ \n                    text: `Member since ${new Date(profile.createdAt).toLocaleDateString()}` \n                })\n                .setTimestamp();\n            \n            // Add recent activity if available\n            if (recentDeposit || recentWithdrawal) {\n                let recentActivity = '';\n                \n                if (recentDeposit) {\n                    const depositDate = new Date(recentDeposit.timestamp).toLocaleDateString();\n                    recentActivity += `üì• **Last Deposit:** ${formatLTC(recentDeposit.amount)} LTC (${depositDate})\\n`;\n                }\n                \n                if (recentWithdrawal) {\n                    const withdrawalDate = new Date(recentWithdrawal.timestamp).toLocaleDateString();\n                    recentActivity += `üì§ **Last Withdrawal:** ${formatLTC(recentWithdrawal.amount)} LTC (${withdrawalDate})`;\n                }\n                \n                profileEmbed.addFields({\n                    name: 'üìà Recent Activity',\n                    value: recentActivity,\n                    inline: false\n                });\n            }\n            \n            // Add addresses count if any\n            if (profile.addresses.length > 0) {\n                profileEmbed.addFields({\n                    name: 'üìç Linked Addresses',\n                    value: `${profile.addresses.length} Litecoin address(es)`,\n                    inline: true\n                });\n            }\n            \n            await interaction.editReply({ embeds: [profileEmbed] });\n            \n        } catch (error) {\n            console.error('Profile command error:', error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Error')\n                .setDescription('Failed to load your profile. Please try again.')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};","size_bytes":4908},"commands/recoverykey.js":{"content":"const { SlashCommandBuilder, EmbedBuilder } = require('discord.js');\nconst securityManager = require('../utils/securityManager.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('recoverykey')\n        .setDescription('View your recovery key (requires password)')\n        .addStringOption(option =>\n            option.setName('password')\n                .setDescription('Your account password')\n                .setRequired(true)\n        ),\n    \n    async execute(interaction) {\n        await interaction.deferReply({ ephemeral: true });\n        \n        try {\n            const password = interaction.options.getString('password');\n            \n            // Check if user has a password set\n            const userSec = securityManager.getUserSecurity(interaction.user.id);\n            if (!userSec.hasPassword) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå No Password Set')\n                    .setDescription('You need to set a password first using `/setpassword`.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Verify password\n            if (!securityManager.verifyUserPassword(interaction.user.id, password)) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Wrong Password')\n                    .setDescription('The password you entered is incorrect.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            const recoveryKeyEmbed = new EmbedBuilder()\n                .setColor('#f7931a')\n                .setTitle('üîë Your Recovery Key')\n                .setDescription('**Keep this key safe!** You need it to recover your account.')\n                .addFields(\n                    {\n                        name: 'üîê Recovery Key',\n                        value: `\\`${userSec.recoveryKey}\\``,\n                        inline: false\n                    },\n                    {\n                        name: '‚ö†Ô∏è Security Warning',\n                        value: 'Never share this key with anyone. Store it in a secure location offline.',\n                        inline: false\n                    },\n                    {\n                        name: 'üîÑ Reset Key',\n                        value: 'Use `/resetrecovery` if you want to generate a new recovery key.',\n                        inline: false\n                    }\n                )\n                .setFooter({ text: 'This message will delete automatically for security' })\n                .setTimestamp();\n            \n            const message = await interaction.editReply({ embeds: [recoveryKeyEmbed] });\n            \n            // Auto-delete the message after 30 seconds for security\n            setTimeout(async () => {\n                try {\n                    await message.delete();\n                } catch (error) {\n                    console.log('Could not delete recovery key message:', error.message);\n                }\n            }, 30000);\n            \n        } catch (error) {\n            console.error('Recovery key error:', error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Error')\n                .setDescription('Failed to retrieve recovery key. Please try again.')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};","size_bytes":3766},"commands/resetpassworduser.js":{"content":"const { SlashCommandBuilder, EmbedBuilder } = require('discord.js');\nconst userProfiles = require('../utils/userProfiles.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('resetpassworduser')\n        .setDescription('Reset password for any user (Bot Owner only)')\n        .addUserOption(option =>\n            option.setName('user')\n                .setDescription('User whose password to reset')\n                .setRequired(true)\n        ),\n    \n    async execute(interaction) {\n        // Check if interaction is too old\n        const interactionAge = Date.now() - interaction.createdTimestamp;\n        if (interactionAge > 10 * 60 * 1000) {\n            console.log('Interaction too old, ignored');\n            return;\n        }\n        \n        // Check if user is bot owner\n        const ownerId = process.env.OWNER_ID;\n        \n        if (!ownerId || interaction.user.id !== ownerId) {\n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Access Denied')\n                .setDescription('Only the bot owner can reset user passwords.')\n                .setTimestamp();\n            \n            await interaction.reply({ embeds: [errorEmbed], ephemeral: true });\n            return;\n        }\n        \n        await interaction.deferReply({ ephemeral: true });\n        \n        try {\n            const targetUser = interaction.options.getUser('user');\n            \n            // Check if user has a profile\n            const profile = userProfiles.getUserProfile(targetUser.id);\n            if (!profile) {\n                const noProfileEmbed = new EmbedBuilder()\n                    .setColor('#ffaa00')\n                    .setTitle('‚ö†Ô∏è User Not Found')\n                    .setDescription(`User ${targetUser.username} doesn't have a casino profile yet.`)\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [noProfileEmbed] });\n                return;\n            }\n            \n            // Reset password and recovery key\n            const resetResult = userProfiles.resetUserSecurity(targetUser.id);\n            \n            if (resetResult.success) {\n                const successEmbed = new EmbedBuilder()\n                    .setColor('#00ff00')\n                    .setTitle('‚úÖ Password Reset Complete')\n                    .setDescription(`Successfully reset security settings for ${targetUser.username}`)\n                    .addFields(\n                        {\n                            name: 'üë§ Target User',\n                            value: `${targetUser.username} (${targetUser.id})`,\n                            inline: false\n                        },\n                        {\n                            name: 'üîê Actions Taken',\n                            value: '‚Ä¢ Password cleared\\n‚Ä¢ Recovery key regenerated\\n‚Ä¢ User can now set new password with `/setpassword`',\n                            inline: false\n                        },\n                        {\n                            name: 'üîë New Recovery Key',\n                            value: `\\`${resetResult.newRecoveryKey}\\``,\n                            inline: false\n                        }\n                    )\n                    .setFooter({ text: 'Owner command executed' })\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [successEmbed] });\n                \n                console.log(`üîê Owner ${interaction.user.username} reset password for user ${targetUser.username} (${targetUser.id})`);\n                \n                // Try to notify the user via DM (optional)\n                try {\n                    const dmEmbed = new EmbedBuilder()\n                        .setColor('#0099ff')\n                        .setTitle('üîê Password Reset by Admin')\n                        .setDescription('Your casino password has been reset by an administrator.')\n                        .addFields(\n                            {\n                                name: 'üìù What to do next',\n                                value: '‚Ä¢ Use `/setpassword` to set a new password\\n‚Ä¢ Your balance and profile are safe',\n                                inline: false\n                            },\n                            {\n                                name: 'üîë Your New Recovery Key',\n                                value: `\\`${resetResult.newRecoveryKey}\\`\\n*Save this somewhere safe!*`,\n                                inline: false\n                            }\n                        )\n                        .setTimestamp();\n                    \n                    await targetUser.send({ embeds: [dmEmbed] });\n                    console.log(`üì© Notification DM envoy√©e √† ${targetUser.username}`);\n                } catch (dmError) {\n                    console.log(`‚ö†Ô∏è Impossible d'envoyer DM √† ${targetUser.username}: ${dmError.message}`);\n                }\n                \n            } else {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Reset Failed')\n                    .setDescription('Failed to reset user password. Please try again.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n            }\n            \n        } catch (error) {\n            console.error('Erreur resetpassworduser:', error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Error')\n                .setDescription('An error occurred while resetting the password.')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};","size_bytes":5886},"commands/resetrecovery.js":{"content":"const { SlashCommandBuilder, EmbedBuilder } = require('discord.js');\nconst securityManager = require('../utils/securityManager.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('resetrecovery')\n        .setDescription('Reset your recovery key (requires old key + password)')\n        .addStringOption(option =>\n            option.setName('oldkey')\n                .setDescription('Your current recovery key')\n                .setRequired(true)\n        )\n        .addStringOption(option =>\n            option.setName('password')\n                .setDescription('Your account password')\n                .setRequired(true)\n        ),\n    \n    async execute(interaction) {\n        await interaction.deferReply({ ephemeral: true });\n        \n        try {\n            const oldKey = interaction.options.getString('oldkey');\n            const password = interaction.options.getString('password');\n            \n            // Check if user has a password set\n            const userSec = securityManager.getUserSecurity(interaction.user.id);\n            if (!userSec.hasPassword) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå No Password Set')\n                    .setDescription('You need to set a password first using `/setpassword`.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Try to reset recovery key\n            const newRecoveryKey = securityManager.resetRecoveryKey(interaction.user.id, oldKey, password);\n            \n            if (!newRecoveryKey) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Reset Failed')\n                    .setDescription('Invalid recovery key or password. Both must be correct to reset.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            const successEmbed = new EmbedBuilder()\n                .setColor('#00ff00')\n                .setTitle('üîÑ Recovery Key Reset')\n                .setDescription('Your recovery key has been successfully reset.')\n                .addFields(\n                    {\n                        name: 'üîë New Recovery Key',\n                        value: `\\`${newRecoveryKey}\\``,\n                        inline: false\n                    },\n                    {\n                        name: '‚ö†Ô∏è IMPORTANT',\n                        value: '**Save this new recovery key immediately!** Your old key is no longer valid.',\n                        inline: false\n                    },\n                    {\n                        name: 'üîí Security',\n                        value: 'Store your new recovery key in a safe place. You will need it to recover your account.',\n                        inline: false\n                    }\n                )\n                .setFooter({ text: 'This message will delete automatically for security' })\n                .setTimestamp();\n            \n            const message = await interaction.editReply({ embeds: [successEmbed] });\n            \n            // Auto-delete the message after 45 seconds for security\n            setTimeout(async () => {\n                try {\n                    await message.delete();\n                } catch (error) {\n                    console.log('Could not delete reset recovery message:', error.message);\n                }\n            }, 45000);\n            \n        } catch (error) {\n            console.error('Reset recovery error:', error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Error')\n                .setDescription('Failed to reset recovery key. Please try again.')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};","size_bytes":4126},"commands/roulette.js":{"content":"const { SlashCommandBuilder, EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle, StringSelectMenuBuilder, ModalBuilder, TextInputBuilder, TextInputStyle } = require('discord.js');\nconst userProfiles = require('../utils/userProfiles.js');\nconst securityManager = require('../utils/securityManager.js');\nconst logManager = require('../utils/logManager.js');\nconst { formatLTC } = require('../utils/formatters.js');\n\n// Roulette wheel numbers and colors\nconst wheel = {\n    0: 'green',\n    1: 'red', 2: 'black', 3: 'red', 4: 'black', 5: 'red', 6: 'black',\n    7: 'red', 8: 'black', 9: 'red', 10: 'black', 11: 'black', 12: 'red',\n    13: 'black', 14: 'red', 15: 'black', 16: 'red', 17: 'black', 18: 'red',\n    19: 'red', 20: 'black', 21: 'red', 22: 'black', 23: 'red', 24: 'black',\n    25: 'red', 26: 'black', 27: 'red', 28: 'black', 29: 'black', 30: 'red',\n    31: 'black', 32: 'red', 33: 'black', 34: 'red', 35: 'black', 36: 'red'\n};\n\n// Live roulette sessions storage\nconst liveRouletteSessions = new Map();\n\n// GIF URLs\nconst SPINNING_GIF = 'https://images-ext-1.discordapp.net/external/u8-37Lffp-3TZre-_9pbURs23xL1L9wpWWCMZtFAQtc/https/raw.githubusercontent.com/GiorgosLiaskosds20076/RoulettePics/main/spinning_gif.gif';\nconst TABLE_IMAGE = 'https://raw.githubusercontent.com/GiorgosLiaskosds20076/RoulettePics/main/roulette_table.png';\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('roulette')\n        .setDescription('üé∞ Start a live roulette session!'),\n    \n    async execute(interaction) {\n        await interaction.deferReply({ ephemeral: false });\n        \n        try {\n            const userId = interaction.user.id;\n            const channelId = interaction.channel.id;\n            \n            // Check if there's already a live session in this channel\n            if (liveRouletteSessions.has(channelId)) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Session D√©j√† Active')\n                    .setDescription('Une session de roulette live est d√©j√† en cours dans ce canal!')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Check password protection\n            const userSec = securityManager.getUserSecurity(userId);\n            if (!userSec.hasPassword) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ffaa00')\n                    .setTitle('üîí Mot de Passe Requis')\n                    .setDescription('Vous devez d√©finir un mot de passe avant de jouer. Utilisez `/setpassword` d\\'abord.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Start live roulette session\n            await startLiveRouletteSession(interaction);\n            \n        } catch (error) {\n            console.error('Erreur roulette:', error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Erreur')\n                .setDescription('Une erreur est survenue lors du d√©marrage de la roulette.')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};\n\nfunction createBettingEmbed(spin, user) {\n    const embed = new EmbedBuilder()\n        .setColor('#9932cc')\n        .setTitle('üé∞ Roulette - Place Your Bets!')\n        .setDescription(`**Available to bet:** ${formatLTC(spin.bet)} LTC`)\n        .addFields(\n            {\n                name: 'üéØ How to Play',\n                value: '‚Ä¢ Choose your betting options below\\n‚Ä¢ Numbers pay 35:1\\n‚Ä¢ Colors (Red/Black) pay 1:1\\n‚Ä¢ Even/Odd pay 1:1\\n‚Ä¢ High/Low pay 1:1',\n                inline: false\n            },\n            {\n                name: 'üí∞ Current Bets',\n                value: spin.bets.size > 0 ? formatBets(spin.bets) : 'No bets placed yet',\n                inline: false\n            }\n        )\n        .setFooter({ text: 'Select your bets below, then click Spin!' })\n        .setTimestamp();\n    \n    return embed;\n}\n\nfunction createBettingComponents() {\n    const colorRow = new ActionRowBuilder()\n        .addComponents(\n            new ButtonBuilder()\n                .setCustomId('roulette_bet_red')\n                .setLabel('Red (1:1)')\n                .setStyle(ButtonStyle.Danger)\n                .setEmoji('üî¥'),\n            new ButtonBuilder()\n                .setCustomId('roulette_bet_black')\n                .setLabel('Black (1:1)')\n                .setStyle(ButtonStyle.Secondary)\n                .setEmoji('‚ö´'),\n            new ButtonBuilder()\n                .setCustomId('roulette_bet_green')\n                .setLabel('Green (35:1)')\n                .setStyle(ButtonStyle.Success)\n                .setEmoji('üü¢')\n        );\n    \n    const oddEvenRow = new ActionRowBuilder()\n        .addComponents(\n            new ButtonBuilder()\n                .setCustomId('roulette_bet_even')\n                .setLabel('Even (1:1)')\n                .setStyle(ButtonStyle.Primary)\n                .setEmoji('2Ô∏è‚É£'),\n            new ButtonBuilder()\n                .setCustomId('roulette_bet_odd')\n                .setLabel('Odd (1:1)')\n                .setStyle(ButtonStyle.Primary)\n                .setEmoji('1Ô∏è‚É£'),\n            new ButtonBuilder()\n                .setCustomId('roulette_bet_low')\n                .setLabel('Low 1-18 (1:1)')\n                .setStyle(ButtonStyle.Primary)\n                .setEmoji('üîΩ'),\n            new ButtonBuilder()\n                .setCustomId('roulette_bet_high')\n                .setLabel('High 19-36 (1:1)')\n                .setStyle(ButtonStyle.Primary)\n                .setEmoji('üîº')\n        );\n    \n    const numberSelect1 = new ActionRowBuilder()\n        .addComponents(\n            new StringSelectMenuBuilder()\n                .setCustomId('roulette_bet_number_1')\n                .setPlaceholder('Numbers 0-24 (35:1 payout)')\n                .addOptions(\n                    Array.from({ length: 25 }, (_, i) => ({\n                        label: `Number ${i}`,\n                        value: `number_${i}`,\n                        description: `Bet on ${i} (35:1 payout)`,\n                        emoji: i === 0 ? 'üü¢' : (wheel[i] === 'red' ? 'üî¥' : '‚ö´')\n                    }))\n                )\n        );\n        \n    const numberSelect2 = new ActionRowBuilder()\n        .addComponents(\n            new StringSelectMenuBuilder()\n                .setCustomId('roulette_bet_number_2')\n                .setPlaceholder('Numbers 25-36 (35:1 payout)')\n                .addOptions(\n                    Array.from({ length: 12 }, (_, i) => {\n                        const num = i + 25;\n                        return {\n                            label: `Number ${num}`,\n                            value: `number_${num}`,\n                            description: `Bet on ${num} (35:1 payout)`,\n                            emoji: wheel[num] === 'red' ? 'üî¥' : '‚ö´'\n                        };\n                    })\n                )\n        );\n    \n    const actionRow = new ActionRowBuilder()\n        .addComponents(\n            new ButtonBuilder()\n                .setCustomId('roulette_spin')\n                .setLabel('üé∞ SPIN!')\n                .setStyle(ButtonStyle.Success)\n                .setEmoji('üé∞'),\n            new ButtonBuilder()\n                .setCustomId('roulette_clear')\n                .setLabel('Clear Bets')\n                .setStyle(ButtonStyle.Secondary)\n                .setEmoji('üóëÔ∏è'),\n            new ButtonBuilder()\n                .setCustomId('roulette_cancel')\n                .setLabel('Cancel')\n                .setStyle(ButtonStyle.Danger)\n                .setEmoji('‚ùå')\n        );\n    \n    // Add dozens and columns betting\n    const dozensRow = new ActionRowBuilder()\n        .addComponents(\n            new ButtonBuilder()\n                .setCustomId('roulette_bet_dozen1')\n                .setLabel('1st Dozen (1-12)')\n                .setStyle(ButtonStyle.Secondary)\n                .setEmoji('1Ô∏è‚É£'),\n            new ButtonBuilder()\n                .setCustomId('roulette_bet_dozen2')\n                .setLabel('2nd Dozen (13-24)')\n                .setStyle(ButtonStyle.Secondary)\n                .setEmoji('2Ô∏è‚É£'),\n            new ButtonBuilder()\n                .setCustomId('roulette_bet_dozen3')\n                .setLabel('3rd Dozen (25-36)')\n                .setStyle(ButtonStyle.Secondary)\n                .setEmoji('3Ô∏è‚É£')\n        );\n\n    return [colorRow, oddEvenRow, dozensRow, numberSelect1, actionRow];\n}\n\nfunction formatBets(bets) {\n    let betString = '';\n    let totalBet = 0;\n    \n    for (const [betType, amount] of bets) {\n        betString += `‚Ä¢ **${betType}**: ${formatLTC(amount)} LTC\\n`;\n        totalBet += amount;\n    }\n    \n    betString += `\\n**Total Bet**: ${formatLTC(totalBet)} LTC`;\n    return betString;\n}\n\n// Create modal for specific bet type\nfunction createBetModal(betType) {\n    const modal = new ModalBuilder()\n        .setCustomId(`live_roulette_modal_${betType}`)\n        .setTitle(`Add ${betType.charAt(0).toUpperCase() + betType.slice(1)} Bet`);\n    \n    let choiceInput, amountInput;\n    \n    if (betType === 'number') {\n        choiceInput = new TextInputBuilder()\n            .setCustomId('bet_choice')\n            .setLabel('Num√©ros (s√©par√©s par virgule et espace)')\n            .setStyle(TextInputStyle.Short)\n            .setPlaceholder('Ex: 7, 12, 19')\n            .setRequired(true);\n    } else if (betType === 'color') {\n        choiceInput = new TextInputBuilder()\n            .setCustomId('bet_choice')\n            .setLabel('Couleur (red ou black)')\n            .setStyle(TextInputStyle.Short)\n            .setPlaceholder('red ou black')\n            .setRequired(true);\n    } else if (betType === 'dozen') {\n        choiceInput = new TextInputBuilder()\n            .setCustomId('bet_choice')\n            .setLabel('Douzaine (1st12, 2nd12, ou 3rd12)')\n            .setStyle(TextInputStyle.Short)\n            .setPlaceholder('1st12, 2nd12, ou 3rd12')\n            .setRequired(true);\n    } else if (betType === 'column') {\n        choiceInput = new TextInputBuilder()\n            .setCustomId('bet_choice')\n            .setLabel('Colonne (1st column, 2nd column, ou 3rd column)')\n            .setStyle(TextInputStyle.Short)\n            .setPlaceholder('1st column, 2nd column, ou 3rd column')\n            .setRequired(true);\n    } else if (betType === 'evenodd') {\n        choiceInput = new TextInputBuilder()\n            .setCustomId('bet_choice')\n            .setLabel('Pair ou Impair (even ou odd)')\n            .setStyle(TextInputStyle.Short)\n            .setPlaceholder('even ou odd')\n            .setRequired(true);\n    } else if (betType === 'range') {\n        choiceInput = new TextInputBuilder()\n            .setCustomId('bet_choice')\n            .setLabel('Range (1-18 ou 19-36)')\n            .setStyle(TextInputStyle.Short)\n            .setPlaceholder('1-18 ou 19-36')\n            .setRequired(true);\n    }\n    \n    amountInput = new TextInputBuilder()\n        .setCustomId('bet_amount')\n        .setLabel('Montant en LTC')\n        .setStyle(TextInputStyle.Short)\n        .setPlaceholder('Ex: 0.01')\n        .setRequired(true);\n    \n    const choiceRow = new ActionRowBuilder().addComponents(choiceInput);\n    const amountRow = new ActionRowBuilder().addComponents(amountInput);\n    \n    modal.addComponents(choiceRow, amountRow);\n    return modal;\n}\n\n// Spin the wheel\nfunction spinWheel() {\n    return Math.floor(Math.random() * 37);\n}\n\n// Perform the spin with animation\nasync function performSpin(interaction, session) {\n    // Calculate total bets and check balances\n    let totalBetAmount = 0;\n    const userBets = new Map();\n    \n    for (const [userId, bets] of session.pendingBets) {\n        let userTotal = 0;\n        for (const bet of bets) {\n            userTotal += bet.amount;\n        }\n        userBets.set(userId, userTotal);\n        totalBetAmount += userTotal;\n    }\n    \n    // Deduct bets from user balances and add wagered amounts\n    for (const [userId, amount] of userBets) {\n        const profile = userProfiles.getUserProfile(userId);\n        userProfiles.updateUserProfile(userId, { \n            balance: profile.balance - amount \n        });\n        securityManager.addWageredAmount(userId, amount);\n    }\n    \n    // Show spinning animation\n    const spinningEmbed = new EmbedBuilder()\n        .setColor('#ff6600')\n        .setTitle('Mont Olympus Casino | Roulette')\n        .setDescription('üåÄ **LA ROULETTE TOURNE!** üåÄ')\n        .setImage(SPINNING_GIF)\n        .addFields(\n            { name: 'üé≤ Statut', value: 'La bille tourne...', inline: false }\n        )\n        .setTimestamp();\n    \n    await interaction.editReply({ embeds: [spinningEmbed], components: [] });\n    \n    // Wait for animation\n    await new Promise(resolve => setTimeout(resolve, 3000));\n    \n    // Generate result\n    const result = spinWheel();\n    \n    // Calculate payouts for all users\n    let totalPayouts = 0;\n    const allWinnings = new Map();\n    \n    for (const [userId, bets] of session.pendingBets) {\n        const { totalPayout, winningBets } = calculatePayout(bets, result);\n        if (totalPayout > 0) {\n            allWinnings.set(userId, { totalPayout, winningBets });\n            totalPayouts += totalPayout;\n            \n            // Update user balance with winnings\n            const profile = userProfiles.getUserProfile(userId);\n            userProfiles.updateUserProfile(userId, { \n                balance: profile.balance + totalPayout \n            });\n        }\n    }\n    \n    // Show final result\n    await showFinalResult(interaction, result, session, allWinnings, totalBetAmount);\n    \n    // Clean up session\n    liveRouletteSessions.delete(session.channelId);\n}\n\n// Show final result with winning number and image\nasync function showFinalResult(interaction, result, session, allWinnings, totalBetAmount) {\n    const resultColor = wheel[result];\n    const colorEmoji = resultColor === 'red' ? 'üî¥' : resultColor === 'black' ? '‚ö´' : 'üü¢';\n    \n    let title = 'üé∞ R√©sultat de la Roulette';\n    let color = '#9932cc';\n    let description = `üéØ **La bille s'est arr√™t√©e sur le ${result}** ${colorEmoji}`;\n    \n    const totalWinnings = Array.from(allWinnings.values()).reduce((sum, w) => sum + w.totalPayout, 0);\n    \n    if (totalWinnings > 0) {\n        title = 'üéâ F√âLICITATIONS ! Il y a des gagnants !';\n        color = '#00ff00';\n        description += `\\n\\nüí∞ **Gains totaux distribu√©s: ${formatLTC(totalWinnings)} LTC**`;\n    } else {\n        title = 'üí∏ La Maison Gagne';\n        color = '#ff0000';\n        description += `\\n\\nüíî **Perdu: ${formatLTC(totalBetAmount)} LTC**`;\n    }\n    \n    const embed = new EmbedBuilder()\n        .setColor(color)\n        .setTitle(title)\n        .setDescription(description)\n        .setImage(TABLE_IMAGE) // This should show the roulette table with a white dot on the winning number\n        .addFields(\n            {\n                name: 'üéØ Num√©ro Gagnant',\n                value: `**${result}** ${colorEmoji} (${resultColor === 'red' ? 'Rouge' : resultColor === 'black' ? 'Noir' : 'Vert'})`,\n                inline: true\n            }\n        )\n        .setTimestamp();\n    \n    // Add individual winners if any\n    if (allWinnings.size > 0) {\n        let winnersText = '';\n        for (const [userId, data] of allWinnings) {\n            const user = await interaction.client.users.fetch(userId);\n            winnersText += `‚Ä¢ **${user.username}**: ${formatLTC(data.totalPayout)} LTC\\n`;\n        }\n        embed.addFields({\n            name: 'üèÜ Gagnants',\n            value: winnersText,\n            inline: false\n        });\n    }\n    \n    await interaction.editReply({ embeds: [embed], components: [] });\n    \n    // Log the game for each participant\n    for (const [userId, bets] of session.pendingBets) {\n        const user = await interaction.client.users.fetch(userId);\n        const userBetAmount = bets.reduce((sum, bet) => sum + bet.amount, 0);\n        const userWinnings = allWinnings.get(userId)?.totalPayout || 0;\n        \n        await logManager.sendGamblingLog(interaction.client, interaction.guild.id, {\n            type: 'roulette',\n            user: user,\n            game: 'roulette',\n            bet: userBetAmount,\n            result: userWinnings > 0 ? 'win' : 'lose',\n            payout: userWinnings,\n            details: `R√©sultat: ${result} ${colorEmoji}, ${bets.length} paris plac√©s`\n        });\n    }\n}\n\nfunction calculatePayout(bets, result) {\n    let totalPayout = 0;\n    const winningBets = [];\n    \n    for (const bet of bets) {\n        let won = false;\n        let multiplier = 0;\n        \n        if (bet.type === 'number') {\n            // Check if any of the numbers won\n            if (bet.details.includes(result)) {\n                won = true;\n                multiplier = 35;\n            }\n        } else if (bet.type === 'color') {\n            if ((bet.details === 'red' && wheel[result] === 'red') ||\n                (bet.details === 'black' && wheel[result] === 'black')) {\n                won = true;\n                multiplier = 1;\n            }\n        } else if (bet.type === 'dozen') {\n            if ((bet.details === '1st12' && result >= 1 && result <= 12) ||\n                (bet.details === '2nd12' && result >= 13 && result <= 24) ||\n                (bet.details === '3rd12' && result >= 25 && result <= 36)) {\n                won = true;\n                multiplier = 2;\n            }\n        } else if (bet.type === 'column') {\n            // Column logic: 1st column (1,4,7,10,13,16,19,22,25,28,31,34)\n            // 2nd column (2,5,8,11,14,17,20,23,26,29,32,35)\n            // 3rd column (3,6,9,12,15,18,21,24,27,30,33,36)\n            if (result > 0) {\n                const column = ((result - 1) % 3) + 1;\n                if ((bet.details === '1st column' && column === 1) ||\n                    (bet.details === '2nd column' && column === 2) ||\n                    (bet.details === '3rd column' && column === 3)) {\n                    won = true;\n                    multiplier = 2;\n                }\n            }\n        } else if (bet.type === 'evenodd') {\n            if (result > 0) {\n                if ((bet.details === 'even' && result % 2 === 0) ||\n                    (bet.details === 'odd' && result % 2 === 1)) {\n                    won = true;\n                    multiplier = 1;\n                }\n            }\n        } else if (bet.type === 'range') {\n            if ((bet.details === '1-18' && result >= 1 && result <= 18) ||\n                (bet.details === '19-36' && result >= 19 && result <= 36)) {\n                won = true;\n                multiplier = 1;\n            }\n        }\n        \n        if (won) {\n            const payout = bet.amount * (multiplier + 1);\n            totalPayout += payout;\n            winningBets.push({ ...bet, payout, multiplier });\n        }\n    }\n    \n    return { totalPayout, winningBets };\n}\n\n// Export session map and functions for button handlers\nmodule.exports.liveRouletteSessions = liveRouletteSessions;\nmodule.exports.createBetModal = createBetModal;\nmodule.exports.performSpin = performSpin;\nmodule.exports.endLiveRouletteSession = endLiveRouletteSession;\n\n","size_bytes":19590},"commands/setlogbal.js":{"content":"const { SlashCommandBuilder, EmbedBuilder, PermissionFlagsBits, ChannelType } = require('discord.js');\nconst fs = require('fs');\nconst path = require('path');\n\nconst CONFIG_FILE = path.join(__dirname, '../data/log_config.json');\n\n// Ensure data directory exists\nconst dataDir = path.join(__dirname, '../data');\nif (!fs.existsSync(dataDir)) {\n    fs.mkdirSync(dataDir, { recursive: true });\n}\n\nfunction loadLogConfig() {\n    try {\n        if (fs.existsSync(CONFIG_FILE)) {\n            const data = fs.readFileSync(CONFIG_FILE, 'utf8');\n            return JSON.parse(data);\n        }\n    } catch (error) {\n        console.error('Error loading log config:', error.message);\n    }\n    return {};\n}\n\nfunction saveLogConfig(config) {\n    try {\n        fs.writeFileSync(CONFIG_FILE, JSON.stringify(config, null, 2));\n        console.log('‚úÖ Log config saved');\n    } catch (error) {\n        console.error('Error saving log config:', error.message);\n    }\n}\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('setlogbal')\n        .setDescription('Configure balance log channel (Admin only)')\n        .addChannelOption(option =>\n            option.setName('channel')\n                .setDescription('Channel to send balance logs to')\n                .setRequired(true)\n                .addChannelTypes(ChannelType.GuildText)\n        )\n        .setDefaultMemberPermissions(PermissionFlagsBits.Administrator),\n    \n    async execute(interaction) {\n        // Check if interaction is too old\n        const interactionAge = Date.now() - interaction.createdTimestamp;\n        if (interactionAge > 10 * 60 * 1000) {\n            console.log('Interaction too old, ignored');\n            return;\n        }\n        \n        await interaction.deferReply({ ephemeral: true });\n        \n        try {\n            const channel = interaction.options.getChannel('channel');\n            const serverId = interaction.guild.id;\n            \n            // Load config\n            const config = loadLogConfig();\n            \n            if (!config[serverId]) {\n                config[serverId] = {};\n            }\n            \n            config[serverId].balanceLogChannel = channel.id;\n            \n            // Save config\n            saveLogConfig(config);\n            \n            const successEmbed = new EmbedBuilder()\n                .setColor('#00ff00')\n                .setTitle('‚úÖ Balance Log Channel Set')\n                .setDescription(`Balance logs will now be sent to ${channel}`)\n                .addFields(\n                    {\n                        name: 'üìã Configuration Details',\n                        value: `**Channel:** ${channel}\\n**Channel ID:** \\`${channel.id}\\`\\n**Server:** ${interaction.guild.name}`,\n                        inline: false\n                    },\n                    {\n                        name: 'üìù What gets logged',\n                        value: '‚Ä¢ Deposit confirmations\\n‚Ä¢ Balance additions\\n‚Ä¢ Deposit channel closures\\n‚Ä¢ Address generations',\n                        inline: false\n                    }\n                )\n                .setFooter({ text: `Configured by ${interaction.user.username}` })\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [successEmbed] });\n            \n            // Send test message to the log channel\n            try {\n                const testEmbed = new EmbedBuilder()\n                    .setColor('#0099ff')\n                    .setTitle('üîß Balance Log Channel Configured')\n                    .setDescription('This channel has been set up to receive balance logs from the casino bot.')\n                    .addFields(\n                        {\n                            name: '‚öôÔ∏è Configured by',\n                            value: `${interaction.user} (${interaction.user.username})`,\n                            inline: false\n                        }\n                    )\n                    .setTimestamp();\n                \n                await channel.send({ embeds: [testEmbed] });\n            } catch (channelError) {\n                console.log('Could not send test message to log channel:', channelError.message);\n            }\n            \n            console.log(`üìù Balance log channel set to ${channel.name} for server ${interaction.guild.name}`);\n            \n        } catch (error) {\n            console.error('Erreur setlogbal:', error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Error')\n                .setDescription('An error occurred while setting the log channel.')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};","size_bytes":4784},"commands/setloggamble.js":{"content":"const { SlashCommandBuilder, EmbedBuilder, PermissionFlagsBits, ChannelType } = require('discord.js');\nconst fs = require('fs');\nconst path = require('path');\n\nconst CONFIG_FILE = path.join(__dirname, '../data/log_config.json');\n\n// Ensure data directory exists\nconst dataDir = path.join(__dirname, '../data');\nif (!fs.existsSync(dataDir)) {\n    fs.mkdirSync(dataDir, { recursive: true });\n}\n\nfunction loadLogConfig() {\n    try {\n        if (fs.existsSync(CONFIG_FILE)) {\n            const data = fs.readFileSync(CONFIG_FILE, 'utf8');\n            return JSON.parse(data);\n        }\n    } catch (error) {\n        console.error('Error loading log config:', error.message);\n    }\n    return {};\n}\n\nfunction saveLogConfig(config) {\n    try {\n        fs.writeFileSync(CONFIG_FILE, JSON.stringify(config, null, 2));\n        console.log('‚úÖ Log config saved');\n    } catch (error) {\n        console.error('Error saving log config:', error.message);\n    }\n}\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('setloggamble')\n        .setDescription('Configure gambling log channel (Admin only)')\n        .addChannelOption(option =>\n            option.setName('channel')\n                .setDescription('Channel to send gambling logs to')\n                .setRequired(true)\n                .addChannelTypes(ChannelType.GuildText)\n        )\n        .setDefaultMemberPermissions(PermissionFlagsBits.Administrator),\n    \n    async execute(interaction) {\n        // Check if interaction is too old\n        const interactionAge = Date.now() - interaction.createdTimestamp;\n        if (interactionAge > 10 * 60 * 1000) {\n            console.log('Interaction too old, ignored');\n            return;\n        }\n        \n        await interaction.deferReply({ ephemeral: true });\n        \n        try {\n            const channel = interaction.options.getChannel('channel');\n            const serverId = interaction.guild.id;\n            \n            // Load config\n            const config = loadLogConfig();\n            \n            if (!config[serverId]) {\n                config[serverId] = {};\n            }\n            \n            config[serverId].gamblingLogChannel = channel.id;\n            \n            // Save config\n            saveLogConfig(config);\n            \n            const successEmbed = new EmbedBuilder()\n                .setColor('#00ff00')\n                .setTitle('‚úÖ Gambling Log Channel Set')\n                .setDescription(`Gambling logs will now be sent to ${channel}`)\n                .addFields(\n                    {\n                        name: 'üìã Configuration Details',\n                        value: `**Channel:** ${channel}\\n**Channel ID:** \\`${channel.id}\\`\\n**Server:** ${interaction.guild.name}`,\n                        inline: false\n                    },\n                    {\n                        name: 'üé∞ What gets logged',\n                        value: '‚Ä¢ Blackjack games and results\\n‚Ä¢ Roulette spins and payouts\\n‚Ä¢ Big wins and losses\\n‚Ä¢ Suspicious gambling patterns',\n                        inline: false\n                    }\n                )\n                .setFooter({ text: `Configured by ${interaction.user.username}` })\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [successEmbed] });\n            \n            // Send test message to the log channel\n            try {\n                const testEmbed = new EmbedBuilder()\n                    .setColor('#9932cc')\n                    .setTitle('üé∞ Gambling Log Channel Configured')\n                    .setDescription('This channel has been set up to receive gambling logs from the casino bot.')\n                    .addFields(\n                        {\n                            name: '‚öôÔ∏è Configured by',\n                            value: `${interaction.user} (${interaction.user.username})`,\n                            inline: false\n                        }\n                    )\n                    .setTimestamp();\n                \n                await channel.send({ embeds: [testEmbed] });\n            } catch (channelError) {\n                console.log('Could not send test message to gambling log channel:', channelError.message);\n            }\n            \n            console.log(`üé∞ Gambling log channel set to ${channel.name} for server ${interaction.guild.name}`);\n            \n        } catch (error) {\n            console.error('Erreur setloggamble:', error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Error')\n                .setDescription('An error occurred while setting the gambling log channel.')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};","size_bytes":4835},"commands/setpanel.js":{"content":"const { SlashCommandBuilder, EmbedBuilder, PermissionFlagsBits } = require('discord.js');\nconst panelManager = require('../utils/panelManager.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('setpanel')\n        .setDescription('Configure a casino panel in a channel')\n        .addStringOption(option =>\n            option.setName('type')\n                .setDescription('Type of panel to create')\n                .setRequired(true)\n                .addChoices(\n                    { name: 'üé∞ Casino Main Panel', value: 'casinoPanel' },\n                    { name: 'üí∞ Add Balance Panel', value: 'addBalancePanel' }\n                )\n        )\n        .addChannelOption(option =>\n            option.setName('channel')\n                .setDescription('Channel to send the panel to')\n                .setRequired(true)\n        )\n        .addChannelOption(option =>\n            option.setName('ticket_category')\n                .setDescription('Category for creating ticket channels')\n                .setRequired(false)\n        )\n        .addRoleOption(option =>\n            option.setName('staff_role')\n                .setDescription('Staff role that can see tickets')\n                .setRequired(false)\n        )\n        .setDefaultMemberPermissions(PermissionFlagsBits.Administrator),\n    \n    async execute(interaction) {\n        // Check if interaction is too old\n        const interactionAge = Date.now() - interaction.createdTimestamp;\n        if (interactionAge > 10 * 60 * 1000) {\n            console.log('Interaction too old, ignored');\n            return;\n        }\n        \n        await interaction.deferReply({ ephemeral: true });\n        \n        try {\n            const panelType = interaction.options.getString('type');\n            const channel = interaction.options.getChannel('channel');\n            const ticketCategory = interaction.options.getChannel('ticket_category');\n            const staffRole = interaction.options.getRole('staff_role');\n            \n            // Validate channel type\n            if (channel.type !== 0) { // Not a text channel\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Invalid Channel')\n                    .setDescription('Please select a text channel for the panel.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Validate category if provided\n            if (ticketCategory && ticketCategory.type !== 4) { // Not a category\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Invalid Category')\n                    .setDescription('Please select a channel category for tickets.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Save configuration\n            const success = panelManager.setPanelChannel(\n                panelType,\n                channel.id,\n                ticketCategory?.id,\n                staffRole?.id\n            );\n            \n            if (!success) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Configuration Failed')\n                    .setDescription('Failed to save panel configuration.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Create and send the panel\n            const panelEmbed = await createPanelEmbed(panelType, interaction.guild);\n            const components = await createPanelComponents(panelType);\n            \n            try {\n                const message = await channel.send({ \n                    embeds: [panelEmbed], \n                    components: components \n                });\n                \n                // Save message ID\n                panelManager.setPanelMessageId(panelType, message.id);\n                \n                const successEmbed = new EmbedBuilder()\n                    .setColor('#00ff00')\n                    .setTitle('‚úÖ Panel Created')\n                    .setDescription(`${getPanelName(panelType)} has been sent to ${channel}`)\n                    .addFields(\n                        {\n                            name: 'üìã Configuration',\n                            value: `**Channel:** ${channel}\\n**Ticket Category:** ${ticketCategory || 'Not set'}\\n**Staff Role:** ${staffRole || 'Not set'}`,\n                            inline: false\n                        }\n                    )\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [successEmbed] });\n                \n            } catch (sendError) {\n                console.error('Panel send error:', sendError);\n                \n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Send Failed')\n                    .setDescription('Failed to send panel to channel. Check bot permissions.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n            }\n            \n        } catch (error) {\n            console.error('Setpanel error:', error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Error')\n                .setDescription('Failed to configure panel.')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};\n\n/**\n * Create panel embed based on type\n */\nasync function createPanelEmbed(panelType, guild) {\n    const { EmbedBuilder } = require('discord.js');\n    \n    if (panelType === 'casinoPanel') {\n        return new EmbedBuilder()\n            .setColor('#f7931a')\n            .setTitle('üé∞ Welcome to the Casino!')\n            .setDescription('Click the buttons below to start your casino experience.')\n            .addFields(\n                {\n                    name: 'üí∞ Add Balance',\n                    value: 'Generate a unique Litecoin address for deposits',\n                    inline: true\n                },\n                {\n                    name: 'üë§ View Profile',\n                    value: 'Check your balance and casino statistics',\n                    inline: true\n                },\n                {\n                    name: 'üèÜ Leaderboard',\n                    value: 'See the top players and rankings',\n                    inline: true\n                },\n                {\n                    name: 'üéÆ Games Available Soon',\n                    value: '‚Ä¢ üÉè Blackjack\\n‚Ä¢ üé≤ Roulette\\n‚Ä¢ üé∞ Slots',\n                    inline: false\n                }\n            )\n            .setThumbnail('https://cryptologos.cc/logos/litecoin-ltc-logo.png')\n            .setFooter({ \n                text: `${guild.name} Casino ‚Ä¢ Powered by Litecoin`,\n                iconURL: guild.iconURL() \n            })\n            .setTimestamp();\n    }\n    \n    if (panelType === 'addBalancePanel') {\n        return new EmbedBuilder()\n            .setColor('#00ff00')\n            .setTitle('üí∞ Add Balance to Your Casino Account')\n            .setDescription('Click the button below to get a unique deposit address and start playing!')\n            .addFields(\n                {\n                    name: '‚ö° Instant Detection',\n                    value: 'Deposits are detected within 30 seconds',\n                    inline: true\n                },\n                {\n                    name: 'üîí Secure',\n                    value: 'Each deposit gets a unique address',\n                    inline: true\n                },\n                {\n                    name: 'üìà Minimum Deposit',\n                    value: '0.001 LTC',\n                    inline: true\n                }\n            )\n            .setThumbnail('https://cryptologos.cc/logos/litecoin-ltc-logo.png')\n            .setFooter({ \n                text: `${guild.name} Casino ‚Ä¢ Safe & Secure`,\n                iconURL: guild.iconURL() \n            })\n            .setTimestamp();\n    }\n}\n\n/**\n * Create panel components based on type\n */\nasync function createPanelComponents(panelType) {\n    const { ActionRowBuilder, ButtonBuilder, ButtonStyle } = require('discord.js');\n    \n    if (panelType === 'casinoPanel') {\n        return [\n            new ActionRowBuilder()\n                .addComponents(\n                    new ButtonBuilder()\n                        .setCustomId('panel_add_balance')\n                        .setLabel('üí∞ Add Balance')\n                        .setStyle(ButtonStyle.Success)\n                        .setEmoji('üí∞'),\n                    new ButtonBuilder()\n                        .setCustomId('panel_view_profile')\n                        .setLabel('üë§ View Profile')\n                        .setStyle(ButtonStyle.Primary)\n                        .setEmoji('üë§'),\n                    new ButtonBuilder()\n                        .setCustomId('panel_leaderboard')\n                        .setLabel('üèÜ Leaderboard')\n                        .setStyle(ButtonStyle.Secondary)\n                        .setEmoji('üèÜ')\n                ),\n            new ActionRowBuilder()\n                .addComponents(\n                    new ButtonBuilder()\n                        .setCustomId('panel_games_blackjack')\n                        .setLabel('üÉè Blackjack')\n                        .setStyle(ButtonStyle.Secondary)\n                        .setEmoji('üÉè')\n                        .setDisabled(true),\n                    new ButtonBuilder()\n                        .setCustomId('panel_games_roulette')\n                        .setLabel('üé≤ Roulette')\n                        .setStyle(ButtonStyle.Secondary)\n                        .setEmoji('üé≤')\n                        .setDisabled(true),\n                    new ButtonBuilder()\n                        .setCustomId('panel_games_slots')\n                        .setLabel('üé∞ Slots')\n                        .setStyle(ButtonStyle.Secondary)\n                        .setEmoji('üé∞')\n                        .setDisabled(true)\n                )\n        ];\n    }\n    \n    if (panelType === 'addBalancePanel') {\n        return [\n            new ActionRowBuilder()\n                .addComponents(\n                    new ButtonBuilder()\n                        .setCustomId('panel_add_balance')\n                        .setLabel('üí∞ Get Deposit Address')\n                        .setStyle(ButtonStyle.Success)\n                        .setEmoji('üí∞')\n                )\n        ];\n    }\n    \n    return [];\n}\n\n/**\n * Get friendly panel name\n */\nfunction getPanelName(panelType) {\n    const names = {\n        'casinoPanel': 'üé∞ Casino Main Panel',\n        'addBalancePanel': 'üí∞ Add Balance Panel'\n    };\n    return names[panelType] || panelType;\n}","size_bytes":11265},"commands/setpassword.js":{"content":"const { SlashCommandBuilder, EmbedBuilder } = require('discord.js');\nconst securityManager = require('../utils/securityManager.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('setpassword')\n        .setDescription('Set your account password (required for security features)')\n        .addStringOption(option =>\n            option.setName('password')\n                .setDescription('Your new password (minimum 6 characters)')\n                .setRequired(true)\n        ),\n    \n    async execute(interaction) {\n        await interaction.deferReply({ ephemeral: true });\n        \n        try {\n            const password = interaction.options.getString('password');\n            \n            // Validate password\n            if (password.length < 6) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Invalid Password')\n                    .setDescription('Password must be at least 6 characters long.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Check if user already has a password\n            const userSec = securityManager.getUserSecurity(interaction.user.id);\n            if (userSec.hasPassword) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Password Already Set')\n                    .setDescription('You already have a password set. Use `/changepassword` to change it.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Set password and generate recovery key\n            const recoveryKey = securityManager.setUserPassword(interaction.user.id, password);\n            \n            const successEmbed = new EmbedBuilder()\n                .setColor('#00ff00')\n                .setTitle('üîí Password Set Successfully')\n                .setDescription('Your password has been set and your recovery key has been generated.')\n                .addFields(\n                    {\n                        name: 'üîë Recovery Key',\n                        value: `\\`${recoveryKey}\\``,\n                        inline: false\n                    },\n                    {\n                        name: '‚ö†Ô∏è IMPORTANT',\n                        value: '**Save this recovery key immediately!** You need it to recover your account if you lose access. Store it in a safe place.',\n                        inline: false\n                    },\n                    {\n                        name: 'üõ°Ô∏è Security Features Unlocked',\n                        value: '‚Ä¢ View recovery key with password\\n‚Ä¢ Enable gambling sessions\\n‚Ä¢ Secure cashout protection\\n‚Ä¢ Account recovery',\n                        inline: false\n                    }\n                )\n                .setThumbnail('https://em-content.zobj.net/thumbs/120/twitter/351/locked_1f512.png')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [successEmbed] });\n            \n        } catch (error) {\n            console.error('Set password error:', error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Error')\n                .setDescription('Failed to set password. Please try again.')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};","size_bytes":3699},"commands/stopallactives.js":{"content":"const { SlashCommandBuilder, EmbedBuilder, PermissionFlagsBits } = require('discord.js');\nconst securityManager = require('../utils/securityManager.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('stopallactives')\n        .setDescription('Stop all active deposits monitoring (Admin only)')\n        .setDefaultMemberPermissions(PermissionFlagsBits.Administrator),\n    \n    async execute(interaction) {\n        // Check if interaction is too old\n        const interactionAge = Date.now() - interaction.createdTimestamp;\n        if (interactionAge > 10 * 60 * 1000) {\n            console.log('Interaction too old, ignored');\n            return;\n        }\n        \n        await interaction.deferReply({ ephemeral: true });\n        \n        try {\n            // Get all active deposits before clearing\n            const activeDeposits = securityManager.getAllActiveDeposits();\n            const activeCount = activeDeposits.length;\n            \n            if (activeCount === 0) {\n                const noActiveEmbed = new EmbedBuilder()\n                    .setColor('#ffaa00')\n                    .setTitle('‚ÑπÔ∏è No Active Deposits')\n                    .setDescription('There are no active deposits to stop.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [noActiveEmbed] });\n                return;\n            }\n            \n            // Clear all active deposits\n            const success = securityManager.clearAllActiveDeposits();\n            \n            if (success) {\n                // Stop monitoring\n                const { stopSmartMonitoring } = require('../discord-bot.js');\n                stopSmartMonitoring();\n                \n                const successEmbed = new EmbedBuilder()\n                    .setColor('#00ff00')\n                    .setTitle('‚úÖ All Active Deposits Stopped')\n                    .setDescription(`Successfully stopped monitoring for **${activeCount}** active deposit(s).`)\n                    .addFields(\n                        {\n                            name: 'üõë Actions Taken',\n                            value: '‚Ä¢ All active deposits cleared\\n‚Ä¢ Smart monitoring stopped\\n‚Ä¢ Users will need to generate new addresses',\n                            inline: false\n                        },\n                        {\n                            name: '‚ö†Ô∏è Note',\n                            value: 'Users with pending deposits will need to use `/casino` again to generate new addresses.',\n                            inline: false\n                        }\n                    )\n                    .setFooter({ text: `Executed by ${interaction.user.username}` })\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [successEmbed] });\n                \n                console.log(`üõë Admin ${interaction.user.username} stopped ${activeCount} active deposits`);\n                \n            } else {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Failed to Stop')\n                    .setDescription('Failed to clear active deposits. Please try again.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n            }\n            \n        } catch (error) {\n            console.error('Erreur stopallactives:', error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Error')\n                .setDescription('An error occurred while stopping active deposits.')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};","size_bytes":3846},"commands/testgamble.js":{"content":"const { SlashCommandBuilder, EmbedBuilder } = require('discord.js');\nconst securityManager = require('../utils/securityManager.js');\nconst userProfiles = require('../utils/userProfiles.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('testgamble')\n        .setDescription('Test gambling command to simulate wagering (requires active session)')\n        .addNumberOption(option =>\n            option.setName('amount')\n                .setDescription('Amount to wager in LTC')\n                .setRequired(true)\n                .setMinValue(0.001)\n        ),\n    \n    async execute(interaction) {\n        await interaction.deferReply({ ephemeral: true });\n        \n        try {\n            const amount = interaction.options.getNumber('amount');\n            const userId = interaction.user.id;\n            \n            // Check if user has active gambling session\n            if (!securityManager.hasActiveGamblingSession(userId)) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå No Active Session')\n                    .setDescription('You need to enable a gambling session first using `/enable`.')\n                    .addFields({\n                        name: 'üîí How to Start',\n                        value: 'Use `/enable [minutes] [password]` to start a gambling session.',\n                        inline: false\n                    })\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Check user balance\n            const profile = userProfiles.getUserProfile(userId);\n            \n            if (profile.balance < amount) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Insufficient Balance')\n                    .setDescription('You don\\'t have enough balance to wager this amount.')\n                    .addFields({\n                        name: 'üí∞ Available Balance',\n                        value: `${profile.balance.toFixed(8)} LTC`,\n                        inline: true\n                    })\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Simulate gambling result (50/50 chance for testing)\n            const won = Math.random() > 0.5;\n            const resultAmount = won ? amount * 1.8 : 0; // 1.8x payout if win\n            \n            // Update balance\n            const newBalance = profile.balance - amount + resultAmount;\n            userProfiles.updateUserProfile(userId, { balance: newBalance });\n            \n            // Add wagered amount (for cashout protection)\n            securityManager.addWageredAmount(userId, amount);\n            \n            // Check new cashout status\n            const cashoutStatus = securityManager.canUserCashout(userId);\n            \n            const resultEmbed = new EmbedBuilder()\n                .setColor(won ? '#00ff00' : '#ff0000')\n                .setTitle(won ? 'üéâ You Won!' : 'üíî You Lost!')\n                .setDescription(`Test gambling result: ${won ? 'WIN' : 'LOSS'}`)\n                .addFields(\n                    {\n                        name: 'üé≤ Game Result',\n                        value: `**Wagered:** ${amount.toFixed(8)} LTC\\n**${won ? 'Won' : 'Lost'}:** ${resultAmount.toFixed(8)} LTC\\n**Net:** ${(resultAmount - amount).toFixed(8)} LTC`,\n                        inline: true\n                    },\n                    {\n                        name: 'üí∞ Balance Update',\n                        value: `**Previous:** ${profile.balance.toFixed(8)} LTC\\n**Current:** ${newBalance.toFixed(8)} LTC`,\n                        inline: true\n                    },\n                    {\n                        name: 'üìä Cashout Status',\n                        value: `**Progress:** ${cashoutStatus.wageredPercent.toFixed(1)}%\\n**Can Cashout:** ${cashoutStatus.canCashout ? '‚úÖ Yes' : '‚ùå No'}\\n**Remaining:** ${cashoutStatus.remainingToWager.toFixed(8)} LTC`,\n                        inline: false\n                    }\n                )\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [resultEmbed] });\n            \n            console.log(`üé≤ ${interaction.user.username} ${won ? 'won' : 'lost'} ${amount} LTC - Balance: ${newBalance.toFixed(8)} LTC`);\n            \n        } catch (error) {\n            console.error('Test gamble error:', error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Game Error')\n                .setDescription('An error occurred during the game. Please try again.')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};","size_bytes":5045},"deploy-commands.js":{"content":"const { REST, Routes } = require('discord.js');\nconst fs = require('fs');\nconst path = require('path');\n\n// Load environment variables\nrequire('dotenv').config();\n\nconst commands = [];\n\n// Load all command files\nconst commandsPath = path.join(__dirname, 'commands');\nconst commandFiles = fs.readdirSync(commandsPath).filter(file => file.endsWith('.js'));\n\nfor (const file of commandFiles) {\n    const filePath = path.join(commandsPath, file);\n    const command = require(filePath);\n    \n    if ('data' in command && 'execute' in command) {\n        commands.push(command.data.toJSON());\n        console.log(`‚úÖ Loaded command: ${command.data.name}`);\n    } else {\n        console.log(`‚ö†Ô∏è  Command ${file} is missing required properties`);\n    }\n}\n\n// Deploy commands\nasync function deployCommands() {\n    const token = process.env.DISCORD_TOKEN;\n    const clientId = process.env.DISCORD_CLIENT_ID;\n    const guildId = process.env.DISCORD_GUILD_ID; // Optional: for guild-specific commands\n    \n    if (!token) {\n        console.error('‚ùå DISCORD_TOKEN is required!');\n        process.exit(1);\n    }\n    \n    if (!clientId) {\n        console.error('‚ùå DISCORD_CLIENT_ID is required!');\n        process.exit(1);\n    }\n    \n    const rest = new REST().setToken(token);\n    \n    try {\n        console.log(`üîÑ Started refreshing ${commands.length} application (/) commands.`);\n        \n        let data;\n        \n        if (guildId) {\n            // Deploy to specific guild (faster for development)\n            data = await rest.put(\n                Routes.applicationGuildCommands(clientId, guildId),\n                { body: commands },\n            );\n            console.log(`‚úÖ Successfully reloaded ${data.length} guild commands for guild ${guildId}.`);\n        } else {\n            // Deploy globally (takes up to 1 hour to propagate)\n            data = await rest.put(\n                Routes.applicationCommands(clientId),\n                { body: commands },\n            );\n            console.log(`‚úÖ Successfully reloaded ${data.length} global application commands.`);\n        }\n        \n    } catch (error) {\n        console.error('‚ùå Error deploying commands:', error);\n    }\n}\n\n// Run deployment if this file is executed directly\nif (require.main === module) {\n    deployCommands();\n}\n\nmodule.exports = { deployCommands };","size_bytes":2341},"discord-bot.js":{"content":"const { Client, GatewayIntentBits, Collection, EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle, Events } = require('discord.js');\nconst fs = require('fs');\nconst path = require('path');\n\n// Import Litecoin wallet system\nconst ltcWallet = require('./litecoin-casino-bot.js');\nconst LiveRoulette = require('./utils/liveRoulette.js');\n\n// Create Discord client\nconst client = new Client({\n    intents: [\n        GatewayIntentBits.Guilds,\n        GatewayIntentBits.GuildMessages,\n        GatewayIntentBits.MessageContent,\n        GatewayIntentBits.GuildMembers\n    ]\n});\n\n// Initialize live roulette\nconst liveRoulette = new LiveRoulette(client);\n\n// Commands collection\nclient.commands = new Collection();\n\n// Load commands\nconst commandsPath = path.join(__dirname, 'commands');\nif (fs.existsSync(commandsPath)) {\n    const commandFiles = fs.readdirSync(commandsPath).filter(file => file.endsWith('.js'));\n    \n    for (const file of commandFiles) {\n        const filePath = path.join(commandsPath, file);\n        const command = require(filePath);\n        \n        if ('data' in command && 'execute' in command) {\n            client.commands.set(command.data.name, command);\n            console.log(`‚úÖ Command loaded: ${command.data.name}`);\n        } else {\n            console.log(`‚ö†Ô∏è  Command ${file} missing required properties`);\n        }\n    }\n}\n\n// Load events\nconst eventsPath = path.join(__dirname, 'events');\nif (fs.existsSync(eventsPath)) {\n    const eventFiles = fs.readdirSync(eventsPath).filter(file => file.endsWith('.js'));\n    \n    for (const file of eventFiles) {\n        const filePath = path.join(eventsPath, file);\n        const event = require(filePath);\n        \n        if (event.once) {\n            client.once(event.name, (...args) => event.execute(...args));\n        } else {\n            client.on(event.name, (...args) => event.execute(...args));\n        }\n        console.log(`‚úÖ Event loaded: ${event.name}`);\n    }\n}\n\n\n// Interaction handling\nclient.on(Events.InteractionCreate, async interaction => {\n    // Handle slash commands\n    if (interaction.isChatInputCommand()) {\n        const command = client.commands.get(interaction.commandName);\n        \n        if (!command) {\n            console.error(`‚ùå No command matching ${interaction.commandName} found.`);\n            return;\n        }\n        \n        try {\n            await command.execute(interaction);\n        } catch (error) {\n            console.error(`‚ùå Error executing ${interaction.commandName}:`, error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Error')\n                .setDescription('There was an error while executing this command!')\n                .setTimestamp();\n            \n            if (interaction.replied || interaction.deferred) {\n                await interaction.followUp({ embeds: [errorEmbed], ephemeral: true });\n            } else {\n                await interaction.reply({ embeds: [errorEmbed], ephemeral: true });\n            }\n        }\n    }\n    \n    // Handle button interactions\n    if (interaction.isButton()) {\n        console.log(`üîò Button interaction: ${interaction.customId}`);\n        try {\n            // Add Balance button\n            if (interaction.customId === 'add_balance') {\n                await handleAddBalance(interaction);\n            }\n            // Create channel button\n            else if (interaction.customId === 'create_channel') {\n                await handleCreateChannel(interaction);\n            }\n            // Re-add balance button\n            else if (interaction.customId === 'readd_balance') {\n                await handleAddBalance(interaction);\n            }\n            // Close channel button\n            else if (interaction.customId === 'close_channel') {\n                await handleCloseChannel(interaction);\n            }\n            // Blackjack game buttons\n            else if (interaction.customId.startsWith('blackjack_')) {\n                await handleBlackjackInteraction(interaction);\n            }\n            // Roulette game buttons\n            else if (interaction.customId.startsWith('roulette_')) {\n                await handleRouletteInteraction(interaction);\n            }\n            // Casino game quick start buttons\n            else if (interaction.customId === 'casino_blackjack') {\n                console.log('üÉè Casino blackjack button clicked');\n                await handleCasinoBlackjack(interaction);\n            }\n            else if (interaction.customId === 'casino_roulette') {\n                console.log('üé∞ Casino roulette button clicked');\n                await handleCasinoRoulette(interaction);\n            }\n            // Game explanation buttons\n            else if (interaction.customId === 'explain_blackjack') {\n                await handleExplainBlackjack(interaction);\n            }\n            else if (interaction.customId === 'explain_roulette') {\n                await handleExplainRoulette(interaction);\n            }\n            else if (interaction.customId === 'explain_coinflip') {\n                await handleExplainCoinflip(interaction);\n            }\n            // Private session button\n            else if (interaction.customId === 'create_private_session') {\n                await handleCreatePrivateSession(interaction);\n            }\n            // Channel management buttons\n            else if (interaction.customId === 'close_channel') {\n                await handleCloseChannel(interaction);\n            }\n            else if (interaction.customId === 'close_session') {\n                await handleCloseSession(interaction);\n            }\n            // Live roulette buttons\n            else if (interaction.customId.startsWith('live_roulette_')) {\n                await handleLiveRouletteBet(interaction);\n            }\n            // Coinflip progression buttons\n            else if (interaction.customId.startsWith('coinflip_double_')) {\n                await handleCoinflipDouble(interaction);\n            }\n            else if (interaction.customId === 'coinflip_cashout') {\n                await handleCoinflipCashout(interaction);\n            }\n            // Other button handlers can be added here\n            else {\n                console.log(`‚ùì Unknown button interaction: ${interaction.customId}`);\n            }\n        } catch (error) {\n            console.error('‚ùå Button interaction error:', error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Error')\n                .setDescription('There was an error processing your request!')\n                .setTimestamp();\n            \n            if (interaction.replied || interaction.deferred) {\n                await interaction.followUp({ embeds: [errorEmbed], ephemeral: true });\n            } else {\n                await interaction.reply({ embeds: [errorEmbed], ephemeral: true });\n            }\n        }\n    }\n    \n    // Handle select menu interactions\n    if (interaction.isStringSelectMenu()) {\n        try {\n            // Roulette number selection\n            if (interaction.customId === 'roulette_bet_number') {\n                await handleRouletteNumberBet(interaction);\n            }\n        } catch (error) {\n            console.error('‚ùå Menu interaction error:', error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Error')\n                .setDescription('There was an error processing your selection!')\n                .setTimestamp();\n            \n            if (interaction.replied || interaction.deferred) {\n                await interaction.followUp({ embeds: [errorEmbed], ephemeral: true });\n            } else {\n                await interaction.reply({ embeds: [errorEmbed], ephemeral: true });\n            }\n        }\n    }\n});\n\n// Add Balance handler\nasync function handleAddBalance(interaction) {\n    await interaction.deferReply({ ephemeral: true });\n    \n    try {\n        const guild = interaction.guild;\n        const user = interaction.user;\n        const channelManager = require('./utils/channelManager.js');\n        const { ChannelType, PermissionsBitField } = require('discord.js');\n        \n        // Generate new LTC address for each deposit request (always new address)\n        const newAddress = ltcWallet.generateAddress();\n        \n        if (!newAddress) {\n            throw new Error('Failed to generate Litecoin address');\n        }\n        \n        // Get add balance category from config\n        const fs = require('fs');\n        let config = {};\n        try {\n            if (fs.existsSync('./data/server_config.json')) {\n                const allConfigs = JSON.parse(fs.readFileSync('./data/server_config.json', 'utf8'));\n                config = allConfigs[guild.id] || {};\n            }\n        } catch (error) {\n            console.error('Error loading server config:', error);\n        }\n        \n        // Get category\n        const categoryId = config.addBalanceCategory;\n        let category = null;\n        if (categoryId) {\n            category = guild.channels.cache.get(categoryId);\n        }\n        \n        // Generate unique channel name\n        const channelName = channelManager.getNextBalanceChannelName();\n        \n        // Create private deposit channel\n        const depositChannel = await guild.channels.create({\n            name: channelName,\n            type: ChannelType.GuildText,\n            parent: category,\n            topic: `Deposit channel for ${user.username} - Auto-closes in 20 minutes`,\n            permissionOverwrites: [\n                {\n                    id: guild.id,\n                    deny: [PermissionsBitField.Flags.ViewChannel]\n                },\n                {\n                    id: user.id,\n                    allow: [PermissionsBitField.Flags.ViewChannel, PermissionsBitField.Flags.SendMessages, PermissionsBitField.Flags.ReadMessageHistory]\n                }\n            ]\n        });\n        \n        // Register channel\n        channelManager.registerChannel(depositChannel.id, user.id, 'deposit');\n        \n        // Link address to user and add to active deposits monitoring\n        const userProfiles = require('./utils/userProfiles.js');\n        const securityManager = require('./utils/securityManager.js');\n        const logManager = require('./utils/logManager.js');\n        \n        await userProfiles.linkAddressToUser(user.id, newAddress.address);\n        securityManager.addActiveDeposit(user.id, newAddress.address, 0);\n        \n        // Log address generation\n        await logManager.sendBalanceLog(client, guild.id, {\n            type: 'address_generated',\n            user: user,\n            address: newAddress.address\n        });\n        \n        // Start smart monitoring for this deposit\n        startSmartMonitoring();\n        \n        // Send deposit info to the private channel\n        const depositEmbed = new EmbedBuilder()\n            .setColor('#f7931a')\n            .setTitle('üí∞ Deposit Information')\n            .setDescription('Send Litecoin to the address below to add balance to your account:')\n            .addFields(\n                { name: 'üìç Deposit Address', value: `\\`${newAddress.address}\\``, inline: false },\n                { name: '‚è±Ô∏è Detection Time', value: 'Deposits detected within 30 seconds', inline: true },\n                { name: 'üîí Security', value: 'This address is unique to this deposit', inline: true },\n                { name: 'üìà Minimum Deposit', value: '0.001 LTC', inline: true },\n                { name: '‚ö†Ô∏è Important', value: '‚Ä¢ Your balance will be added once payment is confirmed\\n‚Ä¢ If no deposit is made within 20 minutes, this channel will auto-close\\n‚Ä¢ Contact staff if you experience any issues', inline: false }\n            )\n            .setThumbnail('https://cryptologos.cc/logos/litecoin-ltc-logo.png')\n            .setFooter({ text: 'Casino Bot ‚Ä¢ Smart Monitoring Active' })\n            .setTimestamp();\n            \n        const { ActionRowBuilder, ButtonBuilder, ButtonStyle } = require('discord.js');\n        const actionRow = new ActionRowBuilder()\n            .addComponents(\n                new ButtonBuilder()\n                    .setCustomId('close_channel')\n                    .setLabel('Close Channel')\n                    .setStyle(ButtonStyle.Danger)\n                    .setEmoji('‚ùå')\n            );\n        \n        await depositChannel.send({ \n            content: `${user}, your private deposit channel has been created!`,\n            embeds: [depositEmbed],\n            components: [actionRow]\n        });\n        \n        // Auto-close channel after 20 minutes\n        setTimeout(async () => {\n            try {\n                await depositChannel.delete('Auto-close after 20 minutes');\n                channelManager.unregisterChannel(depositChannel.id);\n            } catch (error) {\n                console.error('Error auto-closing deposit channel:', error);\n            }\n        }, 20 * 60 * 1000);\n        \n        // Reply to user\n        const responseEmbed = new EmbedBuilder()\n            .setColor('#00ff00')\n            .setTitle('‚úÖ Deposit Channel Created')\n            .setDescription(`Your private deposit channel has been created: ${depositChannel}`)\n            .addFields({\n                name: '‚è∞ Auto-Close',\n                value: 'Channel will automatically close in 20 minutes if unused',\n                inline: false\n            })\n            .setTimestamp();\n            \n        await interaction.editReply({ embeds: [responseEmbed] });\n        \n        console.log(`üîç Deposit channel created for ${user.username}: ${depositChannel.name}`);\n        \n    } catch (error) {\n        console.error('‚ùå Add balance error:', error);\n        \n        const errorEmbed = new EmbedBuilder()\n            .setColor('#ff0000')\n            .setTitle('‚ùå Error')\n            .setDescription('Failed to create deposit channel. Please try again.')\n            .setTimestamp();\n        \n        await interaction.editReply({ embeds: [errorEmbed] });\n    }\n}\n\n// Create Channel handler\nasync function handleCreateChannel(interaction) {\n    await interaction.deferReply({ ephemeral: false });\n    \n    try {\n        const guild = interaction.guild;\n        const user = interaction.user;\n        \n        // Check if user already has a channel\n        const existingChannel = guild.channels.cache.find(channel => \n            channel.name === `casino-${user.username.toLowerCase()}` && \n            channel.type === 0 // Text channel\n        );\n        \n        if (existingChannel) {\n            const alreadyExistsEmbed = new EmbedBuilder()\n                .setColor('#ffaa00')\n                .setTitle('‚ö†Ô∏è Channel Already Exists')\n                .setDescription(`You already have a private channel: ${existingChannel}`)\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [alreadyExistsEmbed] });\n            return;\n        }\n        \n        // Create private channel\n        const channel = await guild.channels.create({\n            name: `casino-${user.username.toLowerCase()}`,\n            type: 0, // Text channel\n            topic: `Private casino session for ${user.username}`,\n            permissionOverwrites: [\n                {\n                    id: guild.id,\n                    deny: ['ViewChannel', 'SendMessages']\n                },\n                {\n                    id: user.id,\n                    allow: ['ViewChannel', 'SendMessages', 'ReadMessageHistory']\n                }\n                // Add staff role permissions here if needed\n                // {\n                //     id: 'STAFF_ROLE_ID',\n                //     allow: ['ViewChannel', 'SendMessages', 'ReadMessageHistory']\n                // }\n            ]\n        });\n        \n        const successEmbed = new EmbedBuilder()\n            .setColor('#00ff00')\n            .setTitle('‚úÖ Private Channel Created')\n            .setDescription(`Your private casino channel has been created: ${channel}`)\n            .addFields(\n                { name: 'üé∞ Features Available', value: '‚Ä¢ Check balance\\n‚Ä¢ Play casino games\\n‚Ä¢ Withdraw funds\\n‚Ä¢ Get support', inline: false },\n                { name: '‚è∞ Auto-Delete', value: 'Channel will be deleted after 24 hours of inactivity', inline: false }\n            )\n            .setTimestamp();\n        \n        await interaction.editReply({ embeds: [successEmbed] });\n        \n        // Send welcome message in the new channel\n        const welcomeEmbed = new EmbedBuilder()\n            .setColor('#f7931a')\n            .setTitle('üé∞ Welcome to Your Private Casino!')\n            .setDescription(`Hello ${user}! This is your private casino session.`)\n            .addFields(\n                { name: 'üí∞ Available Commands', value: '‚Ä¢ `/profile` - View your profile\\n‚Ä¢ `/balance` - Check balance\\n‚Ä¢ `/givebal` - Transfer balance\\n‚Ä¢ `/convert-eur-usd` - Currency converter', inline: false },\n                { name: 'üéÆ Coming Soon', value: '‚Ä¢ Blackjack\\n‚Ä¢ Roulette\\n‚Ä¢ Slots', inline: true },\n                { name: 'üîß Support', value: 'Need help? Staff can access this channel.', inline: true }\n            )\n            .setThumbnail(user.displayAvatarURL())\n            .setTimestamp();\n        \n        await channel.send({ embeds: [welcomeEmbed] });\n        \n        console.log(`üè† Private channel created: ${channel.name} for ${user.username}`);\n        \n        // Auto-close channel after 20 minutes\n        setTimeout(async () => {\n            try {\n                const logManager = require('./utils/logManager.js');\n                await logManager.sendBalanceLog(client, interaction.guild.id, {\n                    type: 'channel_closed',\n                    user: interaction.user,\n                    details: 'Auto-close after 20 minutes'\n                });\n                \n                await channel.delete('Auto-close after 20 minutes');\n                console.log(`üîí Auto-closed channel ${channel.name} after 20 minutes`);\n            } catch (autoCloseError) {\n                console.error('Error auto-closing channel:', autoCloseError);\n            }\n        }, 20 * 60 * 1000); // 20 minutes\n        \n    } catch (error) {\n        console.error('‚ùå Create channel error:', error);\n        \n        const errorEmbed = new EmbedBuilder()\n            .setColor('#ff0000')\n            .setTitle('‚ùå Error')\n            .setDescription('Failed to create private channel. Please contact staff.')\n            .setTimestamp();\n        \n        await interaction.editReply({ embeds: [errorEmbed] });\n    }\n}\n\n// Close Channel handler\nasync function handleCloseChannel(interaction) {\n    await interaction.deferReply({ ephemeral: false });\n    \n    try {\n        const channel = interaction.channel;\n        \n        // Log channel closure\n        const logManager = require('./utils/logManager.js');\n        await logManager.sendBalanceLog(client, interaction.guild.id, {\n            type: 'channel_closed',\n            user: interaction.user,\n            details: 'Manually closed by user'\n        });\n        \n        const confirmEmbed = new EmbedBuilder()\n            .setColor('#ff6600')\n            .setTitle('üîí Channel Closing')\n            .setDescription('This channel will be deleted in 5 seconds...')\n            .setTimestamp();\n        \n        await interaction.editReply({ embeds: [confirmEmbed] });\n        \n        // Delete channel after 5 seconds\n        setTimeout(async () => {\n            try {\n                await channel.delete('Manually closed by user');\n                console.log(`üîí Channel ${channel.name} closed by ${interaction.user.username}`);\n            } catch (deleteError) {\n                console.error('Error deleting channel:', deleteError);\n            }\n        }, 5000);\n        \n    } catch (error) {\n        console.error('‚ùå Close channel error:', error);\n        \n        const errorEmbed = new EmbedBuilder()\n            .setColor('#ff0000')\n            .setTitle('‚ùå Error')\n            .setDescription('Unable to close the channel. Please try again.')\n            .setTimestamp();\n        \n        await interaction.editReply({ embeds: [errorEmbed] });\n    }\n}\n\n// Blackjack interaction handler\nasync function handleBlackjackInteraction(interaction) {\n    const { activeGames, calculateHandValue, dealCard, createGameEmbed, createGameButtons } = require('./commands/blackjack.js');\n    const userProfiles = require('./utils/userProfiles.js');\n    const securityManager = require('./utils/securityManager.js');\n    const logManager = require('./utils/logManager.js');\n    const { formatLTC } = require('./utils/formatters.js');\n    \n    await interaction.deferUpdate();\n    \n    const userId = interaction.user.id;\n    const game = activeGames.get(userId);\n    \n    if (!game || game.status !== 'playing') {\n        return;\n    }\n    \n    try {\n        if (interaction.customId === 'blackjack_hit') {\n            // Player hits\n            game.playerHand.push(dealCard(game));\n            game.playerValue = calculateHandValue(game.playerHand);\n            game.canDoubleDown = false;\n            \n            if (game.playerValue > 21) {\n                game.status = 'lost';\n                activeGames.delete(userId);\n                \n                // Log the game\n                await logManager.sendGamblingLog(client, interaction.guild.id, {\n                    type: 'blackjack',\n                    user: interaction.user,\n                    game: 'blackjack',\n                    bet: game.bet,\n                    result: 'lose',\n                    payout: 0,\n                    details: `Player busted with ${game.playerValue}`\n                });\n            }\n            \n        } else if (interaction.customId === 'blackjack_stand') {\n            // Player stands - dealer plays\n            while (game.dealerValue < 17) {\n                game.dealerHand.push(dealCard(game));\n                game.dealerValue = calculateHandValue(game.dealerHand);\n            }\n            \n            // Determine winner\n            let payout = 0;\n            if (game.dealerValue > 21) {\n                game.status = 'won';\n                payout = game.bet * 2;\n            } else if (game.playerValue > game.dealerValue) {\n                game.status = 'won';\n                payout = game.bet * 2;\n            } else if (game.playerValue < game.dealerValue) {\n                game.status = 'lost';\n                payout = 0;\n            } else {\n                game.status = 'push';\n                payout = game.bet; // Return bet\n            }\n            \n            // Update balance\n            if (payout > 0) {\n                const profile = userProfiles.getUserProfile(userId);\n                userProfiles.updateUserProfile(userId, { \n                    balance: profile.balance + payout \n                });\n            }\n            \n            // Log the game\n            await logManager.sendGamblingLog(client, interaction.guild.id, {\n                type: 'blackjack',\n                user: interaction.user,\n                game: 'blackjack',\n                bet: game.bet,\n                result: game.status === 'won' ? 'win' : game.status === 'lost' ? 'lose' : 'push',\n                payout: payout,\n                details: `Player: ${game.playerValue}, Dealer: ${game.dealerValue}`\n            });\n            \n            activeGames.delete(userId);\n            \n        } else if (interaction.customId === 'blackjack_double') {\n            // Player doubles down\n            const profile = userProfiles.getUserProfile(userId);\n            if (profile.balance >= game.bet) {\n                userProfiles.updateUserProfile(userId, { \n                    balance: profile.balance - game.bet \n                });\n                securityManager.addWageredAmount(userId, game.bet);\n                \n                game.bet *= 2;\n                game.playerHand.push(dealCard(game));\n                game.playerValue = calculateHandValue(game.playerHand);\n                \n                if (game.playerValue > 21) {\n                    game.status = 'lost';\n                } else {\n                    // Dealer plays\n                    while (game.dealerValue < 17) {\n                        game.dealerHand.push(dealCard(game));\n                        game.dealerValue = calculateHandValue(game.dealerHand);\n                    }\n                    \n                    // Determine winner\n                    let payout = 0;\n                    if (game.dealerValue > 21 || game.playerValue > game.dealerValue) {\n                        game.status = 'won';\n                        payout = game.bet * 2;\n                    } else if (game.playerValue < game.dealerValue) {\n                        game.status = 'lost';\n                        payout = 0;\n                    } else {\n                        game.status = 'push';\n                        payout = game.bet;\n                    }\n                    \n                    if (payout > 0) {\n                        const updatedProfile = userProfiles.getUserProfile(userId);\n                        userProfiles.updateUserProfile(userId, { \n                            balance: updatedProfile.balance + payout \n                        });\n                    }\n                }\n                \n                // Log the game\n                await logManager.sendGamblingLog(client, interaction.guild.id, {\n                    type: 'blackjack',\n                    user: interaction.user,\n                    game: 'blackjack',\n                    bet: game.bet,\n                    result: game.status === 'won' ? 'win' : game.status === 'lost' ? 'lose' : 'push',\n                    payout: payout || 0,\n                    details: `Double Down - Player: ${game.playerValue}, Dealer: ${game.dealerValue}`\n                });\n                \n                activeGames.delete(userId);\n            }\n        }\n        \n        // Update the game display\n        const gameEmbed = createGameEmbed(game, interaction.user);\n        const gameButtons = createGameButtons(game);\n        \n        await interaction.editReply({ \n            embeds: [gameEmbed],\n            components: game.status === 'playing' ? [gameButtons] : []\n        });\n        \n    } catch (error) {\n        console.error('Erreur blackjack interaction:', error);\n    }\n}\n\n// Roulette interaction handler\nasync function handleRouletteInteraction(interaction) {\n    const { activeSpins, spinWheel, calculatePayout, createResultEmbed, createBettingEmbed, createBettingComponents } = require('./commands/roulette.js');\n    const userProfiles = require('./utils/userProfiles.js');\n    const securityManager = require('./utils/securityManager.js');\n    const logManager = require('./utils/logManager.js');\n    const { formatLTC } = require('./utils/formatters.js');\n    \n    await interaction.deferUpdate();\n    \n    const userId = interaction.user.id;\n    const spin = activeSpins.get(userId);\n    \n    if (!spin || spin.status !== 'betting') {\n        return;\n    }\n    \n    try {\n        if (interaction.customId === 'roulette_spin') {\n            if (spin.bets.size === 0) {\n                return; // No bets placed\n            }\n            \n            // Deduct total bet amount\n            let totalBet = 0;\n            for (const [, amount] of spin.bets) {\n                totalBet += amount;\n            }\n            \n            const profile = userProfiles.getUserProfile(userId);\n            userProfiles.updateUserProfile(userId, { \n                balance: profile.balance - totalBet \n            });\n            securityManager.addWageredAmount(userId, totalBet);\n            \n            // Spin the wheel\n            const result = spinWheel();\n            const { totalPayout, winningBets } = calculatePayout(spin.bets, result);\n            \n            // Add winnings to balance\n            if (totalPayout > 0) {\n                const updatedProfile = userProfiles.getUserProfile(userId);\n                userProfiles.updateUserProfile(userId, { \n                    balance: updatedProfile.balance + totalPayout \n                });\n            }\n            \n            // Log the game\n            await logManager.sendGamblingLog(client, interaction.guild.id, {\n                type: 'roulette',\n                user: interaction.user,\n                game: 'roulette',\n                bet: totalBet,\n                result: totalPayout > 0 ? 'win' : 'lose',\n                payout: totalPayout,\n                details: `Number ${result}, Total Bet: ${formatLTC(totalBet)} LTC`\n            });\n            \n            // Check for big win (5x or more)\n            if (totalPayout >= totalBet * 5) {\n                await logManager.sendGamblingLog(client, interaction.guild.id, {\n                    type: 'big_win',\n                    user: interaction.user,\n                    game: 'roulette',\n                    bet: totalBet,\n                    result: 'win',\n                    payout: totalPayout\n                });\n            }\n            \n            spin.status = 'finished';\n            spin.result = result;\n            spin.totalPayout = totalPayout;\n            \n            const resultEmbed = createResultEmbed(spin, result, totalPayout, winningBets, interaction.user);\n            \n            await interaction.editReply({ \n                embeds: [resultEmbed],\n                components: []\n            });\n            \n            activeSpins.delete(userId);\n            \n        } else if (interaction.customId === 'roulette_clear') {\n            spin.bets.clear();\n            const bettingEmbed = createBettingEmbed(spin, interaction.user);\n            const bettingComponents = createBettingComponents();\n            \n            await interaction.editReply({ \n                embeds: [bettingEmbed],\n                components: bettingComponents\n            });\n            \n        } else if (interaction.customId === 'roulette_cancel') {\n            activeSpins.delete(userId);\n            \n            const cancelEmbed = new EmbedBuilder()\n                .setColor('#ff6600')\n                .setTitle('üö´ Roulette Cancelled')\n                .setDescription('Your roulette game has been cancelled.')\n                .setTimestamp();\n            \n            await interaction.editReply({ \n                embeds: [cancelEmbed],\n                components: []\n            });\n            \n        } else {\n            // Handle bet buttons\n            const betType = interaction.customId.replace('roulette_bet_', '');\n            const betAmount = spin.bet / 4; // Split bet into quarters\n            \n            if (spin.bets.has(betType)) {\n                spin.bets.set(betType, spin.bets.get(betType) + betAmount);\n            } else {\n                spin.bets.set(betType, betAmount);\n            }\n            \n            const bettingEmbed = createBettingEmbed(spin, interaction.user);\n            const bettingComponents = createBettingComponents();\n            \n            await interaction.editReply({ \n                embeds: [bettingEmbed],\n                components: bettingComponents\n            });\n        }\n        \n    } catch (error) {\n        console.error('Erreur roulette interaction:', error);\n    }\n}\n\n// Roulette number bet handler\nasync function handleRouletteNumberBet(interaction) {\n    const { activeSpins, createBettingEmbed, createBettingComponents } = require('./commands/roulette.js');\n    \n    await interaction.deferUpdate();\n    \n    const userId = interaction.user.id;\n    const spin = activeSpins.get(userId);\n    \n    if (!spin || spin.status !== 'betting') {\n        return;\n    }\n    \n    try {\n        const selectedValue = interaction.values[0];\n        const betAmount = spin.bet / 4; // Split bet into quarters\n        \n        if (spin.bets.has(selectedValue)) {\n            spin.bets.set(selectedValue, spin.bets.get(selectedValue) + betAmount);\n        } else {\n            spin.bets.set(selectedValue, betAmount);\n        }\n        \n        const bettingEmbed = createBettingEmbed(spin, interaction.user);\n        const bettingComponents = createBettingComponents();\n        \n        await interaction.editReply({ \n            embeds: [bettingEmbed],\n            components: bettingComponents\n        });\n        \n    } catch (error) {\n        console.error('Erreur roulette number bet:', error);\n    }\n}\n\n// Casino game quick start handlers\nasync function handleCasinoBlackjack(interaction) {\n    await interaction.deferUpdate();\n    \n    const quickPlayEmbed = new EmbedBuilder()\n        .setColor('#9932cc')\n        .setTitle('üÉè Quick Play Blackjack')\n        .setDescription('Ready to play Blackjack? Use the command `/blackjack <bet>` to start!')\n        .addFields(\n            {\n                name: 'üéØ How to Play',\n                value: '‚Ä¢ Beat the dealer by getting closer to 21 without going over\\n‚Ä¢ Face cards are worth 10, Aces are 1 or 11\\n‚Ä¢ You can Hit, Stand, or Double Down',\n                inline: false\n            },\n            {\n                name: 'üí∞ Example Commands',\n                value: '‚Ä¢ `/blackjack bet:0.01` - Play with 0.01 LTC\\n‚Ä¢ `/blackjack bet:0.1` - Play with 0.1 LTC',\n                inline: false\n            }\n        )\n        .setFooter({ text: 'Good luck at the tables!' })\n        .setTimestamp();\n    \n    await interaction.editReply({ embeds: [quickPlayEmbed] });\n}\n\nasync function handleCasinoRoulette(interaction) {\n    await interaction.deferUpdate();\n    \n    const quickPlayEmbed = new EmbedBuilder()\n        .setColor('#9932cc')\n        .setTitle('üé∞ Quick Play Roulette')\n        .setDescription('Ready to spin the wheel? Use the command `/roulette <bet>` to start!')\n        .addFields(\n            {\n                name: 'üéØ How to Play',\n                value: '‚Ä¢ Choose your bets: numbers (35:1), colors (1:1), even/odd (1:1)\\n‚Ä¢ The ball will land on a number from 0-36\\n‚Ä¢ Multiple bets allowed per spin',\n                inline: false\n            },\n            {\n                name: 'üí∞ Example Commands',\n                value: '‚Ä¢ `/roulette bet:0.01` - Play with 0.01 LTC\\n‚Ä¢ `/roulette bet:0.1` - Play with 0.1 LTC',\n                inline: false\n            }\n        )\n        .setFooter({ text: 'Place your bets!' })\n        .setTimestamp();\n    \n    await interaction.editReply({ embeds: [quickPlayEmbed] });\n}\n\n// Smart monitoring system\nlet monitoringInterval = null;\n\n/**\n * Start smart monitoring for active deposits\n */\nfunction startSmartMonitoring() {\n    // Don't start if already running\n    if (monitoringInterval) return;\n    \n    console.log('üîç D√©marrage de la surveillance des d√©p√¥ts...');\n    \n    // Surveillance automatique toutes les 2 minutes pour respecter les limites API gratuites\n    monitoringInterval = setInterval(async () => {\n        try {\n            const securityManager = require('./utils/securityManager.js');\n            const userProfiles = require('./utils/userProfiles.js');\n            \n            // Get all active deposits\n            const activeDeposits = securityManager.getAllActiveDeposits();\n            \n            if (activeDeposits.length === 0) {\n                console.log('‚ÑπÔ∏è  Aucun d√©p√¥t actif - arr√™t de la surveillance');\n                stopSmartMonitoring();\n                return;\n            }\n            \n            // Check for new deposits\n            const detectedDeposits = await ltcWallet.smartDepositCheck(activeDeposits);\n            \n            // Process detected deposits\n            for (const deposit of detectedDeposits) {\n                try {\n                    // Add deposit to user profile\n                    userProfiles.addDeposit(deposit.userId, deposit.amount, deposit.address);\n                    \n                    // Add to deposited amount for cashout protection\n                    securityManager.addDepositedAmount(deposit.userId, deposit.amount);\n                    \n                    // Mark deposit as completed\n                    securityManager.completeDepositRequest(deposit.userId, deposit.address);\n                    \n                    // Notify user\n                    await notifyUserOfDeposit(deposit);\n                    \n                } catch (error) {\n                    console.error('Erreur traitement d√©p√¥t:', error);\n                }\n            }\n            \n        } catch (error) {\n            console.error('Erreur surveillance intelligente:', error);\n        }\n    }, 120000); // Check every 2 minutes pour respecter les limites BlockCypher gratuit\n}\n\n/**\n * Stop smart monitoring\n */\nfunction stopSmartMonitoring() {\n    if (monitoringInterval) {\n        clearInterval(monitoringInterval);\n        monitoringInterval = null;\n        console.log('üõë Surveillance intelligente arr√™t√©e');\n    }\n}\n\n/**\n * Notify user of detected deposit\n */\nasync function notifyUserOfDeposit(deposit) {\n    try {\n        const user = await client.users.fetch(deposit.userId);\n        \n        if (user) {\n            const depositEmbed = new EmbedBuilder()\n                .setColor('#00ff00')\n                .setTitle('‚úÖ Deposit Confirmed!')\n                .setDescription('Your Litecoin deposit has been confirmed and added to your balance.')\n                .addFields(\n                    {\n                        name: 'üí∞ Deposit Amount',\n                        value: `**${deposit.amount.toFixed(8)} LTC**`,\n                        inline: true\n                    },\n                    {\n                        name: 'üìç Address',\n                        value: `\\`${deposit.address}\\``,\n                        inline: false\n                    },\n                    {\n                        name: 'üé∞ Ready to Play',\n                        value: 'Use `/casino` to start playing!\\n**Note:** You must wager 100% of deposited amount before cashout.',\n                        inline: false\n                    }\n                )\n                .setThumbnail('https://cryptologos.cc/logos/litecoin-ltc-logo.png')\n                .setTimestamp();\n            \n            // Try to send DM\n            try {\n                await user.send({ embeds: [depositEmbed] });\n                console.log(`üí∞ Utilisateur ${user.username} notifi√© du d√©p√¥t de ${deposit.amount} LTC`);\n            } catch (dmError) {\n                console.log(`Impossible d'envoyer un MP √† ${user.username}:`, dmError.message);\n            }\n        }\n    } catch (error) {\n        console.log('Unable to notify user of deposit:', error.message);\n    }\n}\n\n// Game explanation handlers\nasync function handleExplainBlackjack(interaction) {\n    const embed = new EmbedBuilder()\n        .setColor('#ff6b6b')\n        .setTitle('üÉè How to Play Blackjack')\n        .setDescription('Beat the dealer by getting closer to 21 without going over!')\n        .addFields(\n            {\n                name: 'üéØ Objective',\n                value: 'Get a hand value closer to 21 than the dealer without exceeding it.',\n                inline: false\n            },\n            {\n                name: 'üÉè Card Values',\n                value: '‚Ä¢ Number cards (2-10): Face value\\n‚Ä¢ Face cards (J, Q, K): 10 points\\n‚Ä¢ Ace: 1 or 11 points (best value automatically chosen)',\n                inline: false\n            },\n            {\n                name: 'üéÆ How to Play',\n                value: '1. Use `/blackjack <amount>` in this channel\\n2. You and dealer get 2 cards each\\n3. Choose to Hit (get another card) or Stand (keep current hand)\\n4. Try to get closer to 21 than the dealer!',\n                inline: false\n            },\n            {\n                name: 'üèÜ Winning Conditions',\n                value: '‚Ä¢ **Blackjack**: 21 with first 2 cards (pays 3:2)\\n‚Ä¢ **Win**: Closer to 21 than dealer (pays 1:1)\\n‚Ä¢ **Push**: Same value as dealer (bet returned)\\n‚Ä¢ **Bust**: Over 21 (lose bet)',\n                inline: false\n            }\n        )\n        .setFooter({ text: 'Good luck at the tables!' })\n        .setTimestamp();\n    \n    await interaction.reply({ embeds: [embed], ephemeral: true });\n}\n\nasync function handleExplainRoulette(interaction) {\n    const embed = new EmbedBuilder()\n        .setColor('#00ff00')\n        .setTitle('üé≤ How to Play Roulette')\n        .setDescription('Place your bets and watch the wheel spin!')\n        .addFields(\n            {\n                name: 'üéØ Objective',\n                value: 'Predict where the ball will land on the spinning wheel.',\n                inline: false\n            },\n            {\n                name: 'üéÆ How to Play',\n                value: '1. Use `/roulette <amount>` in this channel\\n2. Choose your bet type:\\n   ‚Ä¢ Number bet (0-36)\\n   ‚Ä¢ Color bet (Red/Black)\\n   ‚Ä¢ Even/Odd bet\\n3. Watch the wheel spin and see if you win!',\n                inline: false\n            },\n            {\n                name: 'üí∞ Payouts',\n                value: '‚Ä¢ **Number bet**: 35:1 (guess exact number)\\n‚Ä¢ **Color bet**: 1:1 (red or black)\\n‚Ä¢ **Even/Odd bet**: 1:1 (even or odd numbers)\\n‚Ä¢ **Zero**: Wins number bets only',\n                inline: false\n            },\n            {\n                name: 'üé∞ The Wheel',\n                value: 'European wheel with numbers 0-36. Zero (0) is green, others alternate red and black.',\n                inline: false\n            }\n        )\n        .setFooter({ text: 'Place your bets!' })\n        .setTimestamp();\n    \n    await interaction.reply({ embeds: [embed], ephemeral: true });\n}\n\nasync function handleExplainCoinflip(interaction) {\n    const embed = new EmbedBuilder()\n        .setColor('#ffd700')\n        .setTitle('ü™ô How to Play Coinflip')\n        .setDescription('The simplest casino game - just pick heads or tails!')\n        .addFields(\n            {\n                name: 'üéØ Objective',\n                value: 'Predict the outcome of a coin flip.',\n                inline: false\n            },\n            {\n                name: 'üéÆ How to Play',\n                value: '1. Use `/coinflip <amount>` in this channel\\n2. Choose Heads or Tails\\n3. Watch the coin flip!\\n4. If you guess correctly, you double your bet!',\n                inline: false\n            },\n            {\n                name: 'üí∞ Payouts',\n                value: '‚Ä¢ **Correct guess**: 1:1 (double your money)\\n‚Ä¢ **Wrong guess**: Lose your bet\\n‚Ä¢ **50/50 chance** - pure luck!',\n                inline: false\n            },\n            {\n                name: 'üé≤ Perfect for Beginners',\n                value: 'No strategy needed - just pick your side and hope for the best!',\n                inline: false\n            }\n        )\n        .setFooter({ text: 'Flip that coin!' })\n        .setTimestamp();\n    \n    await interaction.reply({ embeds: [embed], ephemeral: true });\n}\n\nasync function handleCreatePrivateSession(interaction) {\n    await interaction.deferReply({ ephemeral: true });\n    \n    try {\n        const guild = interaction.guild;\n        const user = interaction.user;\n        const { ChannelType, PermissionsBitField } = require('discord.js');\n        \n        // Check if user already has a private session\n        const existingChannel = guild.channels.cache.find(channel => \n            channel.name === `session-${user.username.toLowerCase()}` && \n            channel.type === ChannelType.GuildText\n        );\n        \n        if (existingChannel) {\n            const alreadyExistsEmbed = new EmbedBuilder()\n                .setColor('#ffaa00')\n                .setTitle('‚ö†Ô∏è Session Already Exists')\n                .setDescription(`You already have an active private session: ${existingChannel}`)\n                .addFields({\n                    name: 'üéÆ Available Commands',\n                    value: 'Use `/addplayer` in your session to invite other players',\n                    inline: false\n                })\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [alreadyExistsEmbed] });\n            return;\n        }\n        \n        // Create private session channel\n        const sessionChannel = await guild.channels.create({\n            name: `session-${user.username.toLowerCase()}`,\n            type: ChannelType.GuildText,\n            topic: `Private gaming session owned by ${user.username}`,\n            permissionOverwrites: [\n                {\n                    id: guild.id,\n                    deny: [PermissionsBitField.Flags.ViewChannel]\n                },\n                {\n                    id: user.id,\n                    allow: [PermissionsBitField.Flags.ViewChannel, PermissionsBitField.Flags.SendMessages, PermissionsBitField.Flags.ReadMessageHistory, PermissionsBitField.Flags.ManageMessages]\n                }\n            ]\n        });\n        \n        // Send welcome message to session\n        const welcomeEmbed = new EmbedBuilder()\n            .setColor('#5865f2')\n            .setTitle('üîí Private Gaming Session Created')\n            .setDescription(`Welcome to your private gaming session, ${user}!`)\n            .addFields(\n                {\n                    name: 'üéÆ Available Games',\n                    value: '‚Ä¢ `/blackjack <amount>` - Play private blackjack\\n‚Ä¢ `/roulette <amount>` - Play private roulette\\n‚Ä¢ `/coinflip <amount>` - Play private coinflip',\n                    inline: false\n                },\n                {\n                    name: 'üë• Session Management',\n                    value: '‚Ä¢ Use `/addplayer @user` to invite players\\n‚Ä¢ Only you can manage this session\\n‚Ä¢ Session auto-closes after 2 hours of inactivity',\n                    inline: false\n                },\n                {\n                    name: 'üîí Privacy',\n                    value: 'This is your private space - only invited players can see and participate',\n                    inline: false\n                }\n            )\n            .setFooter({ text: 'Private Session ‚Ä¢ Auto-closes after 2 hours of inactivity' })\n            .setTimestamp();\n            \n        const { ActionRowBuilder, ButtonBuilder, ButtonStyle } = require('discord.js');\n        const actionRow = new ActionRowBuilder()\n            .addComponents(\n                new ButtonBuilder()\n                    .setCustomId('close_session')\n                    .setLabel('End Session')\n                    .setStyle(ButtonStyle.Danger)\n                    .setEmoji('üîí')\n            );\n        \n        await sessionChannel.send({ \n            embeds: [welcomeEmbed],\n            components: [actionRow]\n        });\n        \n        // Auto-close session after 2 hours of inactivity\n        setTimeout(async () => {\n            try {\n                await sessionChannel.delete('Auto-close after 2 hours of inactivity');\n            } catch (error) {\n                console.error('Error auto-closing session channel:', error);\n            }\n        }, 2 * 60 * 60 * 1000);\n        \n        // Reply to user\n        const responseEmbed = new EmbedBuilder()\n            .setColor('#00ff00')\n            .setTitle('‚úÖ Private Session Created')\n            .setDescription(`Your private gaming session has been created: ${sessionChannel}`)\n            .addFields({\n                name: '‚è∞ Auto-Close',\n                value: 'Session will automatically close in 2 hours if unused',\n                inline: false\n            })\n            .setTimestamp();\n            \n        await interaction.editReply({ embeds: [responseEmbed] });\n        \n        console.log(`üîí Private session created for ${user.username}: ${sessionChannel.name}`);\n        \n    } catch (error) {\n        console.error('‚ùå Create private session error:', error);\n        \n        const errorEmbed = new EmbedBuilder()\n            .setColor('#ff0000')\n            .setTitle('‚ùå Error')\n            .setDescription('Failed to create private session. Please try again.')\n            .setTimestamp();\n        \n        await interaction.editReply({ embeds: [errorEmbed] });\n    }\n}\n\n// Export for external use\nmodule.exports = {\n    client,\n    handleAddBalance,\n    handleCreateChannel,\n    startSmartMonitoring,\n    stopSmartMonitoring\n};\n\n// Gestion d'erreurs globales pour √©viter les d√©connexions\nprocess.on('uncaughtException', (error) => {\n    console.error('‚ö†Ô∏è Erreur non g√©r√©e captur√©e:', error);\n    console.log('üîÑ Le bot continue de fonctionner...');\n});\n\nprocess.on('unhandledRejection', (reason, promise) => {\n    console.error('‚ö†Ô∏è Promesse rejet√©e non g√©r√©e:', reason);\n    console.log('üîÑ Le bot continue de fonctionner...');\n});\n\n// Gestion des erreurs Discord\nclient.on('error', (error) => {\n    console.error('‚ö†Ô∏è Erreur client Discord:', error);\n    console.log('üîÑ Tentative de reconnexion...');\n});\n\nclient.on('warn', (info) => {\n    console.warn('‚ö†Ô∏è Avertissement Discord:', info);\n});\n\nclient.on('disconnect', () => {\n    console.log('‚ö†Ô∏è Bot d√©connect√©, tentative de reconnexion...');\n});\n\nclient.on('reconnecting', () => {\n    console.log('üîÑ Reconnexion en cours...');\n});\n\n// Channel management handlers\nasync function handleCloseChannel(interaction) {\n    await interaction.deferReply({ ephemeral: true });\n    \n    try {\n        const channel = interaction.channel;\n        const channelManager = require('./utils/channelManager.js');\n        \n        // Check if user owns this channel\n        const channelInfo = channelManager.getChannelInfo(channel.id);\n        if (!channelInfo || channelInfo.userId !== interaction.user.id) {\n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Permission Denied')\n                .setDescription('You can only close channels that belong to you.')\n                .setTimestamp();\n                \n            await interaction.editReply({ embeds: [errorEmbed] });\n            return;\n        }\n        \n        const confirmEmbed = new EmbedBuilder()\n            .setColor('#00ff00')\n            .setTitle('‚úÖ Channel Closed')\n            .setDescription('This channel will be deleted in 5 seconds...')\n            .setTimestamp();\n            \n        await interaction.editReply({ embeds: [confirmEmbed] });\n        \n        // Clean up and delete channel\n        setTimeout(async () => {\n            try {\n                channelManager.unregisterChannel(channel.id);\n                await channel.delete('User requested closure');\n            } catch (error) {\n                console.error('Error deleting channel:', error);\n            }\n        }, 5000);\n        \n    } catch (error) {\n        console.error('‚ùå Close channel error:', error);\n        \n        const errorEmbed = new EmbedBuilder()\n            .setColor('#ff0000')\n            .setTitle('‚ùå Error')\n            .setDescription('Failed to close channel.')\n            .setTimestamp();\n            \n        await interaction.editReply({ embeds: [errorEmbed] });\n    }\n}\n\nasync function handleCloseSession(interaction) {\n    await interaction.deferReply({ ephemeral: true });\n    \n    try {\n        const channel = interaction.channel;\n        const expectedName = `session-${interaction.user.username.toLowerCase()}`;\n        \n        // Check if user owns this session\n        if (channel.name !== expectedName) {\n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Permission Denied')\n                .setDescription('You can only close your own private sessions.')\n                .setTimestamp();\n                \n            await interaction.editReply({ embeds: [errorEmbed] });\n            return;\n        }\n        \n        const confirmEmbed = new EmbedBuilder()\n            .setColor('#00ff00')\n            .setTitle('‚úÖ Session Ended')\n            .setDescription('Your private session will be deleted in 5 seconds...')\n            .setTimestamp();\n            \n        await interaction.editReply({ embeds: [confirmEmbed] });\n        \n        // Delete session after delay\n        setTimeout(async () => {\n            try {\n                await channel.delete('Session ended by user');\n            } catch (error) {\n                console.error('Error deleting session:', error);\n            }\n        }, 5000);\n        \n    } catch (error) {\n        console.error('‚ùå Close session error:', error);\n        \n        const errorEmbed = new EmbedBuilder()\n            .setColor('#ff0000')\n            .setTitle('‚ùå Error')\n            .setDescription('Failed to close session.')\n            .setTimestamp();\n            \n        await interaction.editReply({ embeds: [errorEmbed] });\n    }\n}\n\nasync function handleLiveRouletteBet(interaction) {\n    await interaction.deferReply({ ephemeral: true });\n    \n    try {\n        const betType = interaction.customId.replace('live_roulette_', '');\n        const userId = interaction.user.id;\n        \n        // For now, use a fixed bet amount of 0.01 LTC\n        const betAmount = 0.01;\n        \n        // Check if user has balance\n        const userProfiles = require('./utils/userProfiles.js');\n        const profile = userProfiles.getUserProfile(userId);\n        \n        if (profile.balance < betAmount) {\n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Insufficient Balance')\n                .setDescription(`You need at least ${betAmount.toFixed(3)} LTC to place this bet.`)\n                .addFields({\n                    name: 'üí∞ Your Balance',\n                    value: `${profile.balance.toFixed(8)} LTC`,\n                    inline: false\n                })\n                .setTimestamp();\n                \n            await interaction.editReply({ embeds: [errorEmbed] });\n            return;\n        }\n        \n        // Place bet in live roulette\n        const result = liveRoulette.placeBet(userId, betType, betAmount);\n        \n        if (!result.success) {\n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff9900')\n                .setTitle('‚ö†Ô∏è Betting Closed')\n                .setDescription(result.message)\n                .setTimestamp();\n                \n            await interaction.editReply({ embeds: [errorEmbed] });\n            return;\n        }\n        \n        // Deduct bet from balance\n        profile.balance -= betAmount;\n        userProfiles.saveProfile(userId, profile);\n        \n        const successEmbed = new EmbedBuilder()\n            .setColor('#00ff00')\n            .setTitle('‚úÖ Bet Placed!')\n            .setDescription(`Your bet on **${betType}** has been placed for the live roulette.`)\n            .addFields(\n                { name: 'üéØ Bet Type', value: betType.charAt(0).toUpperCase() + betType.slice(1), inline: true },\n                { name: 'üí∞ Bet Amount', value: `${betAmount.toFixed(3)} LTC`, inline: true },\n                { name: 'üí≥ Remaining Balance', value: `${profile.balance.toFixed(8)} LTC`, inline: true }\n            )\n            .setFooter({ text: 'Good luck! Results will be announced in the live channel.' })\n            .setTimestamp();\n            \n        await interaction.editReply({ embeds: [successEmbed] });\n        \n    } catch (error) {\n        console.error('‚ùå Live roulette bet error:', error);\n        \n        const errorEmbed = new EmbedBuilder()\n            .setColor('#ff0000')\n            .setTitle('‚ùå Error')\n            .setDescription('Failed to place bet.')\n            .setTimestamp();\n            \n        await interaction.editReply({ embeds: [errorEmbed] });\n    }\n}\n\n// Function to start live roulette when server is configured\nfunction startLiveRouletteIfConfigured() {\n    try {\n        const fs = require('fs');\n        if (fs.existsSync('./data/server_config.json')) {\n            const allConfigs = JSON.parse(fs.readFileSync('./data/server_config.json', 'utf8'));\n            \n            for (const [guildId, config] of Object.entries(allConfigs)) {\n                if (config.liveRouletteChannel) {\n                    const channel = client.channels.cache.get(config.liveRouletteChannel);\n                    if (channel) {\n                        liveRoulette.start(config.liveRouletteChannel);\n                        console.log(`üé∞ Live roulette started for guild ${guildId}`);\n                    }\n                }\n            }\n        }\n    } catch (error) {\n        console.error('Error starting live roulette:', error);\n    }\n}\n\n// Coinflip progression button handlers\nasync function handleCoinflipDouble(interaction) {\n    await interaction.deferReply({ ephemeral: false });\n    \n    try {\n        const betAmount = parseFloat(interaction.customId.split('_')[2]);\n        const userId = interaction.user.id;\n        \n        // Get coinflip command and its active sessions\n        const coinflipCommand = client.commands.get('coinflip');\n        const activeSessions = coinflipCommand.activeSessions || new Map();\n        \n        const session = activeSessions.get(userId);\n        if (!session) {\n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Session Expir√©e')\n                .setDescription('Votre session de coinflip a expir√©. Commencez une nouvelle partie avec `/coinflip`.')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n            return;\n        }\n        \n        // Check user balance\n        const profile = require('./utils/userProfiles.js').getUserProfile(userId);\n        if (profile.balance < betAmount) {\n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Solde Insuffisant')\n                .setDescription(`Vous avez besoin de ${betAmount.toFixed(8)} LTC pour doubler votre mise.`)\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n            return;\n        }\n        \n        // Use the same choice as previous round\n        const previousChoice = session.lastChoice || 'heads';\n        \n        // Call the animation function from coinflip command\n        await coinflipCommand.showCoinflipAnimation(interaction, betAmount, previousChoice);\n        \n    } catch (error) {\n        console.error('Coinflip double error:', error);\n        \n        const errorEmbed = new EmbedBuilder()\n            .setColor('#ff0000')\n            .setTitle('‚ùå Erreur')\n            .setDescription('Une erreur est survenue lors du double ou rien.')\n            .setTimestamp();\n        \n        await interaction.editReply({ embeds: [errorEmbed] });\n    }\n}\n\nasync function handleCoinflipCashout(interaction) {\n    await interaction.deferReply({ ephemeral: false });\n    \n    try {\n        const userId = interaction.user.id;\n        \n        // Get coinflip command and its active sessions\n        const coinflipCommand = client.commands.get('coinflip');\n        const activeSessions = coinflipCommand.activeSessions || new Map();\n        \n        const session = activeSessions.get(userId);\n        if (!session) {\n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Session Expir√©e')\n                .setDescription('Votre session de coinflip a expir√©.')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n            return;\n        }\n        \n        // Add winnings to user balance\n        const userProfiles = require('./utils/userProfiles.js');\n        const profile = userProfiles.getUserProfile(userId);\n        const finalBalance = profile.balance + session.totalWinnings;\n        userProfiles.updateUserProfile(userId, { balance: finalBalance });\n        \n        // Clear session\n        activeSessions.delete(userId);\n        \n        // Create cashout embed\n        const cashoutEmbed = new EmbedBuilder()\n            .setColor('#27ae60')\n            .setTitle('üí∞ Encaissement R√©ussi!')\n            .setDescription(`Vous avez encaiss√© vos gains avec succ√®s!`)\n            .addFields(\n                {\n                    name: 'üéâ Gains Encaiss√©s',\n                    value: `${session.totalWinnings.toFixed(8)} LTC`,\n                    inline: true\n                },\n                {\n                    name: 'üèÜ S√©rie de Victoires',\n                    value: `${session.streak} victoire(s) cons√©cutive(s)`,\n                    inline: true\n                },\n                {\n                    name: 'üí≥ Nouveau Solde',\n                    value: `${finalBalance.toFixed(8)} LTC`,\n                    inline: false\n                }\n            )\n            .setImage('https://media.giphy.com/media/3o7abKhOpu0NwenH3O/giphy.gif')\n            .setFooter({ text: 'F√©licitations! Vous pouvez relancer une nouvelle partie.' })\n            .setTimestamp();\n        \n        await interaction.editReply({ embeds: [cashoutEmbed] });\n        \n        console.log(`üí∞ ${interaction.user.username} cashed out ${session.totalWinnings.toFixed(8)} LTC from coinflip`);\n        \n    } catch (error) {\n        console.error('Coinflip cashout error:', error);\n        \n        const errorEmbed = new EmbedBuilder()\n            .setColor('#ff0000')\n            .setTitle('‚ùå Erreur')\n            .setDescription('Une erreur est survenue lors de l\\'encaissement.')\n            .setTimestamp();\n        \n        await interaction.editReply({ embeds: [errorEmbed] });\n    }\n}\n\n// Start live roulette when bot is ready\nclient.once('ready', () => {\n    setTimeout(startLiveRouletteIfConfigured, 5000); // Wait 5 seconds after bot is ready\n});\n\n// Fonction de reconnexion automatique\nasync function startBotWithRetry() {\n    const token = process.env.DISCORD_TOKEN;\n    \n    if (!token) {\n        console.error('‚ùå DISCORD_TOKEN environment variable is required!');\n        process.exit(1);\n    }\n    \n    let retryCount = 0;\n    const maxRetries = 5;\n    \n    while (retryCount < maxRetries) {\n        try {\n            await client.login(token);\n            console.log('‚úÖ Bot connect√© avec succ√®s!');\n            break;\n        } catch (error) {\n            retryCount++;\n            console.error(`‚ùå √âchec de connexion (tentative ${retryCount}/${maxRetries}):`, error.message);\n            \n            if (retryCount < maxRetries) {\n                const delay = retryCount * 5000; // D√©lai croissant: 5s, 10s, 15s...\n                console.log(`‚è≥ Nouvelle tentative dans ${delay/1000}s...`);\n                await new Promise(resolve => setTimeout(resolve, delay));\n            } else {\n                console.error('‚ùå Impossible de se connecter apr√®s plusieurs tentatives');\n                process.exit(1);\n            }\n        }\n    }\n}\n\n// Start the bot if this file is run directly\nif (require.main === module) {\n    startBotWithRetry();\n}","size_bytes":63297},"events/interactionCreate.js":{"content":"const { Events, EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle } = require('discord.js');\n\nmodule.exports = {\n    name: Events.InteractionCreate,\n    async execute(interaction) {\n        // Handle slash commands\n        if (interaction.isChatInputCommand()) {\n            const command = interaction.client.commands.get(interaction.commandName);\n\n            if (!command) {\n                console.error(`‚ùå No command matching ${interaction.commandName} was found.`);\n                return;\n            }\n\n            try {\n                await command.execute(interaction);\n                console.log(`‚úÖ ${interaction.user.username} a utilis√© /${interaction.commandName}`);\n            } catch (error) {\n                console.error(`‚ùå Erreur lors de l'ex√©cution de ${interaction.commandName}:`, error);\n\n                try {\n                    const errorEmbed = new EmbedBuilder()\n                        .setColor('#ff0000')\n                        .setTitle('‚ùå Command Error')\n                        .setDescription('There was an error while executing this command!')\n                        .setTimestamp();\n\n                    if (interaction.replied || interaction.deferred) {\n                        await interaction.followUp({ embeds: [errorEmbed], ephemeral: true });\n                    } else {\n                        await interaction.reply({ embeds: [errorEmbed], ephemeral: true });\n                    }\n                } catch (replyError) {\n                    console.error('‚ö†Ô∏è Impossible de r√©pondre √† l\\'interaction:', replyError.message);\n                }\n            }\n        }\n\n        // Handle button interactions\n        if (interaction.isButton()) {\n            try {\n                // Check for panel interactions\n                if (interaction.customId.startsWith('panel_')) {\n                    await handlePanelInteraction(interaction);\n                } else {\n                    await handleButtonInteraction(interaction);\n                }\n            } catch (error) {\n                console.error('‚ùå Erreur d\\'interaction bouton:', error);\n\n                try {\n                    const errorEmbed = new EmbedBuilder()\n                        .setColor('#ff0000')\n                        .setTitle('‚ùå Error')\n                        .setDescription('There was an error processing your request!')\n                        .setTimestamp();\n\n                    if (interaction.replied || interaction.deferred) {\n                        await interaction.followUp({ embeds: [errorEmbed], ephemeral: true });\n                    } else {\n                        await interaction.reply({ embeds: [errorEmbed], ephemeral: true });\n                    }\n                } catch (replyError) {\n                    console.error('‚ö†Ô∏è Impossible de r√©pondre √† l\\'interaction bouton:', replyError.message);\n                }\n            }\n        }\n    },\n};\n\n/**\n * Handle button interactions\n */\nasync function handleButtonInteraction(interaction) {\n    const { customId } = interaction;\n    \n    switch (customId) {\n        case 'add_balance':\n            await handleAddBalance(interaction);\n            break;\n        case 'view_profile':\n            await handleViewProfile(interaction);\n            break;\n        case 'leaderboard':\n            await handleLeaderboard(interaction);\n            break;\n        case 'create_channel':\n            await handleCreateChannel(interaction);\n            break;\n        case 'blackjack':\n        case 'roulette':\n        case 'slots':\n            await handleGameNotAvailable(interaction);\n            break;\n        default:\n            console.log(`Interaction bouton inconnue: ${customId}`);\n    }\n}\n\n/**\n * Handle Add Balance button\n */\nasync function handleAddBalance(interaction) {\n    // Avoid duplicate calls from panel interactions\n    if (interaction.customId === 'panel_add_balance') {\n        return; // This is handled by handlePanelInteraction\n    }\n    \n    const { handleAddBalance } = require('../discord-bot.js');\n    await handleAddBalance(interaction);\n}\n\n/**\n * Handle View Profile button\n */\nasync function handleViewProfile(interaction) {\n    // Avoid duplicate calls from panel interactions\n    if (interaction.customId === 'panel_view_profile') {\n        return; // This is handled by handlePanelInteraction\n    }\n    \n    await interaction.deferReply({ ephemeral: true });\n    \n    const profileCommand = require('../commands/profile.js');\n    await profileCommand.execute(interaction);\n}\n\n/**\n * Handle Leaderboard button\n */\nasync function handleLeaderboard(interaction) {\n    await interaction.deferReply({ ephemeral: true });\n    \n    try {\n        const userProfiles = require('../utils/userProfiles.js');\n        const { formatLTC } = require('../utils/formatters.js');\n        const leaderboard = userProfiles.getLeaderboard('balance', 10);\n        \n        if (leaderboard.length === 0) {\n            const emptyEmbed = new EmbedBuilder()\n                .setColor('#ffaa00')\n                .setTitle('üèÜ Casino Leaderboard')\n                .setDescription('No players yet! Be the first to add balance.')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [emptyEmbed] });\n            return;\n        }\n        \n        let leaderboardText = '';\n        const medals = ['ü•á', 'ü•à', 'ü•â'];\n        \n        for (let i = 0; i < leaderboard.length; i++) {\n            const user = leaderboard[i];\n            const medal = i < 3 ? medals[i] : `${i + 1}.`;\n            \n            try {\n                const discordUser = await interaction.client.users.fetch(user.userId);\n                leaderboardText += `${medal} **${discordUser.username}** - ${formatLTC(user.value)} LTC\\n`;\n            } catch (error) {\n                leaderboardText += `${medal} **Unknown User** - ${formatLTC(user.value)} LTC\\n`;\n            }\n        }\n        \n        const leaderboardEmbed = new EmbedBuilder()\n            .setColor('#ffd700')\n            .setTitle('üèÜ Casino Leaderboard')\n            .setDescription('**Top Players by Balance**\\n\\n' + leaderboardText)\n            .setThumbnail('https://cryptologos.cc/logos/litecoin-ltc-logo.png')\n            .setFooter({ text: 'Rankings update in real-time' })\n            .setTimestamp();\n        \n        await interaction.editReply({ embeds: [leaderboardEmbed] });\n        \n    } catch (error) {\n        console.error('Leaderboard error:', error);\n        \n        const errorEmbed = new EmbedBuilder()\n            .setColor('#ff0000')\n            .setTitle('‚ùå Error')\n            .setDescription('Failed to load leaderboard. Please try again.')\n            .setTimestamp();\n        \n        await interaction.editReply({ embeds: [errorEmbed] });\n    }\n}\n\n/**\n * Handle Create Channel button\n */\nasync function handleCreateChannel(interaction) {\n    const { handleCreateChannel } = require('../discord-bot.js');\n    await handleCreateChannel(interaction);\n}\n\n/**\n * Handle panel interactions (creates tickets)\n */\nasync function handlePanelInteraction(interaction) {\n    // Check if interaction is too old\n    const interactionAge = Date.now() - interaction.createdTimestamp;\n    if (interactionAge > 10 * 60 * 1000) {\n        console.log('Interaction trop ancienne, ignor√©e');\n        return;\n    }\n    \n    const ticketManager = require('../utils/ticketManager.js');\n    const panelManager = require('../utils/panelManager.js');\n    \n    const { customId } = interaction;\n    \n    // Determine ticket type based on button\n    let ticketType = 'general';\n    let actionName = 'Casino';\n    \n    if (customId === 'panel_add_balance') {\n        ticketType = 'balance';\n        actionName = 'Add Balance';\n    } else if (customId === 'panel_view_profile') {\n        ticketType = 'profile';\n        actionName = 'Profile';\n    }\n    \n    await interaction.deferReply({ ephemeral: true });\n    \n    try {\n        // Get panel configuration for ticket category\n        const panelConfig = panelManager.getPanelConfig('casinoPanel');\n        const categoryId = panelConfig?.ticketCategory;\n        const staffRoleId = panelConfig?.staffRole;\n        \n        // Create ticket\n        const result = await ticketManager.createTicket(\n            interaction.guild,\n            interaction.user,\n            categoryId,\n            staffRoleId,\n            ticketType\n        );\n        \n        if (result.success) {\n            const successEmbed = new EmbedBuilder()\n                .setColor('#00ff00')\n                .setTitle('‚úÖ Private Channel Created')\n                .setDescription(`Your private ${actionName.toLowerCase()} channel has been created!`)\n                .addFields({\n                    name: 'üé´ Your Channel',\n                    value: `${result.channel}`,\n                    inline: false\n                })\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [successEmbed] });\n            \n            // Send welcome message in ticket\n            await sendTicketWelcome(result.channel, interaction.user, ticketType);\n            \n        } else if (result.error === 'existing') {\n            const existingEmbed = new EmbedBuilder()\n                .setColor('#ffaa00')\n                .setTitle('‚ö†Ô∏è Channel Already Exists')\n                .setDescription(`You already have a private ${actionName.toLowerCase()} channel!`)\n                .addFields({\n                    name: 'üé´ Your Existing Channel',\n                    value: `${result.channel}`,\n                    inline: false\n                })\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [existingEmbed] });\n            \n        } else {\n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Failed to Create Channel')\n                .setDescription('Unable to create your private channel. Please contact staff.')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n        \n    } catch (error) {\n        console.error('Erreur panel interaction:', error);\n        \n        const errorEmbed = new EmbedBuilder()\n            .setColor('#ff0000')\n            .setTitle('‚ùå Error')\n            .setDescription('An error occurred while processing your request.')\n            .setTimestamp();\n        \n        await interaction.editReply({ embeds: [errorEmbed] });\n    }\n}\n\n/**\n * Send welcome message in ticket channel\n */\nasync function sendTicketWelcome(channel, user, ticketType) {\n    try {\n        let welcomeEmbed;\n        \n        if (ticketType === 'balance') {\n            const { handleAddBalance } = require('../discord-bot.js');\n            \n            welcomeEmbed = new EmbedBuilder()\n                .setColor('#00ff00')\n                .setTitle('üí∞ Private Balance Channel')\n                .setDescription(`Welcome ${user}! This is your private channel for balance operations.`)\n                .addFields(\n                    {\n                        name: 'üìã Available Actions',\n                        value: '‚Ä¢ Click the button below to generate a deposit address\\n‚Ä¢ Check your balance with commands\\n‚Ä¢ Safe and private environment',\n                        inline: false\n                    }\n                )\n                .setThumbnail(user.displayAvatarURL())\n                .setTimestamp();\n            \n            const balanceButton = new ActionRowBuilder()\n                .addComponents(\n                    new ButtonBuilder()\n                        .setCustomId('add_balance')\n                        .setLabel('üí∞ Generate Deposit Address')\n                        .setStyle(ButtonStyle.Success)\n                        .setEmoji('üí∞')\n                );\n            \n            await channel.send({ \n                embeds: [welcomeEmbed],\n                components: [balanceButton]\n            });\n            \n        } else if (ticketType === 'profile') {\n            welcomeEmbed = new EmbedBuilder()\n                .setColor('#0099ff')\n                .setTitle('üë§ Private Profile Channel')\n                .setDescription(`Welcome ${user}! This is your private channel for profile management.`)\n                .addFields(\n                    {\n                        name: 'üìã Available Actions',\n                        value: '‚Ä¢ Use `/profile` to view your statistics\\n‚Ä¢ Use `/balance` to check your funds\\n‚Ä¢ Use `/givebal` to transfer to other users',\n                        inline: false\n                    }\n                )\n                .setThumbnail(user.displayAvatarURL())\n                .setTimestamp();\n            \n            await channel.send({ embeds: [welcomeEmbed] });\n            \n        } else {\n            welcomeEmbed = new EmbedBuilder()\n                .setColor('#f7931a')\n                .setTitle('üé∞ Private Casino Channel')\n                .setDescription(`Welcome ${user}! This is your private casino session.`)\n                .addFields(\n                    {\n                        name: 'üéÆ Available Commands',\n                        value: '‚Ä¢ `/profile` - View your profile\\n‚Ä¢ `/balance` - Check balance\\n‚Ä¢ `/casino` - Access main panel\\n‚Ä¢ `/convert-eur-usd` - Currency converter',\n                        inline: false\n                    }\n                )\n                .setThumbnail(user.displayAvatarURL())\n                .setTimestamp();\n            \n            await channel.send({ embeds: [welcomeEmbed] });\n        }\n        \n    } catch (error) {\n        console.error('Erreur envoi welcome message:', error);\n    }\n}\n\n/**\n * Handle game buttons (not yet implemented)\n */\nasync function handleGameNotAvailable(interaction) {\n    const gameNames = {\n        'blackjack': 'üÉè Blackjack',\n        'roulette': 'üé≤ Roulette',\n        'slots': 'üé∞ Slots'\n    };\n    \n    const gameName = gameNames[interaction.customId] || 'Game';\n    \n    const comingSoonEmbed = new EmbedBuilder()\n        .setColor('#ffaa00')\n        .setTitle('üöß Coming Soon!')\n        .setDescription(`${gameName} is currently under development and will be available soon!`)\n        .addFields({\n            name: 'üéÆ Available Features',\n            value: '‚Ä¢ Balance management\\n‚Ä¢ Currency conversion\\n‚Ä¢ Deposit/withdrawal system\\n‚Ä¢ User profiles',\n            inline: false\n        })\n        .setFooter({ text: 'Stay tuned for exciting casino games!' })\n        .setTimestamp();\n    \n    await interaction.reply({ embeds: [comingSoonEmbed], ephemeral: true });\n}","size_bytes":14699},"events/ready.js":{"content":"const { Events } = require('discord.js');\n\nmodule.exports = {\n    name: Events.ClientReady,\n    once: true,\n    execute(client) {\n        console.log(`üé∞ Bot Casino Discord pr√™t! Connect√© en tant que ${client.user.tag}`);\n        console.log(`üîó Connect√© √† ${client.guilds.cache.size} serveur(s)`);\n        console.log(`üë• Au service de ${client.users.cache.size} utilisateur(s)`);\n        \n        // Set bot status\n        client.user.setActivity('üé∞ Litecoin Casino | /casino', { type: 'PLAYING' });\n        \n        // Initialize smart monitoring if there are active deposits\n        checkAndStartSmartMonitoring(client);\n    },\n};\n\n/**\n * Check for active deposits and start smart monitoring if needed\n */\nfunction checkAndStartSmartMonitoring(client) {\n    const securityManager = require('../utils/securityManager.js');\n    const { startSmartMonitoring } = require('../discord-bot.js');\n    \n    // Check if there are any active deposits\n    const activeDeposits = securityManager.getAllActiveDeposits();\n    \n    if (activeDeposits.length > 0) {\n        console.log(`üîç ${activeDeposits.length} d√©p√¥t(s) actif(s) trouv√©(s) - d√©marrage de la surveillance intelligente`);\n        startSmartMonitoring();\n    } else {\n        console.log('‚ÑπÔ∏è  Aucun d√©p√¥t actif trouv√© - la surveillance d√©marrera quand n√©cessaire');\n    }\n}","size_bytes":1355},"litecoin-casino-bot.js":{"content":"const fs = require('fs');\nconst litecore = require('litecore-lib');\nconst litecoinDirect = require('./utils/litecoinDirect.js');\n\n// Configuration for direct connection (no API key required)\nconst NETWORK = 'ltc'; // Litecoin mainnet\n\n// File to store generated addresses\nconst ADDRESSES_FILE = 'addresses.json';\n\n/**\n * Load saved addresses from JSON file\n * @returns {Array} List of addresses with their private keys\n */\nfunction loadAddresses() {\n    try {\n        if (fs.existsSync(ADDRESSES_FILE)) {\n            const data = fs.readFileSync(ADDRESSES_FILE, 'utf8');\n            return JSON.parse(data);\n        }\n    } catch (error) {\n        console.error('Error loading addresses:', error.message);\n    }\n    return [];\n}\n\n/**\n * Save addresses to JSON file\n * @param {Array} addresses - List of addresses to save\n */\nfunction saveAddresses(addresses) {\n    try {\n        fs.writeFileSync(ADDRESSES_FILE, JSON.stringify(addresses, null, 2));\n        console.log(`‚úÖ Addresses saved to ${ADDRESSES_FILE}`);\n    } catch (error) {\n        console.error('Error saving addresses:', error.message);\n    }\n}\n\n/**\n * Generate a new Litecoin address with its private key\n * This function uses litecore-lib to create a private key/public address pair\n * Perfect for later integration into a Discord bot with games like blackjack/roulette\n * @returns {Object} Object containing the address and private key\n */\nfunction generateAddress() {\n    try {\n        // Generate a new random private key\n        const privateKey = new litecore.PrivateKey();\n        \n        // Create the corresponding public address\n        const address = privateKey.toAddress();\n        \n        const newAddress = {\n            address: address.toString(),\n            privateKey: privateKey.toString(),\n            createdAt: new Date().toISOString(),\n            balance: 0 // Will be updated during checks\n        };\n        \n        // Load existing addresses\n        const addresses = loadAddresses();\n        \n        // Add the new address\n        addresses.push(newAddress);\n        \n        // Save\n        saveAddresses(addresses);\n        \n        console.log(`üîë New address generated: ${newAddress.address}`);\n        return newAddress;\n        \n    } catch (error) {\n        console.error('Error generating address:', error.message);\n        return null;\n    }\n}\n\n/**\n * V√©rifie le solde d'une adresse via connexion directe (sans API key)\n * @param {string} address - L'adresse Litecoin √† v√©rifier\n * @returns {Promise<number>} Le solde en LTC\n */\nasync function getAddressBalance(address) {\n    try {\n        return await litecoinDirect.getAddressBalance(address, false); // false = mainnet\n    } catch (error) {\n        console.error(`‚ùå Erreur v√©rification pour ${address.substring(0, 10)}...:`, error.message);\n        return 0;\n    }\n}\n\n/**\n * V√©rifie automatiquement les d√©p√¥ts sur toutes les adresses\n * Cette fonction peut √™tre appel√©e p√©riodiquement pour d√©tecter les nouveaux d√©p√¥ts\n * Id√©al pour un bot casino qui doit cr√©diter automatiquement les joueurs\n */\nasync function checkDeposits() {\n    const addresses = loadAddresses();\n    \n    if (addresses.length === 0) {\n        console.log('‚ÑπÔ∏è  No addresses to verify');\n        return;\n    }\n    \n    console.log(`üîç V√©rification de ${addresses.length} adresse(s)...`);\n    \n    for (let i = 0; i < addresses.length; i++) {\n        const addressData = addresses[i];\n        console.log(`üîç Verification ${i + 1}/${addresses.length}: ${addressData.address.substring(0, 10)}...`);\n        \n        const currentBalance = await getAddressBalance(addressData.address);\n        \n        // Check if there was a new deposit\n        if (currentBalance > addressData.balance) {\n            const deposit = currentBalance - addressData.balance;\n            console.log(`üí∞ Deposit detected: ${deposit} LTC on address ${addressData.address}`);\n            \n            // Update balance\n            addresses[i].balance = currentBalance;\n            addresses[i].lastChecked = new Date().toISOString();\n        } else if (currentBalance === addressData.balance) {\n            console.log(`‚ÑπÔ∏è  No new deposits for ${addressData.address.substring(0, 10)}...`);\n        }\n        \n        // D√©lai de 5 secondes pour √™tre respectueux envers les explorateurs publics\n        await new Promise(resolve => setTimeout(resolve, 5000));\n    }\n    \n    // Sauvegarde des soldes mis √† jour\n    saveAddresses(addresses);\n}\n\n/**\n * Obtient les UTXOs (unspent outputs) d'une adresse via connexion directe\n * N√©cessaire pour construire des transactions de retrait\n * @param {string} address - L'adresse Litecoin\n * @returns {Promise<Array>} Liste des UTXOs\n */\nasync function getAddressUTXOs(address) {\n    try {\n        return await litecoinDirect.getAddressUTXOs(address, false); // false = mainnet\n    } catch (error) {\n        console.error('UTXO error:', error.message);\n        return [];\n    }\n}\n\n/**\n * Diffuse une transaction sur le r√©seau Litecoin via connexion directe\n * @param {string} txHex - Transaction s√©rialis√©e en hexad√©cimal\n * @returns {Promise<string|null>} L'ID de la transaction ou null en cas d'erreur\n */\nasync function broadcastTransaction(txHex) {\n    try {\n        return await litecoinDirect.broadcastTransaction(txHex, false); // false = mainnet\n    } catch (error) {\n        console.error('Broadcast error:', error.message);\n        return null;\n    }\n}\n\n/**\n * Effectue un retrait depuis une adresse vers une destination\n * Fonction principale pour les retraits du casino - peut √™tre int√©gr√©e facilement\n * dans un bot Discord pour permettre aux joueurs de retirer leurs gains\n * @param {string} fromAddress - Adresse source (doit √™tre dans notre fichier)\n * @param {string} toAddress - Adresse de destination\n * @param {number} amount - Montant en LTC √† envoyer\n * @param {number} feeRate - Frais en satoshis par byte (d√©faut: 1000 sat/kb = 1 sat/byte)\n * @returns {Promise<string|null>} L'ID de la transaction ou null en cas d'erreur\n */\nasync function withdraw(fromAddress, toAddress, amount, feeRate = 1) {\n    try {\n        // Recherche de la cl√© priv√©e correspondante\n        const addresses = loadAddresses();\n        const addressData = addresses.find(addr => addr.address === fromAddress);\n        \n        if (!addressData) {\n            console.error(`‚ùå Adresse ${fromAddress} non trouv√©e dans notre portefeuille`);\n            return null;\n        }\n        \n        console.log(`üè¶ Pr√©paration du retrait de ${amount} LTC depuis ${fromAddress} vers ${toAddress}`);\n        \n        // R√©cup√©ration des UTXOs\n        const utxos = await getAddressUTXOs(fromAddress);\n        if (utxos.length === 0) {\n            console.error('‚ùå Aucun UTXO disponible pour cette adresse');\n            return null;\n        }\n        \n        // Conversion du montant en satoshis\n        const amountSatoshis = Math.round(amount * 100000000);\n        \n        // Cr√©ation de la transaction\n        const transaction = new litecore.Transaction();\n        \n        // Ajout des inputs (UTXOs) avec script P2PKH standard\n        let totalInputs = 0;\n        for (const utxo of utxos) {\n            // G√©n√©ration du script P2PKH standard pour l'adresse\n            const address = litecore.Address.fromString(fromAddress);\n            const script = litecore.Script.buildPublicKeyHashOut(address);\n            \n            transaction.from({\n                txId: utxo.txid,\n                outputIndex: utxo.outputIndex,\n                address: fromAddress,\n                script: script.toHex(),\n                satoshis: utxo.satoshis\n            });\n            totalInputs += utxo.satoshis;\n        }\n        \n        // Estimation des frais (taille approximative * fee rate)\n        const estimatedSize = 180 + (utxos.length * 180); // Estimation basique\n        const fees = estimatedSize * feeRate;\n        \n        // V√©rification que nous avons assez de fonds\n        if (totalInputs < amountSatoshis + fees) {\n            console.error(`‚ùå Fonds insuffisants. Disponible: ${totalInputs/100000000} LTC, Requis: ${(amountSatoshis + fees)/100000000} LTC`);\n            return null;\n        }\n        \n        // Ajout de l'output principal (destination)\n        transaction.to(toAddress, amountSatoshis);\n        \n        // Calcul et ajout du change (monnaie rendue)\n        const change = totalInputs - amountSatoshis - fees;\n        if (change > 5460) { // Dust limit pour Litecoin\n            transaction.to(fromAddress, change);\n        }\n        \n        // Signature de la transaction avec la cl√© priv√©e\n        const privateKey = new litecore.PrivateKey(addressData.privateKey);\n        transaction.sign(privateKey);\n        \n        // S√©rialisation de la transaction\n        const txHex = transaction.serialize();\n        console.log(`üì§ Transaction created (${txHex.length/2} bytes): ${txHex.substring(0, 64)}...`);\n        \n        // Diffusion sur le r√©seau\n        const txid = await broadcastTransaction(txHex);\n        \n        if (txid) {\n            // Mise √† jour du solde local (approximatif)\n            const addressIndex = addresses.findIndex(addr => addr.address === fromAddress);\n            if (addressIndex !== -1) {\n                addresses[addressIndex].balance -= amount;\n                addresses[addressIndex].lastWithdrawal = {\n                    amount: amount,\n                    to: toAddress,\n                    txid: txid,\n                    timestamp: new Date().toISOString()\n                };\n                saveAddresses(addresses);\n            }\n        }\n        \n        return txid;\n        \n    } catch (error) {\n        console.error('‚ùå Erreur lors du retrait:', error.message);\n        return null;\n    }\n}\n\n/**\n * Affiche le statut de toutes les adresses\n */\nfunction showWalletStatus() {\n    const addresses = loadAddresses();\n    \n    if (addresses.length === 0) {\n        console.log('üíº Portefeuille vide - aucune adresse g√©n√©r√©e');\n        return;\n    }\n    \n    console.log('\\nüíº === STATUT DU PORTEFEUILLE ===');\n    let totalBalance = 0;\n    \n    addresses.forEach((addr, index) => {\n        console.log(`\\n${index + 1}. Adresse: ${addr.address}`);\n        console.log(`   Solde: ${addr.balance} LTC`);\n        console.log(`   Cr√©√©e: ${new Date(addr.createdAt).toLocaleString()}`);\n        if (addr.lastChecked) {\n            console.log(`   Derni√®re v√©rif: ${new Date(addr.lastChecked).toLocaleString()}`);\n        }\n        totalBalance += addr.balance;\n    });\n    \n    console.log(`\\nüí∞ SOLDE TOTAL: ${totalBalance} LTC`);\n    console.log('===================================\\n');\n}\n\n/**\n * Smart deposit monitoring - only check active deposit requests\n * Called by Discord bot when needed\n */\nasync function smartDepositCheck(activeAddresses = []) {\n    if (activeAddresses.length === 0) {\n        console.log('‚ÑπÔ∏è  No active deposit requests to monitor');\n        return [];\n    }\n    \n    console.log(`üîç Smart monitoring ${activeAddresses.length} active deposit(s)...`);\n    const detectedDeposits = [];\n    \n    for (const addressData of activeAddresses) {\n        const currentBalance = await getAddressBalance(addressData.address);\n        \n        // Check if there was a new deposit\n        if (currentBalance > addressData.lastKnownBalance) {\n            const depositAmount = currentBalance - addressData.lastKnownBalance;\n            \n            detectedDeposits.push({\n                address: addressData.address,\n                amount: depositAmount,\n                newBalance: currentBalance,\n                userId: addressData.userId\n            });\n            \n            console.log(`üí∞ Deposit detected: ${depositAmount} LTC on address ${addressData.address}`);\n        }\n        \n        // Small delay to avoid API overload\n        await new Promise(resolve => setTimeout(resolve, 1000));\n    }\n    \n    return detectedDeposits;\n}\n\n/**\n * Initialize wallet system (no automatic monitoring)\n */\nfunction initializeWallet() {\n    console.log('üé∞ === LITECOIN CASINO WALLET SYSTEM ===');\n    console.log('‚úÖ Wallet system initialized - Smart monitoring mode');\n    console.log('üìã AVAILABLE FUNCTIONS:');\n    console.log('- generateAddress(): Create new address');\n    console.log('- smartDepositCheck(): Check active deposits only');\n    console.log('- withdraw(from, to, amount): Process withdrawal');\n    console.log('- showWalletStatus(): Display wallet status');\n}\n\n// Point d'entr√©e - initialise le syst√®me\nif (require.main === module) {\n    initializeWallet();\n}\n\n// Export des fonctions pour utilisation externe (bot Discord, etc.)\nmodule.exports = {\n    generateAddress,\n    checkDeposits,\n    smartDepositCheck,\n    withdraw,\n    showWalletStatus,\n    loadAddresses,\n    getAddressBalance,\n    initializeWallet\n};","size_bytes":12878},"utils/channelManager.js":{"content":"const fs = require('fs');\nconst path = require('path');\n\nconst CHANNEL_COUNTER_FILE = path.join(__dirname, '../data/channel_counter.json');\n\nclass ChannelManager {\n    constructor() {\n        this.channelData = this.loadChannelData();\n    }\n\n    loadChannelData() {\n        try {\n            if (fs.existsSync(CHANNEL_COUNTER_FILE)) {\n                return JSON.parse(fs.readFileSync(CHANNEL_COUNTER_FILE, 'utf8'));\n            }\n        } catch (error) {\n            console.error('Error loading channel data:', error);\n        }\n        \n        return {\n            balanceCounter: 0,\n            activeChannels: {},\n            channelHistory: []\n        };\n    }\n\n    saveChannelData() {\n        try {\n            fs.writeFileSync(CHANNEL_COUNTER_FILE, JSON.stringify(this.channelData, null, 2));\n            console.log('‚úÖ Channel data saved');\n        } catch (error) {\n            console.error('Error saving channel data:', error);\n        }\n    }\n\n    getNextBalanceChannelName() {\n        this.channelData.balanceCounter++;\n        this.saveChannelData();\n        \n        const number = this.channelData.balanceCounter.toString().padStart(3, '0');\n        return `deposit-${number}`;\n    }\n\n    registerChannel(channelId, userId, type = 'balance') {\n        this.channelData.activeChannels[channelId] = {\n            userId: userId,\n            type: type,\n            createdAt: Date.now(),\n            lastActivity: Date.now()\n        };\n        \n        this.channelData.channelHistory.push({\n            channelId: channelId,\n            userId: userId,\n            type: type,\n            createdAt: Date.now()\n        });\n        \n        this.saveChannelData();\n        console.log(`üìù Channel ${channelId} registered for user ${userId}`);\n    }\n\n    unregisterChannel(channelId) {\n        if (this.channelData.activeChannels[channelId]) {\n            delete this.channelData.activeChannels[channelId];\n            this.saveChannelData();\n            console.log(`üóëÔ∏è Channel ${channelId} unregistered`);\n        }\n    }\n\n    getChannelInfo(channelId) {\n        return this.channelData.activeChannels[channelId] || null;\n    }\n\n    getUserActiveChannels(userId) {\n        return Object.entries(this.channelData.activeChannels)\n            .filter(([channelId, data]) => data.userId === userId)\n            .map(([channelId, data]) => ({ channelId, ...data }));\n    }\n\n    getStats() {\n        return {\n            totalCreated: this.channelData.balanceCounter,\n            currentActive: Object.keys(this.channelData.activeChannels).length,\n            totalHistory: this.channelData.channelHistory.length\n        };\n    }\n}\n\nmodule.exports = new ChannelManager();","size_bytes":2692},"utils/ticketManager.js":{"content":"/**\n * Ticket Manager for Casino Bot\n * Handles creation and management of private ticket channels\n */\n\nconst fs = require('fs');\nconst TICKETS_FILE = './data/tickets.json';\n\n/**\n * Get default tickets data\n */\nfunction getDefaultData() {\n    return {\n        activeTickets: {},\n        ticketCounter: 0\n    };\n}\n\n/**\n * Load tickets data\n */\nfunction loadTickets() {\n    try {\n        if (!fs.existsSync('./data')) {\n            fs.mkdirSync('./data', { recursive: true });\n        }\n        \n        if (fs.existsSync(TICKETS_FILE)) {\n            const data = fs.readFileSync(TICKETS_FILE, 'utf8');\n            return JSON.parse(data);\n        }\n    } catch (error) {\n        console.error('Error loading tickets:', error);\n    }\n    \n    return getDefaultData();\n}\n\n/**\n * Save tickets data\n */\nfunction saveTickets(data) {\n    try {\n        if (!fs.existsSync('./data')) {\n            fs.mkdirSync('./data', { recursive: true });\n        }\n        \n        fs.writeFileSync(TICKETS_FILE, JSON.stringify(data, null, 2));\n        return true;\n    } catch (error) {\n        console.error('Error saving tickets:', error);\n        return false;\n    }\n}\n\n/**\n * Create a private ticket channel for user\n */\nasync function createTicket(guild, user, categoryId, staffRoleId, ticketType = 'general') {\n    try {\n        const data = loadTickets();\n        \n        // Check if user already has an active ticket\n        const existingTicket = Object.values(data.activeTickets).find(ticket => \n            ticket.userId === user.id && ticket.type === ticketType\n        );\n        \n        if (existingTicket) {\n            try {\n                const existingChannel = guild.channels.cache.get(existingTicket.channelId);\n                if (existingChannel) {\n                    return { \n                        success: false, \n                        error: 'existing',\n                        channel: existingChannel \n                    };\n                } else {\n                    // Channel doesn't exist anymore, remove from data\n                    delete data.activeTickets[existingTicket.ticketId];\n                    saveTickets(data);\n                }\n            } catch (error) {\n                console.log('Erreur v√©rification channel existant:', error);\n            }\n        }\n        \n        // Increment counter and create ticket ID\n        data.ticketCounter++;\n        const ticketId = `ticket-${data.ticketCounter}`;\n        \n        // Determine ticket name based on type\n        const ticketNames = {\n            'balance': 'üí∞-balance',\n            'profile': 'üë§-profile', \n            'general': 'üé´-casino'\n        };\n        \n        const channelName = `${ticketNames[ticketType] || 'üé´-casino'}-${user.username}`.toLowerCase();\n        \n        // Set up permissions\n        const permissionOverwrites = [\n            {\n                id: guild.id, // @everyone\n                deny: ['ViewChannel', 'SendMessages', 'ReadMessageHistory']\n            },\n            {\n                id: user.id,\n                allow: ['ViewChannel', 'SendMessages', 'ReadMessageHistory', 'AttachFiles', 'EmbedLinks']\n            }\n        ];\n        \n        // Add staff role permissions if provided\n        if (staffRoleId) {\n            permissionOverwrites.push({\n                id: staffRoleId,\n                allow: ['ViewChannel', 'SendMessages', 'ReadMessageHistory', 'AttachFiles', 'EmbedLinks', 'ManageMessages']\n            });\n        }\n        \n        // Create the channel\n        const channel = await guild.channels.create({\n            name: channelName,\n            type: 0, // Text channel\n            topic: `Private ${ticketType} session for ${user.username} ‚Ä¢ Ticket ID: ${ticketId}`,\n            parent: categoryId,\n            permissionOverwrites: permissionOverwrites\n        });\n        \n        // Save ticket data\n        data.activeTickets[ticketId] = {\n            ticketId,\n            channelId: channel.id,\n            userId: user.id,\n            username: user.username,\n            type: ticketType,\n            createdAt: Date.now(),\n            staffRoleId\n        };\n        \n        saveTickets(data);\n        \n        return {\n            success: true,\n            channel,\n            ticketId\n        };\n        \n    } catch (error) {\n        console.error('Erreur cr√©ation ticket:', error);\n        return {\n            success: false,\n            error: 'create_failed'\n        };\n    }\n}\n\n/**\n * Close a ticket channel\n */\nasync function closeTicket(ticketId, guild) {\n    try {\n        const data = loadTickets();\n        const ticket = data.activeTickets[ticketId];\n        \n        if (!ticket) {\n            return { success: false, error: 'not_found' };\n        }\n        \n        // Try to delete the channel\n        try {\n            const channel = guild.channels.cache.get(ticket.channelId);\n            if (channel) {\n                await channel.delete();\n            }\n        } catch (error) {\n            console.log('Erreur suppression channel:', error);\n        }\n        \n        // Remove from data\n        delete data.activeTickets[ticketId];\n        saveTickets(data);\n        \n        return { success: true };\n        \n    } catch (error) {\n        console.error('Erreur fermeture ticket:', error);\n        return { success: false, error: 'close_failed' };\n    }\n}\n\n/**\n * Get ticket by channel ID\n */\nfunction getTicketByChannel(channelId) {\n    const data = loadTickets();\n    return Object.values(data.activeTickets).find(ticket => \n        ticket.channelId === channelId\n    );\n}\n\n/**\n * Get ticket by user ID and type\n */\nfunction getTicketByUser(userId, ticketType = null) {\n    const data = loadTickets();\n    return Object.values(data.activeTickets).find(ticket => \n        ticket.userId === userId && (ticketType ? ticket.type === ticketType : true)\n    );\n}\n\n/**\n * Get all active tickets\n */\nfunction getAllTickets() {\n    const data = loadTickets();\n    return data.activeTickets;\n}\n\n/**\n * Clean up old/invalid tickets\n */\nasync function cleanupTickets(guild) {\n    try {\n        const data = loadTickets();\n        let cleanedCount = 0;\n        \n        for (const [ticketId, ticket] of Object.entries(data.activeTickets)) {\n            try {\n                const channel = guild.channels.cache.get(ticket.channelId);\n                if (!channel) {\n                    // Channel doesn't exist, remove ticket\n                    delete data.activeTickets[ticketId];\n                    cleanedCount++;\n                }\n            } catch (error) {\n                // Error checking channel, remove ticket\n                delete data.activeTickets[ticketId];\n                cleanedCount++;\n            }\n        }\n        \n        if (cleanedCount > 0) {\n            saveTickets(data);\n            console.log(`üßπ Nettoy√© ${cleanedCount} ticket(s) invalide(s)`);\n        }\n        \n        return cleanedCount;\n        \n    } catch (error) {\n        console.error('Erreur nettoyage tickets:', error);\n        return 0;\n    }\n}\n\nmodule.exports = {\n    createTicket,\n    closeTicket,\n    getTicketByChannel,\n    getTicketByUser,\n    getAllTickets,\n    cleanupTickets\n};","size_bytes":7195},"commands/setall.js":{"content":"const { SlashCommandBuilder, EmbedBuilder, PermissionFlagsBits, ChannelType, PermissionsBitField } = require('discord.js');\nconst fs = require('fs');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('setall')\n        .setDescription('Setup complete casino server structure (Admin only)')\n        .setDefaultMemberPermissions(PermissionFlagsBits.Administrator),\n    \n    async execute(interaction) {\n        // Check if interaction is too old\n        const interactionAge = Date.now() - interaction.createdTimestamp;\n        if (interactionAge > 10 * 60 * 1000) {\n            console.log('Interaction too old, ignored');\n            return;\n        }\n        \n        await interaction.deferReply({ ephemeral: true });\n        \n        try {\n            const guild = interaction.guild;\n            const config = {};\n            \n            // Create log category and channels\n            const logCategory = await guild.channels.create({\n                name: 'üìä-casino-logs',\n                type: ChannelType.GuildCategory,\n                permissionOverwrites: [\n                    {\n                        id: guild.roles.everyone,\n                        deny: [PermissionsBitField.Flags.ViewChannel]\n                    },\n                    {\n                        id: interaction.user.id,\n                        allow: [PermissionsBitField.Flags.ViewChannel]\n                    }\n                ]\n            });\n            \n            const balanceLogChannel = await guild.channels.create({\n                name: 'üí∞-balance-logs',\n                type: ChannelType.GuildText,\n                parent: logCategory,\n                permissionOverwrites: [\n                    {\n                        id: guild.roles.everyone,\n                        deny: [PermissionsBitField.Flags.SendMessages, PermissionsBitField.Flags.ViewChannel]\n                    }\n                ]\n            });\n            \n            const gamblingLogChannel = await guild.channels.create({\n                name: 'üé∞-gambling-logs',\n                type: ChannelType.GuildText,\n                parent: logCategory,\n                permissionOverwrites: [\n                    {\n                        id: guild.roles.everyone,\n                        deny: [PermissionsBitField.Flags.SendMessages, PermissionsBitField.Flags.ViewChannel]\n                    }\n                ]\n            });\n            \n            // Create main casino category\n            const casinoCategory = await guild.channels.create({\n                name: 'üé∞-casino',\n                type: ChannelType.GuildCategory\n            });\n            \n            // Create add balance category for temporary channels\n            const addBalanceCategory = await guild.channels.create({\n                name: 'üí∞-add-balance',\n                type: ChannelType.GuildCategory\n            });\n            \n            // Create public gambling category\n            const publicGamblingCategory = await guild.channels.create({\n                name: 'üéÆ-public-gambling',\n                type: ChannelType.GuildCategory\n            });\n            \n            // Create add balance channel\n            const addBalanceChannel = await guild.channels.create({\n                name: 'üí∞-add-balance',\n                type: ChannelType.GuildText,\n                parent: casinoCategory,\n                permissionOverwrites: [\n                    {\n                        id: guild.roles.everyone,\n                        deny: [PermissionsBitField.Flags.SendMessages]\n                    }\n                ]\n            });\n            \n            // Create gambling games channel\n            const gamblingChannel = await guild.channels.create({\n                name: 'üé∞-games',\n                type: ChannelType.GuildText,\n                parent: casinoCategory,\n                permissionOverwrites: [\n                    {\n                        id: guild.roles.everyone,\n                        deny: [PermissionsBitField.Flags.SendMessages]\n                    }\n                ]\n            });\n            \n            // Create private sessions channel\n            const sessionChannel = await guild.channels.create({\n                name: 'üîí-private-sessions',\n                type: ChannelType.GuildText,\n                parent: casinoCategory,\n                permissionOverwrites: [\n                    {\n                        id: guild.roles.everyone,\n                        deny: [PermissionsBitField.Flags.SendMessages]\n                    }\n                ]\n            });\n            \n            // Create terms channel\n            const termsChannel = await guild.channels.create({\n                name: 'üìã-terms-of-service',\n                type: ChannelType.GuildText,\n                parent: casinoCategory,\n                permissionOverwrites: [\n                    {\n                        id: guild.roles.everyone,\n                        deny: [PermissionsBitField.Flags.SendMessages]\n                    }\n                ]\n            });\n            \n            // Create public gambling channels\n            const blackjackChannel = await guild.channels.create({\n                name: 'üÉè-blackjack',\n                type: ChannelType.GuildText,\n                parent: publicGamblingCategory\n            });\n            \n            const rouletteChannel = await guild.channels.create({\n                name: 'üé≤-roulette',\n                type: ChannelType.GuildText,\n                parent: publicGamblingCategory\n            });\n            \n            const coinflipChannel = await guild.channels.create({\n                name: 'ü™ô-coinflip',\n                type: ChannelType.GuildText,\n                parent: publicGamblingCategory\n            });\n            \n            const liveRouletteChannel = await guild.channels.create({\n                name: 'üé∞-live-roulette',\n                type: ChannelType.GuildText,\n                parent: publicGamblingCategory,\n                topic: 'Live roulette spins every 30 seconds! Join the action!'\n            });\n            \n            // Save configuration\n            config.balanceLogChannel = balanceLogChannel.id;\n            config.gamblingLogChannel = gamblingLogChannel.id;\n            config.balanceChannel = addBalanceChannel.id;\n            config.gamblingChannel = gamblingChannel.id;\n            config.sessionChannel = sessionChannel.id;\n            config.termsChannel = termsChannel.id;\n            config.addBalanceCategory = addBalanceCategory.id;\n            config.blackjackChannel = blackjackChannel.id;\n            config.rouletteChannel = rouletteChannel.id;\n            config.coinflipChannel = coinflipChannel.id;\n            config.liveRouletteChannel = liveRouletteChannel.id;\n            \n            saveServerConfig(guild.id, config);\n            \n            // Send terms of service\n            await sendTermsOfService(termsChannel, guild);\n            \n            // Send panels\n            await sendBalancePanel(addBalanceChannel, guild);\n            await sendGamblingPanel(gamblingChannel, guild);\n            await sendSessionPanel(sessionChannel, guild);\n            \n            // Configure log channels\n            await configureLogChannels(guild.id, balanceLogChannel.id, gamblingLogChannel.id);\n            \n            const successEmbed = new EmbedBuilder()\n                .setColor('#00ff00')\n                .setTitle('‚úÖ Server Setup Complete')\n                .setDescription('Your casino server has been fully configured!')\n                .addFields(\n                    {\n                        name: 'üìä Log Channels',\n                        value: `${balanceLogChannel} - Balance logs\\n${gamblingLogChannel} - Gambling logs`,\n                        inline: false\n                    },\n                    {\n                        name: 'üé∞ Casino Channels',\n                        value: `${addBalanceChannel} - Add balance\\n${gamblingChannel} - Games\\n${sessionChannel} - Private sessions\\n${termsChannel} - Terms of service`,\n                        inline: false\n                    },\n                    {\n                        name: '‚öôÔ∏è Categories Created',\n                        value: `üìä Casino Logs\\nüé∞ Casino\\nüí∞ Add Balance (for temp channels)`,\n                        inline: false\n                    },\n                    {\n                        name: 'üîß Next Steps',\n                        value: 'Use `/whitelistpanel` to refresh panels if needed',\n                        inline: false\n                    }\n                )\n                .setFooter({ text: `Setup completed by ${interaction.user.username}` })\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [successEmbed] });\n            \n        } catch (error) {\n            console.error('Setall command error:', error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Setup Failed')\n                .setDescription('Failed to setup server. Please check bot permissions and try again.')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};\n\n// Helper functions\nfunction saveServerConfig(serverId, config) {\n    const path = './data/server_config.json';\n    let allConfigs = {};\n    \n    try {\n        if (fs.existsSync(path)) {\n            allConfigs = JSON.parse(fs.readFileSync(path, 'utf8'));\n        }\n    } catch (error) {\n        console.error('Error loading server configs:', error);\n    }\n    \n    allConfigs[serverId] = config;\n    \n    try {\n        if (!fs.existsSync('./data')) {\n            fs.mkdirSync('./data', { recursive: true });\n        }\n        fs.writeFileSync(path, JSON.stringify(allConfigs, null, 2));\n        console.log('‚úÖ Server configuration saved');\n    } catch (error) {\n        console.error('Error saving server config:', error);\n    }\n}\n\nasync function configureLogChannels(serverId, balanceChannelId, gamblingChannelId) {\n    const path = './data/log_config.json';\n    let config = {};\n    \n    try {\n        if (fs.existsSync(path)) {\n            config = JSON.parse(fs.readFileSync(path, 'utf8'));\n        }\n    } catch (error) {\n        console.error('Error loading log config:', error);\n    }\n    \n    if (!config[serverId]) {\n        config[serverId] = {};\n    }\n    \n    config[serverId].balanceLogChannel = balanceChannelId;\n    config[serverId].gamblingLogChannel = gamblingChannelId;\n    \n    try {\n        fs.writeFileSync(path, JSON.stringify(config, null, 2));\n        console.log('‚úÖ Log configuration saved');\n    } catch (error) {\n        console.error('Error saving log config:', error);\n    }\n}\n\nasync function sendTermsOfService(channel, guild) {\n    const embed = new EmbedBuilder()\n        .setColor('#ff6b6b')\n        .setTitle('üìã Terms of Service & Rules')\n        .setDescription('**Please read these terms carefully before participating in our casino.**')\n        .addFields(\n            {\n                name: '‚ö†Ô∏è Gambling Risks & Disclaimer',\n                value: '‚Ä¢ We are **not responsible** for any losses incurred while gambling\\n‚Ä¢ **Every bet should be considered lost** before placing it\\n‚Ä¢ Only gamble what you can **afford to lose completely**\\n‚Ä¢ Gambling involves significant risks and can be addictive\\n‚Ä¢ Set personal limits and stick to them',\n                inline: false\n            },\n            {\n                name: 'üîû Age Restrictions',\n                value: '‚Ä¢ You must be **18 years or older** to participate\\n‚Ä¢ Minors are strictly prohibited from gambling\\n‚Ä¢ Age verification may be required',\n                inline: false\n            },\n            {\n                name: 'ü§ù Community Rules',\n                value: '‚Ä¢ **Racism is strictly prohibited** and will result in immediate ban\\n‚Ä¢ Insults are allowed but must not be excessive or abusive\\n‚Ä¢ Respect other players and maintain a friendly environment\\n‚Ä¢ Spam and excessive toxicity will not be tolerated',\n                inline: false\n            },\n            {\n                name: 'üö´ Prohibited Activities',\n                value: '‚Ä¢ **Doxxing** (sharing personal information) is forbidden\\n‚Ä¢ **Real-life threats** or intimidation will result in immediate ban\\n‚Ä¢ **IRL repercussions** or harassment outside Discord is prohibited\\n‚Ä¢ Attempting to exploit bugs or cheat will result in account suspension',\n                inline: false\n            },\n            {\n                name: 'üí∞ Financial Responsibility',\n                value: '‚Ä¢ All transactions are final once confirmed\\n‚Ä¢ Double-check all bets before confirming\\n‚Ä¢ We are not responsible for user error or misunderstanding\\n‚Ä¢ Withdrawal limits may apply based on verification status',\n                inline: false\n            },\n            {\n                name: '‚öñÔ∏è Enforcement',\n                value: '‚Ä¢ Rules are enforced at staff discretion\\n‚Ä¢ Violations may result in warnings, temporary suspension, or permanent ban\\n‚Ä¢ Appeals can be made through modmail\\n‚Ä¢ Staff decisions are final',\n                inline: false\n            }\n        )\n        .setFooter({ \n            text: `By participating, you agree to these terms ‚Ä¢ ${guild.name} Casino`,\n            iconURL: guild.iconURL() \n        })\n        .setTimestamp();\n    \n    await channel.send({ embeds: [embed] });\n}\n\nasync function sendBalancePanel(channel, guild) {\n    const { ActionRowBuilder, ButtonBuilder, ButtonStyle } = require('discord.js');\n    \n    const embed = new EmbedBuilder()\n        .setColor('#00ff00')\n        .setTitle('üí∞ Add Balance to Your Account')\n        .setDescription('Click the button below to get a unique deposit address and start playing!')\n        .addFields(\n            {\n                name: '‚ö° Instant Detection',\n                value: 'Deposits are detected within 30 seconds',\n                inline: true\n            },\n            {\n                name: 'üîí Secure',\n                value: 'Each deposit gets a unique address',\n                inline: true\n            },\n            {\n                name: 'üìà Minimum Deposit',\n                value: '0.001 LTC',\n                inline: true\n            }\n        )\n        .setThumbnail('https://cryptologos.cc/logos/litecoin-ltc-logo.png')\n        .setFooter({ \n            text: `${guild.name} Casino ‚Ä¢ Safe & Secure`,\n            iconURL: guild.iconURL() \n        })\n        .setTimestamp();\n    \n    const button = new ActionRowBuilder()\n        .addComponents(\n            new ButtonBuilder()\n                .setCustomId('add_balance')\n                .setLabel('Deposit Money')\n                .setStyle(ButtonStyle.Success)\n                .setEmoji('üí∞')\n        );\n    \n    await channel.send({ embeds: [embed], components: [button] });\n}\n\nasync function sendGamblingPanel(channel, guild) {\n    const { ActionRowBuilder, ButtonBuilder, ButtonStyle } = require('discord.js');\n    \n    const embed = new EmbedBuilder()\n        .setColor('#9932cc')\n        .setTitle('üé∞ Casino Games')\n        .setDescription('Welcome to our casino! Click on any game below to learn how to play.')\n        .addFields(\n            {\n                name: 'üÉè Blackjack',\n                value: 'Classic card game - Beat the dealer without going over 21!',\n                inline: true\n            },\n            {\n                name: 'üé≤ Roulette',\n                value: 'Place your bets on numbers, colors, or odds/evens!',\n                inline: true\n            },\n            {\n                name: 'ü™ô Coinflip',\n                value: 'Simple 50/50 game - Choose heads or tails!',\n                inline: true\n            }\n        )\n        .setFooter({ \n            text: `${guild.name} Casino ‚Ä¢ Good Luck!`,\n            iconURL: guild.iconURL() \n        })\n        .setTimestamp();\n    \n    const buttons = new ActionRowBuilder()\n        .addComponents(\n            new ButtonBuilder()\n                .setCustomId('explain_blackjack')\n                .setLabel('üÉè How to Play Blackjack')\n                .setStyle(ButtonStyle.Primary),\n            new ButtonBuilder()\n                .setCustomId('explain_roulette')\n                .setLabel('üé≤ How to Play Roulette')\n                .setStyle(ButtonStyle.Primary),\n            new ButtonBuilder()\n                .setCustomId('explain_coinflip')\n                .setLabel('ü™ô How to Play Coinflip')\n                .setStyle(ButtonStyle.Primary)\n        );\n    \n    await channel.send({ embeds: [embed], components: [buttons] });\n}\n\nasync function sendSessionPanel(channel, guild) {\n    const { ActionRowBuilder, ButtonBuilder, ButtonStyle } = require('discord.js');\n    \n    const embed = new EmbedBuilder()\n        .setColor('#5865f2')\n        .setTitle('üîí Private Gaming Sessions')\n        .setDescription('Create private gaming sessions where only you and invited players can participate.')\n        .addFields(\n            {\n                name: 'üë• Session Features',\n                value: '‚Ä¢ Private gaming environment\\n‚Ä¢ Invite specific players\\n‚Ä¢ Control who can join\\n‚Ä¢ Enhanced privacy',\n                inline: true\n            },\n            {\n                name: 'üéÆ Available Games',\n                value: '‚Ä¢ Private Blackjack tables\\n‚Ä¢ Exclusive Roulette wheels\\n‚Ä¢ Coinflip tournaments\\n‚Ä¢ Custom betting limits',\n                inline: true\n            },\n            {\n                name: '‚öôÔ∏è Session Management',\n                value: '‚Ä¢ Use `/createsession` to start\\n‚Ä¢ Use `/addplayer` to invite\\n‚Ä¢ Sessions auto-close after inactivity',\n                inline: false\n            }\n        )\n        .setFooter({ \n            text: `${guild.name} Casino ‚Ä¢ Private Gaming`,\n            iconURL: guild.iconURL() \n        })\n        .setTimestamp();\n    \n    const button = new ActionRowBuilder()\n        .addComponents(\n            new ButtonBuilder()\n                .setCustomId('create_private_session')\n                .setLabel('üîí Create Private Session')\n                .setStyle(ButtonStyle.Secondary)\n                .setEmoji('üîí')\n        );\n    \n    await channel.send({ embeds: [embed], components: [button] });\n}","size_bytes":18452},"commands/whitelistpanel.js":{"content":"const { SlashCommandBuilder, EmbedBuilder, PermissionFlagsBits } = require('discord.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('whitelistpanel')\n        .setDescription('Send panels to configured channels (Admin only)')\n        .addStringOption(option =>\n            option.setName('type')\n                .setDescription('Type of panel to send')\n                .setRequired(true)\n                .addChoices(\n                    { name: 'üé∞ Gambling Panel', value: 'gambling' },\n                    { name: 'üí∞ Add Balance Panel', value: 'balance' },\n                    { name: 'üîí Private Session Panel', value: 'session' }\n                )\n        )\n        .setDefaultMemberPermissions(PermissionFlagsBits.Administrator),\n    \n    async execute(interaction) {\n        // Check if interaction is too old\n        const interactionAge = Date.now() - interaction.createdTimestamp;\n        if (interactionAge > 10 * 60 * 1000) {\n            console.log('Interaction too old, ignored');\n            return;\n        }\n        \n        await interaction.deferReply({ ephemeral: true });\n        \n        try {\n            const panelType = interaction.options.getString('type');\n            const config = loadPanelConfig();\n            \n            let sent = false;\n            let targetChannel = null;\n            \n            if (panelType === 'gambling' && config.gamblingChannel) {\n                targetChannel = await interaction.guild.channels.fetch(config.gamblingChannel);\n                if (targetChannel) {\n                    await sendGamblingPanel(targetChannel, interaction.guild);\n                    sent = true;\n                }\n            } else if (panelType === 'balance' && config.balanceChannel) {\n                targetChannel = await interaction.guild.channels.fetch(config.balanceChannel);\n                if (targetChannel) {\n                    await sendBalancePanel(targetChannel, interaction.guild);\n                    sent = true;\n                }\n            } else if (panelType === 'session' && config.sessionChannel) {\n                targetChannel = await interaction.guild.channels.fetch(config.sessionChannel);\n                if (targetChannel) {\n                    await sendSessionPanel(targetChannel, interaction.guild);\n                    sent = true;\n                }\n            }\n            \n            const responseEmbed = new EmbedBuilder()\n                .setTimestamp();\n            \n            if (sent) {\n                responseEmbed\n                    .setColor('#00ff00')\n                    .setTitle('‚úÖ Panel Sent')\n                    .setDescription(`${getPanelName(panelType)} has been sent to ${targetChannel}.`);\n            } else {\n                responseEmbed\n                    .setColor('#ff9900')\n                    .setTitle('‚ö†Ô∏è Panel Not Configured')\n                    .setDescription(`No channel configured for ${getPanelName(panelType)}. Use \\`/setall\\` to set up channels.`);\n            }\n            \n            await interaction.editReply({ embeds: [responseEmbed] });\n            \n        } catch (error) {\n            console.error('Whitelistpanel command error:', error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Error')\n                .setDescription('Failed to send panel. Please try again.')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};\n\n// Helper functions\nfunction loadPanelConfig() {\n    const fs = require('fs');\n    const path = './data/server_config.json';\n    \n    try {\n        if (fs.existsSync(path)) {\n            return JSON.parse(fs.readFileSync(path, 'utf8'));\n        }\n    } catch (error) {\n        console.error('Error loading panel config:', error);\n    }\n    \n    return {};\n}\n\nfunction getPanelName(type) {\n    const names = {\n        'gambling': 'üé∞ Gambling Panel',\n        'balance': 'üí∞ Add Balance Panel',\n        'session': 'üîí Private Session Panel'\n    };\n    return names[type] || type;\n}\n\nasync function sendGamblingPanel(channel, guild) {\n    const { ActionRowBuilder, ButtonBuilder, ButtonStyle } = require('discord.js');\n    \n    const embed = new EmbedBuilder()\n        .setColor('#9932cc')\n        .setTitle('üé∞ Casino Games')\n        .setDescription('Welcome to our casino! Click on any game below to learn how to play.')\n        .addFields(\n            {\n                name: 'üÉè Blackjack',\n                value: 'Classic card game - Beat the dealer without going over 21!',\n                inline: true\n            },\n            {\n                name: 'üé≤ Roulette',\n                value: 'Place your bets on numbers, colors, or odds/evens!',\n                inline: true\n            },\n            {\n                name: 'ü™ô Coinflip',\n                value: 'Simple 50/50 game - Choose heads or tails!',\n                inline: true\n            }\n        )\n        .setFooter({ \n            text: `${guild.name} Casino ‚Ä¢ Good Luck!`,\n            iconURL: guild.iconURL() \n        })\n        .setTimestamp();\n    \n    const buttons = new ActionRowBuilder()\n        .addComponents(\n            new ButtonBuilder()\n                .setCustomId('explain_blackjack')\n                .setLabel('üÉè How to Play Blackjack')\n                .setStyle(ButtonStyle.Primary),\n            new ButtonBuilder()\n                .setCustomId('explain_roulette')\n                .setLabel('üé≤ How to Play Roulette')\n                .setStyle(ButtonStyle.Primary),\n            new ButtonBuilder()\n                .setCustomId('explain_coinflip')\n                .setLabel('ü™ô How to Play Coinflip')\n                .setStyle(ButtonStyle.Primary)\n        );\n    \n    await channel.send({ embeds: [embed], components: [buttons] });\n}\n\nasync function sendBalancePanel(channel, guild) {\n    const { ActionRowBuilder, ButtonBuilder, ButtonStyle } = require('discord.js');\n    \n    const embed = new EmbedBuilder()\n        .setColor('#00ff00')\n        .setTitle('üí∞ Add Balance to Your Account')\n        .setDescription('Click the button below to get a unique deposit address and start playing!')\n        .addFields(\n            {\n                name: '‚ö° Instant Detection',\n                value: 'Deposits are detected within 30 seconds',\n                inline: true\n            },\n            {\n                name: 'üîí Secure',\n                value: 'Each deposit gets a unique address',\n                inline: true\n            },\n            {\n                name: 'üìà Minimum Deposit',\n                value: '0.001 LTC',\n                inline: true\n            }\n        )\n        .setThumbnail('https://cryptologos.cc/logos/litecoin-ltc-logo.png')\n        .setFooter({ \n            text: `${guild.name} Casino ‚Ä¢ Safe & Secure`,\n            iconURL: guild.iconURL() \n        })\n        .setTimestamp();\n    \n    const button = new ActionRowBuilder()\n        .addComponents(\n            new ButtonBuilder()\n                .setCustomId('add_balance')\n                .setLabel('Deposit Money')\n                .setStyle(ButtonStyle.Success)\n                .setEmoji('üí∞')\n        );\n    \n    await channel.send({ embeds: [embed], components: [button] });\n}\n\nasync function sendSessionPanel(channel, guild) {\n    const { ActionRowBuilder, ButtonBuilder, ButtonStyle } = require('discord.js');\n    \n    const embed = new EmbedBuilder()\n        .setColor('#5865f2')\n        .setTitle('üîí Private Gaming Sessions')\n        .setDescription('Create private gaming sessions where only you and invited players can participate.')\n        .addFields(\n            {\n                name: 'üë• Session Features',\n                value: '‚Ä¢ Private gaming environment\\n‚Ä¢ Invite specific players\\n‚Ä¢ Control who can join\\n‚Ä¢ Enhanced privacy',\n                inline: true\n            },\n            {\n                name: 'üéÆ Available Games',\n                value: '‚Ä¢ Private Blackjack tables\\n‚Ä¢ Exclusive Roulette wheels\\n‚Ä¢ Coinflip tournaments\\n‚Ä¢ Custom betting limits',\n                inline: true\n            },\n            {\n                name: '‚öôÔ∏è Session Management',\n                value: '‚Ä¢ Use `/createsession` to start\\n‚Ä¢ Use `/addplayer` to invite\\n‚Ä¢ Sessions auto-close after inactivity',\n                inline: false\n            }\n        )\n        .setFooter({ \n            text: `${guild.name} Casino ‚Ä¢ Private Gaming`,\n            iconURL: guild.iconURL() \n        })\n        .setTimestamp();\n    \n    const button = new ActionRowBuilder()\n        .addComponents(\n            new ButtonBuilder()\n                .setCustomId('create_private_session')\n                .setLabel('üîí Create Private Session')\n                .setStyle(ButtonStyle.Secondary)\n                .setEmoji('üîí')\n        );\n    \n    await channel.send({ embeds: [embed], components: [button] });\n}","size_bytes":9018},"utils/liveRoulette.js":{"content":"const { EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle } = require('discord.js');\n\nclass LiveRoulette {\n    constructor(client) {\n        this.client = client;\n        this.isRunning = false;\n        this.currentBets = new Map(); // userId -> { bets: Map, totalBet: number }\n        this.spinInterval = null;\n        this.bettingPhase = true;\n        this.timeLeft = 30;\n        this.liveChannelId = null;\n        this.currentMessage = null;\n        \n        // Roulette wheel configuration\n        this.wheel = {\n            0: 'green',\n            1: 'red', 2: 'black', 3: 'red', 4: 'black', 5: 'red', 6: 'black', 7: 'red', 8: 'black', 9: 'red', 10: 'black',\n            11: 'black', 12: 'red', 13: 'black', 14: 'red', 15: 'black', 16: 'red', 17: 'black', 18: 'red', 19: 'red', 20: 'black',\n            21: 'red', 22: 'black', 23: 'red', 24: 'black', 25: 'red', 26: 'black', 27: 'red', 28: 'black', 29: 'black', 30: 'red',\n            31: 'black', 32: 'red', 33: 'black', 34: 'red', 35: 'black', 36: 'red'\n        };\n    }\n\n    start(channelId) {\n        if (this.isRunning) return;\n        \n        this.liveChannelId = channelId;\n        this.isRunning = true;\n        this.bettingPhase = true;\n        this.timeLeft = 30;\n        \n        console.log('üé∞ Starting live roulette in channel:', channelId);\n        this.runCycle();\n    }\n\n    stop() {\n        if (!this.isRunning) return;\n        \n        this.isRunning = false;\n        if (this.spinInterval) {\n            clearTimeout(this.spinInterval);\n            this.spinInterval = null;\n        }\n        \n        console.log('üõë Live roulette stopped');\n    }\n\n    async runCycle() {\n        if (!this.isRunning) return;\n        \n        try {\n            // Betting phase (30 seconds)\n            this.bettingPhase = true;\n            this.timeLeft = 30;\n            await this.updateDisplay();\n            \n            // Countdown\n            const countdownInterval = setInterval(async () => {\n                this.timeLeft--;\n                if (this.timeLeft <= 0) {\n                    clearInterval(countdownInterval);\n                    await this.endBettingAndSpin();\n                } else {\n                    await this.updateDisplay();\n                }\n            }, 1000);\n            \n        } catch (error) {\n            console.error('‚ùå Live roulette cycle error:', error);\n            setTimeout(() => this.runCycle(), 5000); // Retry in 5 seconds\n        }\n    }\n\n    async endBettingAndSpin() {\n        this.bettingPhase = false;\n        \n        // Spin the wheel\n        const result = Math.floor(Math.random() * 37);\n        const color = this.wheel[result];\n        \n        // Show spinning animation\n        await this.showSpinAnimation(result, color);\n        \n        // Process payouts\n        await this.processPayouts(result, color);\n        \n        // Clear bets for next round\n        this.currentBets.clear();\n        \n        // Start next cycle after 5 seconds\n        setTimeout(() => this.runCycle(), 5000);\n    }\n\n    async showSpinAnimation(finalResult, finalColor) {\n        const channel = this.client.channels.cache.get(this.liveChannelId);\n        if (!channel) return;\n\n        const spinEmbed = new EmbedBuilder()\n            .setColor('#ff6b00')\n            .setTitle('üé∞ ROULETTE IS SPINNING!')\n            .setDescription('The wheel is spinning... üå™Ô∏è')\n            .addFields(\n                { name: '‚è≥ Status', value: 'Spinning...', inline: true },\n                { name: 'üéØ Result', value: 'Coming soon...', inline: true }\n            )\n            .setTimestamp();\n\n        if (this.currentMessage) {\n            await this.currentMessage.edit({ embeds: [spinEmbed], components: [] });\n        }\n\n        // Animate for 3 seconds\n        await new Promise(resolve => setTimeout(resolve, 3000));\n\n        // Show result\n        const colorEmoji = finalColor === 'red' ? 'üî¥' : finalColor === 'black' ? '‚ö´' : 'üü¢';\n        const resultEmbed = new EmbedBuilder()\n            .setColor(finalColor === 'red' ? '#ff0000' : finalColor === 'black' ? '#000000' : '#00ff00')\n            .setTitle('üéØ ROULETTE RESULT!')\n            .setDescription(`The ball landed on: **${finalResult}** ${colorEmoji}`)\n            .addFields(\n                { name: 'üé≤ Number', value: finalResult.toString(), inline: true },\n                { name: 'üé® Color', value: finalColor.charAt(0).toUpperCase() + finalColor.slice(1), inline: true },\n                { name: 'üîÑ Next Round', value: 'Starting in 5 seconds...', inline: true }\n            )\n            .setTimestamp();\n\n        if (this.currentMessage) {\n            await this.currentMessage.edit({ embeds: [resultEmbed], components: [] });\n        }\n    }\n\n    async processPayouts(result, color) {\n        const userProfiles = require('./userProfiles.js');\n        const logManager = require('./logManager.js');\n        \n        for (const [userId, betData] of this.currentBets) {\n            let totalWinnings = 0;\n            \n            for (const [betType, amount] of betData.bets) {\n                const payout = this.calculatePayout(betType, amount, result, color);\n                if (payout > 0) {\n                    totalWinnings += payout;\n                }\n            }\n            \n            if (totalWinnings > 0) {\n                try {\n                    const profile = userProfiles.getUserProfile(userId);\n                    profile.balance += totalWinnings;\n                    userProfiles.saveProfile(userId, profile);\n                    \n                    // Log win\n                    const channel = this.client.channels.cache.get(this.liveChannelId);\n                    if (channel) {\n                        await logManager.sendGamblingLog(this.client, channel.guild.id, {\n                            type: 'win',\n                            user: await this.client.users.fetch(userId),\n                            game: 'Live Roulette',\n                            amount: totalWinnings,\n                            result: `${result} ${color}`\n                        });\n                    }\n                } catch (error) {\n                    console.error('Error processing payout for user:', userId, error);\n                }\n            }\n        }\n    }\n\n    calculatePayout(betType, amount, result, color) {\n        if (betType.startsWith('number_')) {\n            const betNumber = parseInt(betType.split('_')[1]);\n            return betNumber === result ? amount * 35 : 0;\n        }\n        \n        switch (betType) {\n            case 'red':\n                return color === 'red' ? amount * 2 : 0;\n            case 'black':\n                return color === 'black' ? amount * 2 : 0;\n            case 'even':\n                return result !== 0 && result % 2 === 0 ? amount * 2 : 0;\n            case 'odd':\n                return result !== 0 && result % 2 === 1 ? amount * 2 : 0;\n            case 'low':\n                return result >= 1 && result <= 18 ? amount * 2 : 0;\n            case 'high':\n                return result >= 19 && result <= 36 ? amount * 2 : 0;\n            case 'dozen1':\n                return result >= 1 && result <= 12 ? amount * 3 : 0;\n            case 'dozen2':\n                return result >= 13 && result <= 24 ? amount * 3 : 0;\n            case 'dozen3':\n                return result >= 25 && result <= 36 ? amount * 3 : 0;\n            default:\n                return 0;\n        }\n    }\n\n    async updateDisplay() {\n        const channel = this.client.channels.cache.get(this.liveChannelId);\n        if (!channel) return;\n\n        const embed = new EmbedBuilder()\n            .setColor(this.bettingPhase ? '#00ff00' : '#ff0000')\n            .setTitle('üé∞ LIVE ROULETTE')\n            .setDescription(this.bettingPhase ? 'üü¢ **BETTING OPEN** - Place your bets!' : 'üî¥ **BETTING CLOSED** - Spinning...')\n            .addFields(\n                { name: '‚è∞ Time Left', value: this.bettingPhase ? `${this.timeLeft} seconds` : 'Spinning...', inline: true },\n                { name: 'üé≤ Total Bets', value: this.currentBets.size.toString(), inline: true },\n                { name: 'üí∞ Min Bet', value: '0.001 LTC', inline: true }\n            )\n            .setFooter({ text: 'Live Roulette ‚Ä¢ Spins every 30 seconds' })\n            .setTimestamp();\n\n        const components = this.bettingPhase ? this.createBettingButtons() : [];\n\n        try {\n            if (this.currentMessage) {\n                await this.currentMessage.edit({ embeds: [embed], components });\n            } else {\n                this.currentMessage = await channel.send({ embeds: [embed], components });\n            }\n        } catch (error) {\n            console.error('Error updating live roulette display:', error);\n        }\n    }\n\n    createBettingButtons() {\n        const colorRow = new ActionRowBuilder()\n            .addComponents(\n                new ButtonBuilder()\n                    .setCustomId('live_roulette_red')\n                    .setLabel('Red (1:1)')\n                    .setStyle(ButtonStyle.Danger)\n                    .setEmoji('üî¥'),\n                new ButtonBuilder()\n                    .setCustomId('live_roulette_black')\n                    .setLabel('Black (1:1)')\n                    .setStyle(ButtonStyle.Secondary)\n                    .setEmoji('‚ö´'),\n                new ButtonBuilder()\n                    .setCustomId('live_roulette_odd')\n                    .setLabel('Odd (1:1)')\n                    .setStyle(ButtonStyle.Primary)\n                    .setEmoji('1Ô∏è‚É£'),\n                new ButtonBuilder()\n                    .setCustomId('live_roulette_even')\n                    .setLabel('Even (1:1)')\n                    .setStyle(ButtonStyle.Primary)\n                    .setEmoji('2Ô∏è‚É£')\n            );\n\n        return [colorRow];\n    }\n\n    placeBet(userId, betType, amount) {\n        if (!this.bettingPhase) {\n            return { success: false, message: 'Betting is closed for this round!' };\n        }\n\n        if (!this.currentBets.has(userId)) {\n            this.currentBets.set(userId, { bets: new Map(), totalBet: 0 });\n        }\n\n        const userBets = this.currentBets.get(userId);\n        \n        // Add or update bet\n        if (userBets.bets.has(betType)) {\n            userBets.totalBet -= userBets.bets.get(betType);\n        }\n        \n        userBets.bets.set(betType, amount);\n        userBets.totalBet += amount;\n\n        return { success: true, message: 'Bet placed successfully!' };\n    }\n\n    getUserBets(userId) {\n        return this.currentBets.get(userId) || { bets: new Map(), totalBet: 0 };\n    }\n}\n\nmodule.exports = LiveRoulette;","size_bytes":10689},"replit.md":{"content":"# Overview\n\nThis project is a complete Litecoin casino Discord bot system built with Node.js and Discord.js v14+. The application provides full wallet management including address generation, deposit monitoring, withdrawal capabilities, and a complete Discord bot interface with slash commands, interactive panels, and real-time notifications. The system integrates BlockCypher API for fast blockchain interactions and litecore-lib for cryptographic operations. The bot features automatic deposit detection, balance management, currency conversion, user profiles, and is designed as a foundation for casino gaming features like blackjack and roulette.\n\n# User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n# System Architecture\n\n## Core Application Structure\nThe application follows a modular Discord bot architecture with separate command handlers, event listeners, and utility modules. The system includes both a standalone Litecoin wallet system and a complete Discord bot integration with slash commands, interactive panels, and real-time user notifications.\n\n## Discord Bot Architecture\n- **Main Bot File**: `discord-bot.js` - Central Discord client and interaction handling\n- **Commands System**: Modular slash commands in `/commands/` directory\n- **Events System**: Discord event handlers in `/events/` directory\n- **User Profiles**: Complete user management system with balance tracking\n- **Currency Conversion**: Real-time EUR/USD exchange rates with external APIs\n\n## Address Management System\n- **Address Generation**: Uses litecore-lib to create cryptographically secure Litecoin address pairs\n- **Data Persistence**: JSON file-based storage system for addresses and private keys\n- **Address Structure**: Each address record contains the public address, private key, creation timestamp, and balance tracking\n\n## Blockchain Integration\n- **Direct Library Integration**: Uses litecore-lib and direct blockchain explorers, eliminating API rate limits and costs\n- **Network Configuration**: Configured for Litecoin mainnet (LTC) operations\n- **Real-time Monitoring**: 2-minute interval deposit detection with Discord notifications\n- **No External API Dependencies**: Completely self-contained system without third-party API costs\n\n## File System Design\n- **Configuration Management**: Environment-based API key handling with fallback defaults\n- **Data Storage**: JSON-based persistence with error handling and data validation\n- **Modular Functions**: Clear separation between address generation, loading, and saving operations\n\n## Security Considerations\n- Private keys are generated using cryptographically secure random number generation\n- Local file storage for sensitive data (suitable for development, would need enhancement for production)\n- API key configuration system for secure third-party service integration\n\n# External Dependencies\n\n## Discord Integration\n- **discord.js**: Discord API wrapper v14+ for bot functionality, slash commands, and interactions\n- **Discord Bot Features**: Slash commands, button interactions, embed messages, and real-time notifications\n\n## Blockchain Libraries\n- **litecore-lib**: Core Litecoin cryptographic library for address generation and private key management\n- **Direct Blockchain Integration**: Direct connection to blockchain explorers without paid APIs\n- **No Rate Limits**: Unlimited transactions and monitoring without API restrictions\n\n## HTTP and Utility Libraries  \n- **axios**: HTTP client for API communications with blockchain and currency services\n- **dotenv**: Environment variable management for secure API key storage\n- **Node.js fs module**: File system operations for local data persistence\n\n## Currency APIs\n- **ExchangeRate-API**: Real-time currency conversion for EUR/USD pairs\n- **CoinGecko API**: Cryptocurrency price data for Litecoin USD/EUR prices\n\n## Development Dependencies\n- **@types/node**: TypeScript definitions for Node.js development support\n\n## Implemented Features\nThe Discord bot includes complete casino functionality with:\n\n### Core Casino System\n- User profiles with balance tracking and recovery systems\n- Complete deposit detection and monitoring with direct blockchain integration\n- Currency conversion between EUR/USD with real-time exchange rates\n- Secure password protection system with recovery keys\n- Enhanced balance display (shows \"0\" instead of \"0.00000000\" for zero balances)\n\n### Panel and Ticket Management System\n- **Panel Management**: Channel-specific casino panels that can be configured with `/setpanel`\n- **Ticket System**: Private ticket channels created when users interact with panels (similar to TicketTool)\n- **Whitelist System**: Server whitelisting with `/addwhitelist` command for panel management\n- **Smart Interactions**: Panel buttons (`panel_add_balance`, `panel_view_profile`) create private channels for users\n\n### Advanced Features\n- **Rate Limit Protection**: Smart API rate limiting with 8-second delays and proper 429 error handling\n- **French Console Logs**: Console output in French while maintaining English user interface\n- **Robust Error Handling**: Automatic reconnection system preventing bot disconnections\n- **Private Channel Management**: Automatic ticket cleanup and category organization\n- **Active Deposit Management**: `/stopallactives` command to manage monitoring\n\n### Available Slash Commands (20 total)\n- `/balance`, `/profile`, `/casino` - Core user functions\n- `/setpassword`, `/changepassword`, `/recoverykey` - Security system  \n- `/givebal`, `/cashout` - Balance management\n- `/setpanel`, `/addwhitelist` - Panel and server management\n- `/convert-eur-usd`, `/convert-usd-eur` - Currency tools\n- `/enable`, `/stopallactives` - Monitoring controls\n- `/testgamble`, `/resetrecovery` - Testing and recovery\n- `/blackjack`, `/roulette` - Casino games\n- `/setlogbal`, `/setloggamble` - Logging configuration\n\n### Casino Games System (New!)\n- **Blackjack Game**: Complete blackjack implementation with hit, stand, and double down mechanics\n- **Roulette Game**: Full European roulette with number bets (35:1), color bets (1:1), and even/odd bets (1:1)\n- **Game State Management**: Active games tracking with 2-minute auto-timeout\n- **Interactive Controls**: Button-based gameplay with real-time updates\n- **Comprehensive Logging**: All game results logged to configured channels\n\n### Enhanced Deposit System\n- **Always New Addresses**: Each deposit request generates a completely new address\n- **Enhanced Channel Management**: Private channels with auto-close after 20 minutes\n- **Non-Ephemeral Messages**: Deposit addresses sent as normal messages for easy copying\n- **Staff Ping Instructions**: Clear 20-minute timeout warnings with staff ping guidance\n- **Advanced Logging**: Comprehensive logging system for all deposit and gambling activities\n\n### Logging System (New!)\n- **Balance Log Channel**: Configure with `/setlogbal` for deposit confirmations and address generations\n- **Gambling Log Channel**: Configure with `/setloggamble` for game results and big wins\n- **Automated Big Win Detection**: Special notifications for wins 5x or larger\n- **Channel Auto-Management**: Automatic ticket cleanup and category organization\n\nThe system is now production-ready with complete casino functionality including blackjack and roulette games, enhanced user experience, and comprehensive logging systems.","size_bytes":7377},"utils/currencyConverter.js":{"content":"const axios = require('axios');\n\n// Free currency conversion API (you can change this to your preferred service)\nconst API_BASE_URL = 'https://api.exchangerate-api.com/v4/latest';\n\n/**\n * Get exchange rate between two currencies\n * @param {string} from - Source currency (e.g., 'EUR')\n * @param {string} to - Target currency (e.g., 'USD')\n * @returns {Promise<number>} Exchange rate\n */\nasync function getExchangeRate(from, to) {\n    try {\n        const response = await axios.get(`${API_BASE_URL}/${from}`, {\n            timeout: 5000\n        });\n        \n        if (response.data && response.data.rates && response.data.rates[to]) {\n            return response.data.rates[to];\n        } else {\n            throw new Error(`Exchange rate not found for ${from} to ${to}`);\n        }\n    } catch (error) {\n        console.error('Currency API error:', error.message);\n        throw new Error('Failed to fetch exchange rate. Please try again later.');\n    }\n}\n\n/**\n * Convert amount from one currency to another\n * @param {number} amount - Amount to convert\n * @param {string} from - Source currency\n * @param {string} to - Target currency\n * @returns {Promise<Object>} Conversion result\n */\nasync function convertCurrency(amount, from, to) {\n    if (amount <= 0) {\n        throw new Error('Amount must be greater than 0');\n    }\n    \n    const rate = await getExchangeRate(from, to);\n    const convertedAmount = amount * rate;\n    \n    return {\n        originalAmount: amount,\n        convertedAmount: parseFloat(convertedAmount.toFixed(2)),\n        fromCurrency: from.toUpperCase(),\n        toCurrency: to.toUpperCase(),\n        exchangeRate: rate,\n        timestamp: new Date().toISOString()\n    };\n}\n\n/**\n * Get multiple currency rates for display\n * @param {string} baseCurrency - Base currency (e.g., 'USD')\n * @returns {Promise<Object>} Multiple exchange rates\n */\nasync function getMultipleRates(baseCurrency = 'USD') {\n    try {\n        const response = await axios.get(`${API_BASE_URL}/${baseCurrency}`, {\n            timeout: 5000\n        });\n        \n        if (response.data && response.data.rates) {\n            return {\n                base: baseCurrency.toUpperCase(),\n                rates: response.data.rates,\n                lastUpdated: response.data.date || new Date().toISOString().split('T')[0]\n            };\n        } else {\n            throw new Error('Failed to fetch exchange rates');\n        }\n    } catch (error) {\n        console.error('Currency API error:', error.message);\n        throw new Error('Failed to fetch exchange rates. Please try again later.');\n    }\n}\n\n/**\n * Format currency amount for display\n * @param {number} amount - Amount to format\n * @param {string} currency - Currency code\n * @returns {string} Formatted currency string\n */\nfunction formatCurrency(amount, currency) {\n    const symbols = {\n        'USD': '$',\n        'EUR': '‚Ç¨',\n        'GBP': '¬£',\n        'JPY': '¬•',\n        'BTC': '‚Çø',\n        'LTC': '≈Å'\n    };\n    \n    const symbol = symbols[currency.toUpperCase()] || currency.toUpperCase();\n    \n    if (currency.toUpperCase() === 'JPY') {\n        return `${symbol}${Math.round(amount).toLocaleString()}`;\n    }\n    \n    return `${symbol}${amount.toLocaleString('en-US', { \n        minimumFractionDigits: 2, \n        maximumFractionDigits: 2 \n    })}`;\n}\n\n/**\n * Get current Litecoin price in specified currency\n * @param {string} currency - Target currency (default: USD)\n * @returns {Promise<Object>} LTC price data\n */\nasync function getLitecoinPrice(currency = 'USD') {\n    try {\n        // Using CoinGecko API for crypto prices (free tier)\n        const response = await axios.get(`https://api.coingecko.com/api/v3/simple/price?ids=litecoin&vs_currencies=${currency.toLowerCase()}`, {\n            timeout: 5000\n        });\n        \n        if (response.data && response.data.litecoin) {\n            const price = response.data.litecoin[currency.toLowerCase()];\n            return {\n                price: price,\n                currency: currency.toUpperCase(),\n                symbol: 'LTC',\n                timestamp: new Date().toISOString()\n            };\n        } else {\n            throw new Error('Litecoin price not found');\n        }\n    } catch (error) {\n        console.error('Crypto price API error:', error.message);\n        throw new Error('Failed to fetch Litecoin price. Please try again later.');\n    }\n}\n\nmodule.exports = {\n    getExchangeRate,\n    convertCurrency,\n    getMultipleRates,\n    formatCurrency,\n    getLitecoinPrice\n};","size_bytes":4527},"utils/formatters.js":{"content":"/**\n * Utilities for formatting numbers and currencies\n */\n\n/**\n * Format LTC amount to remove unnecessary trailing zeros\n * @param {number} amount - LTC amount\n * @returns {string} - Formatted LTC string\n */\nfunction formatLTC(amount) {\n    if (amount === 0) {\n        return '0';\n    }\n    \n    // Convert to fixed 8 decimal places first\n    const fixed = amount.toFixed(8);\n    \n    // Remove trailing zeros and unnecessary decimal point\n    const formatted = parseFloat(fixed).toString();\n    \n    // If the number is very small, show scientific notation\n    if (amount < 0.00001 && amount > 0) {\n        return amount.toExponential(3);\n    }\n    \n    return formatted;\n}\n\n/**\n * Format USD amount with 2 decimal places\n * @param {number} amount - USD amount\n * @returns {string} - Formatted USD string\n */\nfunction formatUSD(amount) {\n    return amount.toFixed(2);\n}\n\n/**\n * Format percentage with 1 decimal place\n * @param {number} percentage - Percentage value\n * @returns {string} - Formatted percentage string\n */\nfunction formatPercentage(percentage) {\n    return percentage.toFixed(1);\n}\n\nmodule.exports = {\n    formatLTC,\n    formatUSD,\n    formatPercentage\n};","size_bytes":1172},"utils/litecoinDirect.js":{"content":"/**\n * Litecoin Direct Connection - No API Keys Required\n * Uses public blockchain explorers and direct libraries\n */\n\nconst axios = require('axios');\nconst bitcoin = require('bitcoinjs-lib');\n\n// Public Litecoin explorer APIs (no API key required)\nconst EXPLORERS = {\n    mainnet: {\n        base: 'https://litecoinspace.org/api',\n        fallback: 'https://insight.litecore.io/api'\n    },\n    testnet: {\n        base: 'https://litecoinspace.org/testnet/api',\n        fallback: 'https://testnet.litecore.io/api'\n    }\n};\n\n// Network configuration\nconst NETWORK = bitcoin.networks.bitcoin; // Litecoin uses Bitcoin network params\n\n/**\n * Get address balance using public explorer\n * @param {string} address - Litecoin address\n * @param {boolean} testnet - Use testnet (default: false)\n * @returns {Promise<number>} Balance in LTC\n */\nasync function getAddressBalance(address, testnet = false) {\n    const explorer = testnet ? EXPLORERS.testnet : EXPLORERS.mainnet;\n    \n    try {\n        // Try primary explorer\n        const response = await axios.get(`${explorer.base}/address/${address}`, {\n            timeout: 10000\n        });\n        \n        if (response.data && typeof response.data.chain_stats !== 'undefined') {\n            // Litecoin Space format\n            const confirmedBalance = response.data.chain_stats.funded_txo_sum || 0;\n            const spentBalance = response.data.chain_stats.spent_txo_sum || 0;\n            const balance = (confirmedBalance - spentBalance) / 100000000; // Convert satoshis to LTC\n            \n            if (balance > 0) {\n                console.log(`‚úÖ ${address.substring(0, 10)}...: ${balance} LTC`);\n            }\n            return balance;\n        }\n        \n        return 0;\n        \n    } catch (error) {\n        console.log(`‚ö†Ô∏è Erreur explorer principal pour ${address.substring(0, 10)}...: ${error.message}`);\n        \n        // Try fallback explorer\n        try {\n            const fallbackResponse = await axios.get(`${explorer.fallback}/addr/${address}`, {\n                timeout: 10000\n            });\n            \n            if (fallbackResponse.data && typeof fallbackResponse.data.balance !== 'undefined') {\n                // Insight API format\n                const balance = parseFloat(fallbackResponse.data.balance);\n                \n                if (balance > 0) {\n                    console.log(`‚úÖ ${address.substring(0, 10)}... (fallback): ${balance} LTC`);\n                }\n                return balance;\n            }\n            \n        } catch (fallbackError) {\n            console.log(`‚ö†Ô∏è Fallback √©galement √©chou√© pour ${address.substring(0, 10)}...: ${fallbackError.message}`);\n        }\n        \n        return 0;\n    }\n}\n\n/**\n * Get UTXO list for address\n * @param {string} address - Litecoin address\n * @param {boolean} testnet - Use testnet (default: false)\n * @returns {Promise<Array>} Array of UTXOs\n */\nasync function getAddressUTXOs(address, testnet = false) {\n    const explorer = testnet ? EXPLORERS.testnet : EXPLORERS.mainnet;\n    \n    try {\n        // Get UTXOs from Litecoin Space\n        const response = await axios.get(`${explorer.base}/address/${address}/utxo`, {\n            timeout: 10000\n        });\n        \n        if (response.data && Array.isArray(response.data)) {\n            return response.data.map(utxo => ({\n                txid: utxo.txid,\n                outputIndex: utxo.vout,\n                script: utxo.scriptpubkey || '',\n                satoshis: utxo.value\n            }));\n        }\n        \n        return [];\n        \n    } catch (error) {\n        console.error(`Erreur UTXO pour ${address}:`, error.message);\n        return [];\n    }\n}\n\n/**\n * Get transaction details\n * @param {string} txid - Transaction ID\n * @param {boolean} testnet - Use testnet (default: false)\n * @returns {Promise<Object|null>} Transaction details\n */\nasync function getTransaction(txid, testnet = false) {\n    const explorer = testnet ? EXPLORERS.testnet : EXPLORERS.mainnet;\n    \n    try {\n        const response = await axios.get(`${explorer.base}/tx/${txid}`, {\n            timeout: 10000\n        });\n        \n        return response.data;\n        \n    } catch (error) {\n        console.error(`Erreur transaction ${txid}:`, error.message);\n        return null;\n    }\n}\n\n/**\n * Broadcast transaction to network\n * @param {string} txHex - Raw transaction hex\n * @param {boolean} testnet - Use testnet (default: false)\n * @returns {Promise<string|null>} Transaction ID if successful\n */\nasync function broadcastTransaction(txHex, testnet = false) {\n    const explorer = testnet ? EXPLORERS.testnet : EXPLORERS.mainnet;\n    \n    try {\n        const response = await axios.post(`${explorer.base}/tx`, txHex, {\n            headers: { 'Content-Type': 'text/plain' },\n            timeout: 15000\n        });\n        \n        if (typeof response.data === 'string') {\n            console.log(`‚úÖ Transaction diffus√©e avec succ√®s: ${response.data}`);\n            return response.data; // Transaction ID\n        }\n        \n        return null;\n        \n    } catch (error) {\n        console.error('Erreur diffusion transaction:', error.message);\n        return null;\n    }\n}\n\n/**\n * Check for new transactions on an address\n * @param {string} address - Litecoin address\n * @param {number} lastCheckedTimestamp - Last check timestamp\n * @param {boolean} testnet - Use testnet (default: false)\n * @returns {Promise<Array>} Array of new transactions\n */\nasync function getNewTransactions(address, lastCheckedTimestamp, testnet = false) {\n    const explorer = testnet ? EXPLORERS.testnet : EXPLORERS.mainnet;\n    \n    try {\n        const response = await axios.get(`${explorer.base}/address/${address}/txs`, {\n            timeout: 10000\n        });\n        \n        if (response.data && Array.isArray(response.data)) {\n            // Filter transactions newer than last check\n            const newTxs = response.data.filter(tx => {\n                const txTimestamp = tx.status?.block_time ? tx.status.block_time * 1000 : Date.now();\n                return txTimestamp > lastCheckedTimestamp;\n            });\n            \n            return newTxs;\n        }\n        \n        return [];\n        \n    } catch (error) {\n        console.error(`Erreur nouvelles transactions pour ${address}:`, error.message);\n        return [];\n    }\n}\n\n/**\n * Check multiple addresses efficiently\n * @param {Array<string>} addresses - Array of addresses to check\n * @param {boolean} testnet - Use testnet (default: false)\n * @returns {Promise<Object>} Object with address -> balance mapping\n */\nasync function checkMultipleAddresses(addresses, testnet = false) {\n    const results = {};\n    \n    // Process addresses with delay to avoid rate limiting\n    for (let i = 0; i < addresses.length; i++) {\n        const address = addresses[i];\n        \n        try {\n            results[address] = await getAddressBalance(address, testnet);\n        } catch (error) {\n            console.error(`Erreur pour ${address}:`, error.message);\n            results[address] = 0;\n        }\n        \n        // Small delay between requests to be respectful to public APIs\n        if (i < addresses.length - 1) {\n            await new Promise(resolve => setTimeout(resolve, 1000)); // 1 second delay\n        }\n    }\n    \n    return results;\n}\n\n/**\n * Health check for explorer APIs\n * @param {boolean} testnet - Use testnet (default: false)\n * @returns {Promise<boolean>} True if APIs are responsive\n */\nasync function healthCheck(testnet = false) {\n    const explorer = testnet ? EXPLORERS.testnet : EXPLORERS.mainnet;\n    \n    try {\n        // Test with a known address (Litecoin Foundation donation address)\n        const testAddress = testnet ? 'mkYY3QRCJKJHZczVz6mJ6ztNKYZrn4s7hS' : 'LTC1QH7KYTQZ9ZXQX3Y8ZGX7ZXQX3Y8ZGX7ZXQX3Y8ZGX7Z';\n        \n        const response = await axios.get(`${explorer.base}/address/${testAddress}`, {\n            timeout: 5000\n        });\n        \n        return response.status === 200;\n        \n    } catch (error) {\n        console.error('Health check failed:', error.message);\n        return false;\n    }\n}\n\nmodule.exports = {\n    getAddressBalance,\n    getAddressUTXOs,\n    getTransaction,\n    broadcastTransaction,\n    getNewTransactions,\n    checkMultipleAddresses,\n    healthCheck,\n    NETWORK\n};","size_bytes":8312},"utils/logManager.js":{"content":"const fs = require('fs');\nconst path = require('path');\nconst { EmbedBuilder } = require('discord.js');\n\nconst CONFIG_FILE = path.join(__dirname, '../data/log_config.json');\n\nfunction loadLogConfig() {\n    try {\n        if (fs.existsSync(CONFIG_FILE)) {\n            const data = fs.readFileSync(CONFIG_FILE, 'utf8');\n            return JSON.parse(data);\n        }\n    } catch (error) {\n        console.error('Error loading log config:', error.message);\n    }\n    return {};\n}\n\n/**\n * Send balance log to configured channel\n * @param {Object} client - Discord client\n * @param {string} serverId - Server ID\n * @param {Object} logData - Log data\n */\nasync function sendBalanceLog(client, serverId, logData) {\n    try {\n        const config = loadLogConfig();\n        const channelId = config[serverId]?.balanceLogChannel;\n        \n        if (!channelId) {\n            console.log('No balance log channel configured for server:', serverId);\n            return;\n        }\n        \n        const channel = await client.channels.fetch(channelId);\n        if (!channel) {\n            console.log('Balance log channel not found:', channelId);\n            return;\n        }\n        \n        const embed = createBalanceLogEmbed(logData);\n        await channel.send({ embeds: [embed] });\n        \n    } catch (error) {\n        console.error('Error sending balance log:', error.message);\n    }\n}\n\n/**\n * Send gambling log to configured channel\n * @param {Object} client - Discord client\n * @param {string} serverId - Server ID\n * @param {Object} logData - Log data\n */\nasync function sendGamblingLog(client, serverId, logData) {\n    try {\n        const config = loadLogConfig();\n        const channelId = config[serverId]?.gamblingLogChannel;\n        \n        if (!channelId) {\n            console.log('No gambling log channel configured for server:', serverId);\n            return;\n        }\n        \n        const channel = await client.channels.fetch(channelId);\n        if (!channel) {\n            console.log('Gambling log channel not found:', channelId);\n            return;\n        }\n        \n        const embed = createGamblingLogEmbed(logData);\n        await channel.send({ embeds: [embed] });\n        \n    } catch (error) {\n        console.error('Error sending gambling log:', error.message);\n    }\n}\n\n/**\n * Create balance log embed\n * @param {Object} logData - Log data\n * @returns {EmbedBuilder} Embed\n */\nfunction createBalanceLogEmbed(logData) {\n    const { type, user, amount, address, details } = logData;\n    \n    let embed = new EmbedBuilder()\n        .setTimestamp();\n    \n    switch (type) {\n        case 'deposit':\n            embed\n                .setColor('#00ff00')\n                .setTitle('üí∞ Deposit Confirmed')\n                .setDescription(`User ${user.username} deposited **${amount} LTC**`)\n                .addFields(\n                    {\n                        name: 'üë§ User',\n                        value: `${user} (${user.id})`,\n                        inline: true\n                    },\n                    {\n                        name: 'üí∞ Amount',\n                        value: `${amount} LTC`,\n                        inline: true\n                    },\n                    {\n                        name: 'üìç Address',\n                        value: `\\`${address}\\``,\n                        inline: false\n                    }\n                );\n            break;\n            \n        case 'address_generated':\n            embed\n                .setColor('#0099ff')\n                .setTitle('üîë Deposit Address Generated')\n                .setDescription(`New deposit address created for ${user.username}`)\n                .addFields(\n                    {\n                        name: 'üë§ User',\n                        value: `${user} (${user.id})`,\n                        inline: true\n                    },\n                    {\n                        name: 'üìç Address',\n                        value: `\\`${address}\\``,\n                        inline: false\n                    }\n                );\n            break;\n            \n        case 'channel_closed':\n            embed\n                .setColor('#ffaa00')\n                .setTitle('üîí Deposit Channel Closed')\n                .setDescription(`Deposit channel closed for ${user.username}`)\n                .addFields(\n                    {\n                        name: 'üë§ User',\n                        value: `${user} (${user.id})`,\n                        inline: true\n                    },\n                    {\n                        name: '‚è±Ô∏è Reason',\n                        value: details || 'Auto-close after 20 minutes',\n                        inline: true\n                    }\n                );\n            break;\n    }\n    \n    return embed;\n}\n\n/**\n * Create gambling log embed\n * @param {Object} logData - Log data\n * @returns {EmbedBuilder} Embed\n */\nfunction createGamblingLogEmbed(logData) {\n    const { type, user, game, bet, result, payout, details } = logData;\n    \n    let embed = new EmbedBuilder()\n        .setTimestamp();\n    \n    switch (type) {\n        case 'blackjack':\n            embed\n                .setColor(result === 'win' ? '#00ff00' : result === 'lose' ? '#ff0000' : '#ffaa00')\n                .setTitle('üÉè Blackjack Game')\n                .setDescription(`${user.username} ${result === 'win' ? 'won' : result === 'lose' ? 'lost' : 'tied'} ${bet} LTC`)\n                .addFields(\n                    {\n                        name: 'üë§ Player',\n                        value: `${user} (${user.id})`,\n                        inline: true\n                    },\n                    {\n                        name: 'üí∞ Bet',\n                        value: `${bet} LTC`,\n                        inline: true\n                    },\n                    {\n                        name: 'üé∞ Result',\n                        value: result.toUpperCase(),\n                        inline: true\n                    },\n                    {\n                        name: 'üíµ Payout',\n                        value: `${payout || 0} LTC`,\n                        inline: true\n                    }\n                );\n            \n            if (details) {\n                embed.addFields({\n                    name: 'üìã Game Details',\n                    value: details,\n                    inline: false\n                });\n            }\n            break;\n            \n        case 'roulette':\n            embed\n                .setColor(result === 'win' ? '#00ff00' : '#ff0000')\n                .setTitle('üé∞ Roulette Spin')\n                .setDescription(`${user.username} ${result === 'win' ? 'won' : 'lost'} ${bet} LTC`)\n                .addFields(\n                    {\n                        name: 'üë§ Player',\n                        value: `${user} (${user.id})`,\n                        inline: true\n                    },\n                    {\n                        name: 'üí∞ Bet',\n                        value: `${bet} LTC`,\n                        inline: true\n                    },\n                    {\n                        name: 'üé∞ Result',\n                        value: result.toUpperCase(),\n                        inline: true\n                    },\n                    {\n                        name: 'üíµ Payout',\n                        value: `${payout || 0} LTC`,\n                        inline: true\n                    }\n                );\n            \n            if (details) {\n                embed.addFields({\n                    name: 'üìã Spin Details',\n                    value: details,\n                    inline: false\n                });\n            }\n            break;\n            \n        case 'big_win':\n            embed\n                .setColor('#ffd700')\n                .setTitle('üèÜ BIG WIN!')\n                .setDescription(`${user.username} hit a big win of **${payout} LTC**!`)\n                .addFields(\n                    {\n                        name: 'üë§ Winner',\n                        value: `${user} (${user.id})`,\n                        inline: true\n                    },\n                    {\n                        name: 'üéÆ Game',\n                        value: game.toUpperCase(),\n                        inline: true\n                    },\n                    {\n                        name: 'üí∞ Bet',\n                        value: `${bet} LTC`,\n                        inline: true\n                    },\n                    {\n                        name: 'üèÜ Win Amount',\n                        value: `${payout} LTC`,\n                        inline: true\n                    }\n                );\n            break;\n    }\n    \n    return embed;\n}\n\nmodule.exports = {\n    sendBalanceLog,\n    sendGamblingLog,\n    createBalanceLogEmbed,\n    createGamblingLogEmbed\n};","size_bytes":8851},"utils/panelManager.js":{"content":"/**\n * Panel Manager for Casino Bot\n * Manages channel configurations and panel systems\n */\n\nconst fs = require('fs');\n\nconst CONFIG_FILE = './data/panel_config.json';\n\n/**\n * Get default configuration\n */\nfunction getDefaultConfig() {\n    return {\n        panels: {\n            casinoPanel: {\n                channelId: null,\n                messageId: null,\n                ticketCategory: null,\n                staffRole: null\n            },\n            addBalancePanel: {\n                channelId: null,\n                messageId: null,\n                ticketCategory: null,\n                staffRole: null\n            }\n        },\n        whitelist: {\n            serverIds: [],\n            adminRoles: []\n        }\n    };\n}\n\n/**\n * Load panel configuration\n */\nfunction loadConfig() {\n    try {\n        if (!fs.existsSync('./data')) {\n            fs.mkdirSync('./data', { recursive: true });\n        }\n        \n        if (fs.existsSync(CONFIG_FILE)) {\n            const data = fs.readFileSync(CONFIG_FILE, 'utf8');\n            return JSON.parse(data);\n        }\n    } catch (error) {\n        console.error('Error loading panel configuration:', error);\n    }\n    \n    return getDefaultConfig();\n}\n\n/**\n * Save panel configuration\n */\nfunction saveConfig(config) {\n    try {\n        if (!fs.existsSync('./data')) {\n            fs.mkdirSync('./data', { recursive: true });\n        }\n        \n        fs.writeFileSync(CONFIG_FILE, JSON.stringify(config, null, 2));\n        console.log('‚úÖ Panel configuration saved');\n        return true;\n    } catch (error) {\n        console.error('Error saving panel configuration:', error);\n        return false;\n    }\n}\n\n/**\n * Set channel for a specific panel type\n */\nfunction setPanelChannel(panelType, channelId, categoryId = null, staffRole = null) {\n    const config = loadConfig();\n    \n    if (!config.panels[panelType]) {\n        config.panels[panelType] = {\n            channelId: null,\n            messageId: null,\n            ticketCategory: null,\n            staffRole: null\n        };\n    }\n    \n    config.panels[panelType].channelId = channelId;\n    if (categoryId) config.panels[panelType].ticketCategory = categoryId;\n    if (staffRole) config.panels[panelType].staffRole = staffRole;\n    \n    return saveConfig(config);\n}\n\n/**\n * Get panel configuration for a specific type\n */\nfunction getPanelConfig(panelType) {\n    const config = loadConfig();\n    return config.panels[panelType] || null;\n}\n\n/**\n * Check if user/server is whitelisted for panel management\n */\nfunction isWhitelisted(serverId, userId, userRoles) {\n    const config = loadConfig();\n    \n    // Check server whitelist\n    if (!config.whitelist.serverIds.includes(serverId)) {\n        return false;\n    }\n    \n    // Check admin roles\n    if (config.whitelist.adminRoles.length > 0) {\n        const hasAdminRole = config.whitelist.adminRoles.some(roleId => \n            userRoles.includes(roleId)\n        );\n        return hasAdminRole;\n    }\n    \n    return true; // If no admin roles defined, allow all users in whitelisted servers\n}\n\n/**\n * Add server to whitelist\n */\nfunction addToWhitelist(serverId, adminRoleId = null) {\n    const config = loadConfig();\n    \n    if (!config.whitelist.serverIds.includes(serverId)) {\n        config.whitelist.serverIds.push(serverId);\n    }\n    \n    if (adminRoleId && !config.whitelist.adminRoles.includes(adminRoleId)) {\n        config.whitelist.adminRoles.push(adminRoleId);\n    }\n    \n    return saveConfig(config);\n}\n\n/**\n * Remove server from whitelist\n */\nfunction removeFromWhitelist(serverId) {\n    const config = loadConfig();\n    \n    config.whitelist.serverIds = config.whitelist.serverIds.filter(id => id !== serverId);\n    \n    return saveConfig(config);\n}\n\n/**\n * Set message ID for panel (after sending)\n */\nfunction setPanelMessageId(panelType, messageId) {\n    const config = loadConfig();\n    \n    if (config.panels[panelType]) {\n        config.panels[panelType].messageId = messageId;\n        return saveConfig(config);\n    }\n    \n    return false;\n}\n\n/**\n * Get all panel configurations\n */\nfunction getAllPanels() {\n    const config = loadConfig();\n    return config.panels;\n}\n\nmodule.exports = {\n    loadConfig,\n    saveConfig,\n    setPanelChannel,\n    getPanelConfig,\n    isWhitelisted,\n    addToWhitelist,\n    removeFromWhitelist,\n    setPanelMessageId,\n    getAllPanels\n};","size_bytes":4367},"utils/securityManager.js":{"content":"const fs = require('fs');\nconst path = require('path');\nconst crypto = require('crypto');\n\nconst SECURITY_FILE = path.join(__dirname, '../data/user_security.json');\nconst ACTIVE_DEPOSITS_FILE = path.join(__dirname, '../data/active_deposits.json');\nconst GAMBLING_SESSIONS_FILE = path.join(__dirname, '../data/gambling_sessions.json');\n\n// Ensure data directory exists\nconst dataDir = path.join(__dirname, '../data');\nif (!fs.existsSync(dataDir)) {\n    fs.mkdirSync(dataDir, { recursive: true });\n}\n\n/**\n * Load user security data\n * @returns {Object} Security data\n */\nfunction loadSecurityData() {\n    try {\n        if (fs.existsSync(SECURITY_FILE)) {\n            const data = fs.readFileSync(SECURITY_FILE, 'utf8');\n            return JSON.parse(data);\n        }\n    } catch (error) {\n        console.error('Error loading security data:', error.message);\n    }\n    return {};\n}\n\n/**\n * Save user security data\n * @param {Object} data - Security data to save\n */\nfunction saveSecurityData(data) {\n    try {\n        fs.writeFileSync(SECURITY_FILE, JSON.stringify(data, null, 2));\n        console.log('‚úÖ Security data saved');\n    } catch (error) {\n        console.error('Error saving security data:', error.message);\n    }\n}\n\n/**\n * Load active deposits\n * @returns {Object} Active deposits data\n */\nfunction loadActiveDeposits() {\n    try {\n        if (fs.existsSync(ACTIVE_DEPOSITS_FILE)) {\n            const data = fs.readFileSync(ACTIVE_DEPOSITS_FILE, 'utf8');\n            return JSON.parse(data);\n        }\n    } catch (error) {\n        console.error('Error loading active deposits:', error.message);\n    }\n    return {};\n}\n\n/**\n * Save active deposits\n * @param {Object} data - Active deposits data to save\n */\nfunction saveActiveDeposits(data) {\n    try {\n        fs.writeFileSync(ACTIVE_DEPOSITS_FILE, JSON.stringify(data, null, 2));\n        console.log('‚úÖ Active deposits saved');\n    } catch (error) {\n        console.error('Error saving active deposits:', error.message);\n    }\n}\n\n/**\n * Load gambling sessions\n * @returns {Object} Gambling sessions data\n */\nfunction loadGamblingSessions() {\n    try {\n        if (fs.existsSync(GAMBLING_SESSIONS_FILE)) {\n            const data = fs.readFileSync(GAMBLING_SESSIONS_FILE, 'utf8');\n            return JSON.parse(data);\n        }\n    } catch (error) {\n        console.error('Error loading gambling sessions:', error.message);\n    }\n    return {};\n}\n\n/**\n * Save gambling sessions\n * @param {Object} data - Gambling sessions data to save\n */\nfunction saveGamblingSessions(data) {\n    try {\n        fs.writeFileSync(GAMBLING_SESSIONS_FILE, JSON.stringify(data, null, 2));\n        console.log('‚úÖ Gambling sessions saved');\n    } catch (error) {\n        console.error('Error saving gambling sessions:', error.message);\n    }\n}\n\n/**\n * Generate secure recovery key\n * @returns {string} Recovery key\n */\nfunction generateRecoveryKey() {\n    return crypto.randomBytes(16).toString('hex').toUpperCase();\n}\n\n/**\n * Hash password securely\n * @param {string} password - Plain text password\n * @returns {string} Hashed password\n */\nfunction hashPassword(password) {\n    const salt = crypto.randomBytes(16).toString('hex');\n    const hash = crypto.pbkdf2Sync(password, salt, 10000, 64, 'sha512').toString('hex');\n    return `${salt}:${hash}`;\n}\n\n/**\n * Verify password\n * @param {string} password - Plain text password\n * @param {string} hashedPassword - Stored hashed password\n * @returns {boolean} True if password matches\n */\nfunction verifyPassword(password, hashedPassword) {\n    try {\n        const [salt, hash] = hashedPassword.split(':');\n        const verifyHash = crypto.pbkdf2Sync(password, salt, 10000, 64, 'sha512').toString('hex');\n        return hash === verifyHash;\n    } catch (error) {\n        return false;\n    }\n}\n\n/**\n * Get or create user security profile\n * @param {string} userId - Discord user ID\n * @returns {Object} Security profile\n */\nfunction getUserSecurity(userId) {\n    const security = loadSecurityData();\n    \n    if (!security[userId]) {\n        security[userId] = {\n            userId: userId,\n            hasPassword: false,\n            passwordHash: null,\n            recoveryKey: null,\n            depositRequests: [],\n            lastGamblingSession: null,\n            wageredAmount: 0,\n            depositedAmount: 0,\n            canCashout: true,\n            createdAt: new Date().toISOString()\n        };\n        saveSecurityData(security);\n    }\n    \n    return security[userId];\n}\n\n/**\n * Set user password and generate recovery key\n * @param {string} userId - Discord user ID\n * @param {string} password - New password\n * @returns {string} Recovery key\n */\nfunction setUserPassword(userId, password) {\n    const security = loadSecurityData();\n    const userSec = getUserSecurity(userId);\n    \n    const recoveryKey = generateRecoveryKey();\n    \n    userSec.hasPassword = true;\n    userSec.passwordHash = hashPassword(password);\n    userSec.recoveryKey = recoveryKey;\n    \n    security[userId] = userSec;\n    saveSecurityData(security);\n    \n    return recoveryKey;\n}\n\n/**\n * Change user password\n * @param {string} userId - Discord user ID\n * @param {string} oldPassword - Current password\n * @param {string} newPassword - New password\n * @returns {boolean} Success\n */\nfunction changeUserPassword(userId, oldPassword, newPassword) {\n    const security = loadSecurityData();\n    const userSec = getUserSecurity(userId);\n    \n    if (!userSec.hasPassword || !verifyPassword(oldPassword, userSec.passwordHash)) {\n        return false;\n    }\n    \n    userSec.passwordHash = hashPassword(newPassword);\n    security[userId] = userSec;\n    saveSecurityData(security);\n    \n    return true;\n}\n\n/**\n * Verify user password\n * @param {string} userId - Discord user ID\n * @param {string} password - Password to verify\n * @returns {boolean} True if password is correct\n */\nfunction verifyUserPassword(userId, password) {\n    const userSec = getUserSecurity(userId);\n    \n    if (!userSec.hasPassword) {\n        return false;\n    }\n    \n    return verifyPassword(password, userSec.passwordHash);\n}\n\n/**\n * Reset recovery key with old key + password\n * @param {string} userId - Discord user ID\n * @param {string} oldRecoveryKey - Old recovery key\n * @param {string} password - Current password\n * @returns {string|null} New recovery key or null if failed\n */\nfunction resetRecoveryKey(userId, oldRecoveryKey, password) {\n    const security = loadSecurityData();\n    const userSec = getUserSecurity(userId);\n    \n    if (!userSec.hasPassword || \n        userSec.recoveryKey !== oldRecoveryKey.toUpperCase() ||\n        !verifyPassword(password, userSec.passwordHash)) {\n        return null;\n    }\n    \n    const newRecoveryKey = generateRecoveryKey();\n    userSec.recoveryKey = newRecoveryKey;\n    \n    security[userId] = userSec;\n    saveSecurityData(security);\n    \n    return newRecoveryKey;\n}\n\n/**\n * Reset user password and recovery key (Admin function)\n * @param {string} userId - Discord user ID  \n * @param {string} newRecoveryKey - New recovery key to set\n * @returns {Object} Result with success status\n */\nfunction resetPassword(userId, newRecoveryKey) {\n    try {\n        const security = loadSecurityData();\n        const userSec = getUserSecurity(userId);\n        \n        // Reset password to null (user will need to set new one)\n        userSec.hasPassword = false;\n        userSec.passwordHash = null;\n        userSec.recoveryKey = newRecoveryKey;\n        \n        security[userId] = userSec;\n        saveSecurityData(security);\n        \n        console.log(`üîê Admin reset password for user ${userId}`);\n        return { success: true };\n        \n    } catch (error) {\n        console.error('Error resetting password:', error);\n        return { success: false, error: error.message };\n    }\n}\n\n/**\n * Add active deposit request\n * @param {string} userId - Discord user ID\n * @param {string} address - LTC address\n * @param {number} initialBalance - Initial balance of address\n */\nfunction addActiveDeposit(userId, address, initialBalance = 0) {\n    const activeDeposits = loadActiveDeposits();\n    \n    if (!activeDeposits[userId]) {\n        activeDeposits[userId] = [];\n    }\n    \n    activeDeposits[userId].push({\n        address: address,\n        userId: userId,\n        lastKnownBalance: initialBalance,\n        createdAt: new Date().toISOString(),\n        active: true\n    });\n    \n    saveActiveDeposits(activeDeposits);\n}\n\n/**\n * Get active deposits for user\n * @param {string} userId - Discord user ID\n * @returns {Array} Active deposit requests\n */\nfunction getActiveDeposits(userId) {\n    const activeDeposits = loadActiveDeposits();\n    return activeDeposits[userId] || [];\n}\n\n/**\n * Get all active deposits across all users\n * @returns {Array} All active deposit requests\n */\nfunction getAllActiveDeposits() {\n    const activeDeposits = loadActiveDeposits();\n    const allDeposits = [];\n    \n    for (const userId in activeDeposits) {\n        allDeposits.push(...activeDeposits[userId].filter(deposit => deposit.active));\n    }\n    \n    return allDeposits;\n}\n\n/**\n * Complete deposit request\n * @param {string} userId - Discord user ID\n * @param {string} address - LTC address\n */\nfunction completeDepositRequest(userId, address) {\n    const activeDeposits = loadActiveDeposits();\n    \n    if (activeDeposits[userId]) {\n        const deposit = activeDeposits[userId].find(d => d.address === address);\n        if (deposit) {\n            deposit.active = false;\n            deposit.completedAt = new Date().toISOString();\n        }\n    }\n    \n    saveActiveDeposits(activeDeposits);\n}\n\n/**\n * Start gambling session\n * @param {string} userId - Discord user ID\n * @param {number} minutes - Session duration in minutes\n * @returns {Date} Session end time\n */\nfunction startGamblingSession(userId, minutes) {\n    const sessions = loadGamblingSessions();\n    const endTime = new Date(Date.now() + minutes * 60 * 1000);\n    \n    sessions[userId] = {\n        userId: userId,\n        startTime: new Date().toISOString(),\n        endTime: endTime.toISOString(),\n        durationMinutes: minutes,\n        active: true\n    };\n    \n    saveGamblingSessions(sessions);\n    \n    // Update user security\n    const security = loadSecurityData();\n    const userSec = getUserSecurity(userId);\n    userSec.lastGamblingSession = sessions[userId];\n    security[userId] = userSec;\n    saveSecurityData(security);\n    \n    return endTime;\n}\n\n/**\n * Check if user has active gambling session\n * @param {string} userId - Discord user ID\n * @returns {boolean} True if session is active\n */\nfunction hasActiveGamblingSession(userId) {\n    const sessions = loadGamblingSessions();\n    \n    if (!sessions[userId] || !sessions[userId].active) {\n        return false;\n    }\n    \n    const now = new Date();\n    const endTime = new Date(sessions[userId].endTime);\n    \n    if (now > endTime) {\n        // Session expired\n        sessions[userId].active = false;\n        saveGamblingSessions(sessions);\n        return false;\n    }\n    \n    return true;\n}\n\n/**\n * Add wagered amount for user\n * @param {string} userId - Discord user ID\n * @param {number} amount - Amount wagered\n */\nfunction addWageredAmount(userId, amount) {\n    const security = loadSecurityData();\n    const userSec = getUserSecurity(userId);\n    \n    userSec.wageredAmount += amount;\n    security[userId] = userSec;\n    saveSecurityData(security);\n}\n\n/**\n * Add deposited amount for user\n * @param {string} userId - Discord user ID\n * @param {number} amount - Amount deposited\n */\nfunction addDepositedAmount(userId, amount) {\n    const security = loadSecurityData();\n    const userSec = getUserSecurity(userId);\n    \n    userSec.depositedAmount += amount;\n    // Check if user can cashout (wagered >= deposited)\n    userSec.canCashout = userSec.wageredAmount >= userSec.depositedAmount;\n    \n    security[userId] = userSec;\n    saveSecurityData(security);\n}\n\n/**\n * Clear all active deposits (Admin function)\n * @returns {boolean} Success status\n */\nfunction clearAllActiveDeposits() {\n    try {\n        const emptyDeposits = {};\n        saveActiveDeposits(emptyDeposits);\n        console.log('üóØÔ∏è All active deposits cleared');\n        return true;\n    } catch (error) {\n        console.error('Error clearing active deposits:', error);\n        return false;\n    }\n}\n\n/**\n * Check if user can cashout\n * @param {string} userId - Discord user ID\n * @returns {Object} Cashout status and info\n */\nfunction canUserCashout(userId) {\n    const userSec = getUserSecurity(userId);\n    \n    const wageredPercent = userSec.depositedAmount > 0 ? \n        (userSec.wageredAmount / userSec.depositedAmount) * 100 : 100;\n    \n    return {\n        canCashout: userSec.canCashout,\n        wageredAmount: userSec.wageredAmount,\n        depositedAmount: userSec.depositedAmount,\n        wageredPercent: wageredPercent,\n        remainingToWager: Math.max(0, userSec.depositedAmount - userSec.wageredAmount)\n    };\n}\n\nmodule.exports = {\n    getUserSecurity,\n    setUserPassword,\n    changeUserPassword,\n    verifyUserPassword,\n    resetRecoveryKey,\n    resetPassword,\n    addActiveDeposit,\n    getActiveDeposits,\n    getAllActiveDeposits,\n    completeDepositRequest,\n    clearAllActiveDeposits,\n    startGamblingSession,\n    hasActiveGamblingSession,\n    addWageredAmount,\n    addDepositedAmount,\n    canUserCashout,\n    generateRecoveryKey\n};","size_bytes":13379},"utils/sessionManager.js":{"content":"const { EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle, PermissionFlagsBits } = require('discord.js');\nconst fs = require('fs');\nconst path = require('path');\n\nconst SESSIONS_FILE = path.join(__dirname, '../data/gaming_sessions.json');\n\nclass SessionManager {\n    constructor() {\n        this.activeSessions = new Map();\n        this.loadSessions();\n    }\n\n    loadSessions() {\n        try {\n            if (fs.existsSync(SESSIONS_FILE)) {\n                const data = JSON.parse(fs.readFileSync(SESSIONS_FILE, 'utf8'));\n                // Convert array to Map and check for expired sessions\n                const now = Date.now();\n                data.forEach(session => {\n                    if (session.expiresAt > now) {\n                        this.activeSessions.set(session.id, session);\n                    }\n                });\n                console.log(`‚úÖ Loaded ${this.activeSessions.size} active gaming sessions`);\n            }\n        } catch (error) {\n            console.error('Error loading sessions:', error);\n            this.activeSessions = new Map();\n        }\n    }\n\n    saveSessions() {\n        try {\n            const sessionsArray = Array.from(this.activeSessions.values());\n            fs.writeFileSync(SESSIONS_FILE, JSON.stringify(sessionsArray, null, 2));\n        } catch (error) {\n            console.error('Error saving sessions:', error);\n        }\n    }\n\n    generateSessionId() {\n        return `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    }\n\n    async createPrivateSession(guild, host, sessionType = 'general', options = {}) {\n        const sessionId = this.generateSessionId();\n        const channelName = `üé∞-${host.username}-${sessionType}`.toLowerCase().replace(/[^a-z0-9-]/g, '');\n        \n        try {\n            // Create private channel\n            const channel = await guild.channels.create({\n                name: channelName,\n                type: 0, // Text channel\n                topic: `üé∞ Private Gaming Session | Host: ${host.username} | Type: ${sessionType}`,\n                permissionOverwrites: [\n                    {\n                        id: guild.id,\n                        deny: [PermissionFlagsBits.ViewChannel]\n                    },\n                    {\n                        id: host.id,\n                        allow: [\n                            PermissionFlagsBits.ViewChannel,\n                            PermissionFlagsBits.SendMessages,\n                            PermissionFlagsBits.ReadMessageHistory,\n                            PermissionFlagsBits.ManageMessages\n                        ]\n                    }\n                ]\n            });\n\n            // Create session object\n            const session = {\n                id: sessionId,\n                channelId: channel.id,\n                hostId: host.id,\n                guildId: guild.id,\n                sessionType: sessionType,\n                participants: [host.id],\n                createdAt: Date.now(),\n                expiresAt: Date.now() + (options.duration || 60) * 60 * 1000, // Default 1 hour\n                settings: {\n                    maxParticipants: options.maxParticipants || 10,\n                    isPublic: options.isPublic || false,\n                    allowSpectators: options.allowSpectators || true,\n                    minBet: options.minBet || 0.001,\n                    maxBet: options.maxBet || 1.0\n                },\n                stats: {\n                    totalGames: 0,\n                    totalWagers: 0,\n                    participantCount: 1\n                }\n            };\n\n            this.activeSessions.set(sessionId, session);\n            this.saveSessions();\n\n            // Send welcome message\n            await this.sendSessionWelcome(channel, session, host);\n\n            return { success: true, session, channel };\n\n        } catch (error) {\n            console.error('Error creating private session:', error);\n            return { success: false, error: error.message };\n        }\n    }\n\n    async sendSessionWelcome(channel, session, host) {\n        const welcomeEmbed = new EmbedBuilder()\n            .setColor('#9b59b6')\n            .setTitle('üéâ Private Gaming Session Created!')\n            .setDescription(`Welcome to your exclusive gaming room, ${host}!`)\n            .addFields(\n                {\n                    name: 'üéÆ Session Details',\n                    value: `**Type:** ${session.sessionType.charAt(0).toUpperCase() + session.sessionType.slice(1)}\\n**Host:** ${host.username}\\n**Max Players:** ${session.settings.maxParticipants}\\n**Duration:** ${Math.round((session.expiresAt - session.createdAt) / 60000)} minutes`,\n                    inline: true\n                },\n                {\n                    name: 'üí∞ Betting Limits',\n                    value: `**Minimum:** ${session.settings.minBet} LTC\\n**Maximum:** ${session.settings.maxBet} LTC\\n**Spectators:** ${session.settings.allowSpectators ? 'Allowed' : 'Not Allowed'}`,\n                    inline: true\n                },\n                {\n                    name: 'üéØ Available Games',\n                    value: 'üÉè Blackjack\\nüé∞ Roulette\\nüé≤ Dice Games\\nüéÆ Group Games',\n                    inline: false\n                }\n            )\n            .setThumbnail(host.displayAvatarURL({ dynamic: true }))\n            .setFooter({ text: `Session ID: ${session.id}` })\n            .setTimestamp();\n\n        const controlRow = new ActionRowBuilder()\n            .addComponents(\n                new ButtonBuilder()\n                    .setCustomId(`session_invite_${session.id}`)\n                    .setLabel('üë• Invite Players')\n                    .setStyle(ButtonStyle.Primary)\n                    .setEmoji('üë•'),\n                new ButtonBuilder()\n                    .setCustomId(`session_settings_${session.id}`)\n                    .setLabel('‚öôÔ∏è Settings')\n                    .setStyle(ButtonStyle.Secondary)\n                    .setEmoji('‚öôÔ∏è'),\n                new ButtonBuilder()\n                    .setCustomId(`session_stats_${session.id}`)\n                    .setLabel('üìä Stats')\n                    .setStyle(ButtonStyle.Secondary)\n                    .setEmoji('üìä')\n            );\n\n        const gamesRow = new ActionRowBuilder()\n            .addComponents(\n                new ButtonBuilder()\n                    .setCustomId(`session_blackjack_${session.id}`)\n                    .setLabel('üÉè Blackjack')\n                    .setStyle(ButtonStyle.Success)\n                    .setEmoji('üÉè'),\n                new ButtonBuilder()\n                    .setCustomId(`session_roulette_${session.id}`)\n                    .setLabel('üé∞ Roulette')\n                    .setStyle(ButtonStyle.Success)\n                    .setEmoji('üé∞'),\n                new ButtonBuilder()\n                    .setCustomId(`session_close_${session.id}`)\n                    .setLabel('üö™ Close Session')\n                    .setStyle(ButtonStyle.Danger)\n                    .setEmoji('üö™')\n            );\n\n        await channel.send({\n            embeds: [welcomeEmbed],\n            components: [controlRow, gamesRow]\n        });\n    }\n\n    async addParticipant(sessionId, userId, guild) {\n        const session = this.activeSessions.get(sessionId);\n        if (!session) return { success: false, reason: 'Session not found' };\n\n        if (session.participants.includes(userId)) {\n            return { success: false, reason: 'User already in session' };\n        }\n\n        if (session.participants.length >= session.settings.maxParticipants) {\n            return { success: false, reason: 'Session is full' };\n        }\n\n        try {\n            const channel = guild.channels.cache.get(session.channelId);\n            if (!channel) return { success: false, reason: 'Channel not found' };\n\n            // Add permissions for the new participant\n            await channel.permissionOverwrites.create(userId, {\n                ViewChannel: true,\n                SendMessages: true,\n                ReadMessageHistory: true\n            });\n\n            // Update session\n            session.participants.push(userId);\n            session.stats.participantCount = session.participants.length;\n            this.saveSessions();\n\n            // Announce new participant\n            const user = await guild.members.fetch(userId);\n            const joinEmbed = new EmbedBuilder()\n                .setColor('#2ecc71')\n                .setTitle('üéä New Player Joined!')\n                .setDescription(`${user} has joined the gaming session!`)\n                .addFields({\n                    name: 'üë• Current Players',\n                    value: `${session.participants.length}/${session.settings.maxParticipants}`,\n                    inline: true\n                })\n                .setThumbnail(user.displayAvatarURL({ dynamic: true }))\n                .setTimestamp();\n\n            await channel.send({ embeds: [joinEmbed] });\n\n            return { success: true };\n        } catch (error) {\n            console.error('Error adding participant:', error);\n            return { success: false, reason: error.message };\n        }\n    }\n\n    async removeParticipant(sessionId, userId, guild, removedBy = null) {\n        const session = this.activeSessions.get(sessionId);\n        if (!session) return { success: false, reason: 'Session not found' };\n\n        if (!session.participants.includes(userId)) {\n            return { success: false, reason: 'User not in session' };\n        }\n\n        try {\n            const channel = guild.channels.cache.get(session.channelId);\n            if (!channel) return { success: false, reason: 'Channel not found' };\n\n            // Remove permissions\n            await channel.permissionOverwrites.delete(userId);\n\n            // Update session\n            session.participants = session.participants.filter(id => id !== userId);\n            session.stats.participantCount = session.participants.length;\n\n            // If host left, transfer ownership or close session\n            if (userId === session.hostId) {\n                if (session.participants.length > 0) {\n                    session.hostId = session.participants[0];\n                    const newHost = await guild.members.fetch(session.hostId);\n                    \n                    const transferEmbed = new EmbedBuilder()\n                        .setColor('#f39c12')\n                        .setTitle('üëë Host Transfer')\n                        .setDescription(`${newHost} is now the session host!`)\n                        .setTimestamp();\n\n                    await channel.send({ embeds: [transferEmbed] });\n                } else {\n                    // Close session if no participants left\n                    await this.closeSession(sessionId, guild);\n                    return { success: true, sessionClosed: true };\n                }\n            } else {\n                // Announce participant left\n                const user = await guild.members.fetch(userId);\n                const leaveEmbed = new EmbedBuilder()\n                    .setColor('#e74c3c')\n                    .setTitle('üëã Player Left')\n                    .setDescription(`${user.username} has left the gaming session`)\n                    .addFields({\n                        name: 'üë• Remaining Players',\n                        value: `${session.participants.length}/${session.settings.maxParticipants}`,\n                        inline: true\n                    })\n                    .setTimestamp();\n\n                if (removedBy && removedBy !== userId) {\n                    const remover = await guild.members.fetch(removedBy);\n                    leaveEmbed.setFooter({ text: `Removed by ${remover.username}` });\n                }\n\n                await channel.send({ embeds: [leaveEmbed] });\n            }\n\n            this.saveSessions();\n            return { success: true };\n        } catch (error) {\n            console.error('Error removing participant:', error);\n            return { success: false, reason: error.message };\n        }\n    }\n\n    async closeSession(sessionId, guild) {\n        const session = this.activeSessions.get(sessionId);\n        if (!session) return { success: false, reason: 'Session not found' };\n\n        try {\n            const channel = guild.channels.cache.get(session.channelId);\n            \n            if (channel) {\n                // Send closing message\n                const closeEmbed = new EmbedBuilder()\n                    .setColor('#95a5a6')\n                    .setTitle('üîí Session Ending')\n                    .setDescription('This gaming session is being closed...')\n                    .addFields(\n                        {\n                            name: 'üìä Session Stats',\n                            value: `**Total Games:** ${session.stats.totalGames}\\n**Total Wagers:** ${session.stats.totalWagers.toFixed(8)} LTC\\n**Participants:** ${session.stats.participantCount}`,\n                            inline: true\n                        },\n                        {\n                            name: '‚è∞ Duration',\n                            value: `${Math.round((Date.now() - session.createdAt) / 60000)} minutes`,\n                            inline: true\n                        }\n                    )\n                    .setTimestamp();\n\n                await channel.send({ embeds: [closeEmbed] });\n\n                // Delete channel after 10 seconds\n                setTimeout(async () => {\n                    try {\n                        await channel.delete('Gaming session ended');\n                    } catch (error) {\n                        console.error('Error deleting session channel:', error);\n                    }\n                }, 10000);\n            }\n\n            // Remove from active sessions\n            this.activeSessions.delete(sessionId);\n            this.saveSessions();\n\n            return { success: true };\n        } catch (error) {\n            console.error('Error closing session:', error);\n            return { success: false, reason: error.message };\n        }\n    }\n\n    getSession(sessionId) {\n        return this.activeSessions.get(sessionId);\n    }\n\n    isUserInSession(userId) {\n        for (const session of this.activeSessions.values()) {\n            if (session.participants.includes(userId)) {\n                return session;\n            }\n        }\n        return null;\n    }\n\n    async cleanExpiredSessions(guild) {\n        const now = Date.now();\n        const expiredSessions = [];\n\n        for (const [sessionId, session] of this.activeSessions) {\n            if (session.expiresAt <= now) {\n                expiredSessions.push(sessionId);\n            }\n        }\n\n        for (const sessionId of expiredSessions) {\n            await this.closeSession(sessionId, guild);\n            console.log(`üßπ Cleaned expired session: ${sessionId}`);\n        }\n\n        return expiredSessions.length;\n    }\n}\n\nmodule.exports = new SessionManager();","size_bytes":15054},"utils/treasuryManager.js":{"content":"const fs = require('fs');\nconst path = require('path');\nconst ltcWallet = require('../litecoin-casino-bot.js');\n\nconst TREASURY_FILE = path.join(__dirname, '../data/treasury.json');\nconst TREASURY_ADDRESS = 'LTC_TREASURY_ADDRESS_PLACEHOLDER'; // This should be a real LTC address\n\nclass TreasuryManager {\n    constructor() {\n        this.treasuryData = this.loadTreasuryData();\n    }\n\n    loadTreasuryData() {\n        try {\n            if (fs.existsSync(TREASURY_FILE)) {\n                return JSON.parse(fs.readFileSync(TREASURY_FILE, 'utf8'));\n            }\n        } catch (error) {\n            console.error('Error loading treasury data:', error);\n        }\n        \n        return {\n            address: TREASURY_ADDRESS,\n            totalCollected: 0,\n            totalPaidOut: 0,\n            currentBalance: 0,\n            transactions: [],\n            lastUpdated: Date.now()\n        };\n    }\n\n    saveTreasuryData() {\n        try {\n            fs.writeFileSync(TREASURY_FILE, JSON.stringify(this.treasuryData, null, 2));\n            console.log('‚úÖ Treasury data saved');\n        } catch (error) {\n            console.error('Error saving treasury data:', error);\n        }\n    }\n\n    /**\n     * Get current treasury balance (estimated)\n     * This should ideally query the blockchain for the real balance\n     */\n    getCurrentBalance() {\n        return this.treasuryData.currentBalance;\n    }\n\n    /**\n     * Calculate maximum bet allowed (30% of treasury balance)\n     */\n    getMaxBetLimit() {\n        const balance = this.getCurrentBalance();\n        return balance * 0.30; // 30% limit\n    }\n\n    /**\n     * Record a house win (money collected from players)\n     */\n    recordHouseWin(amount, userId, gameType, details = {}) {\n        const transaction = {\n            type: 'house_win',\n            amount: amount,\n            userId: userId,\n            gameType: gameType,\n            details: details,\n            timestamp: Date.now(),\n            id: `win_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`\n        };\n\n        this.treasuryData.transactions.push(transaction);\n        this.treasuryData.totalCollected += amount;\n        this.treasuryData.currentBalance += amount;\n        this.treasuryData.lastUpdated = Date.now();\n\n        this.saveTreasuryData();\n\n        console.log(`üè† House win recorded: ${amount.toFixed(8)} LTC from ${userId} in ${gameType}`);\n        return transaction;\n    }\n\n    /**\n     * Record a payout to a winner\n     */\n    recordPayout(amount, userId, gameType, details = {}) {\n        const transaction = {\n            type: 'payout',\n            amount: amount,\n            userId: userId,\n            gameType: gameType,\n            details: details,\n            timestamp: Date.now(),\n            id: `payout_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`\n        };\n\n        this.treasuryData.transactions.push(transaction);\n        this.treasuryData.totalPaidOut += amount;\n        this.treasuryData.currentBalance -= amount;\n        this.treasuryData.lastUpdated = Date.now();\n\n        this.saveTreasuryData();\n\n        console.log(`üí∞ Payout recorded: ${amount.toFixed(8)} LTC to ${userId} from ${gameType}`);\n        return transaction;\n    }\n\n    /**\n     * Check if a bet amount is within limits\n     */\n    isBetAllowed(betAmount) {\n        const maxBet = this.getMaxBetLimit();\n        return betAmount <= maxBet;\n    }\n\n    /**\n     * Get treasury statistics\n     */\n    getStats() {\n        return {\n            address: this.treasuryData.address,\n            currentBalance: this.treasuryData.currentBalance,\n            totalCollected: this.treasuryData.totalCollected,\n            totalPaidOut: this.treasuryData.totalPaidOut,\n            netProfit: this.treasuryData.totalCollected - this.treasuryData.totalPaidOut,\n            maxBetLimit: this.getMaxBetLimit(),\n            transactionCount: this.treasuryData.transactions.length,\n            lastUpdated: this.treasuryData.lastUpdated\n        };\n    }\n\n    /**\n     * Get recent transactions\n     */\n    getRecentTransactions(limit = 10) {\n        return this.treasuryData.transactions\n            .sort((a, b) => b.timestamp - a.timestamp)\n            .slice(0, limit);\n    }\n\n    /**\n     * Manual balance adjustment (owner only)\n     */\n    adjustBalance(amount, reason, adminUserId) {\n        const transaction = {\n            type: 'manual_adjustment',\n            amount: amount,\n            reason: reason,\n            adminUserId: adminUserId,\n            timestamp: Date.now(),\n            id: `adj_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`\n        };\n\n        this.treasuryData.transactions.push(transaction);\n        this.treasuryData.currentBalance += amount;\n        this.treasuryData.lastUpdated = Date.now();\n\n        this.saveTreasuryData();\n\n        console.log(`‚öñÔ∏è Manual balance adjustment: ${amount.toFixed(8)} LTC by ${adminUserId} - ${reason}`);\n        return transaction;\n    }\n}\n\nmodule.exports = new TreasuryManager();","size_bytes":5017},"utils/userProfiles.js":{"content":"const fs = require('fs');\nconst path = require('path');\n\nconst PROFILES_FILE = path.join(__dirname, '../data/user_profiles.json');\nconst ADDRESS_MAPPING_FILE = path.join(__dirname, '../data/address_mapping.json');\n\n// Ensure data directory exists\nconst dataDir = path.join(__dirname, '../data');\nif (!fs.existsSync(dataDir)) {\n    fs.mkdirSync(dataDir, { recursive: true });\n}\n\n/**\n * Load user profiles from JSON file\n * @returns {Object} User profiles object\n */\nfunction loadProfiles() {\n    try {\n        if (fs.existsSync(PROFILES_FILE)) {\n            const data = fs.readFileSync(PROFILES_FILE, 'utf8');\n            return JSON.parse(data);\n        }\n    } catch (error) {\n        console.error('Error loading user profiles:', error.message);\n    }\n    return {};\n}\n\n/**\n * Save user profiles to JSON file\n * @param {Object} profiles - User profiles to save\n */\nfunction saveProfiles(profiles) {\n    try {\n        fs.writeFileSync(PROFILES_FILE, JSON.stringify(profiles, null, 2));\n        console.log('‚úÖ User profiles saved');\n    } catch (error) {\n        console.error('Error saving user profiles:', error.message);\n    }\n}\n\n/**\n * Load address mapping from JSON file\n * @returns {Object} Address mapping object\n */\nfunction loadAddressMapping() {\n    try {\n        if (fs.existsSync(ADDRESS_MAPPING_FILE)) {\n            const data = fs.readFileSync(ADDRESS_MAPPING_FILE, 'utf8');\n            return JSON.parse(data);\n        }\n    } catch (error) {\n        console.error('Error loading address mapping:', error.message);\n    }\n    return {};\n}\n\n/**\n * Save address mapping to JSON file\n * @param {Object} mapping - Address mapping to save\n */\nfunction saveAddressMapping(mapping) {\n    try {\n        fs.writeFileSync(ADDRESS_MAPPING_FILE, JSON.stringify(mapping, null, 2));\n        console.log('‚úÖ Address mapping saved');\n    } catch (error) {\n        console.error('Error saving address mapping:', error.message);\n    }\n}\n\n/**\n * Get or create user profile\n * @param {string} userId - Discord user ID\n * @returns {Object} User profile\n */\nfunction getUserProfile(userId) {\n    const profiles = loadProfiles();\n    \n    if (!profiles[userId]) {\n        profiles[userId] = {\n            userId: userId,\n            balance: 0,\n            totalDeposited: 0,\n            totalWithdrawn: 0,\n            depositHistory: [],\n            withdrawalHistory: [],\n            gameHistory: [],\n            addresses: [],\n            createdAt: new Date().toISOString(),\n            lastActivity: new Date().toISOString()\n        };\n        saveProfiles(profiles);\n    }\n    \n    return profiles[userId];\n}\n\n/**\n * Update user profile\n * @param {string} userId - Discord user ID\n * @param {Object} updates - Updates to apply to profile\n */\nfunction updateUserProfile(userId, updates) {\n    const profiles = loadProfiles();\n    \n    if (!profiles[userId]) {\n        profiles[userId] = getUserProfile(userId);\n    }\n    \n    // Merge updates\n    profiles[userId] = { ...profiles[userId], ...updates };\n    profiles[userId].lastActivity = new Date().toISOString();\n    \n    saveProfiles(profiles);\n    return profiles[userId];\n}\n\n/**\n * Add deposit to user profile\n * @param {string} userId - Discord user ID\n * @param {number} amount - Deposit amount in LTC\n * @param {string} address - Deposit address\n * @param {string} txid - Transaction ID\n */\nfunction addDeposit(userId, amount, address, txid = null) {\n    const profile = getUserProfile(userId);\n    \n    const deposit = {\n        amount: amount,\n        address: address,\n        txid: txid,\n        timestamp: new Date().toISOString(),\n        confirmed: txid !== null\n    };\n    \n    profile.depositHistory.push(deposit);\n    profile.balance += amount;\n    profile.totalDeposited += amount;\n    \n    updateUserProfile(userId, profile);\n    \n    console.log(`üí∞ Added deposit: ${amount} LTC for user ${userId}`);\n    return deposit;\n}\n\n/**\n * Add withdrawal to user profile\n * @param {string} userId - Discord user ID\n * @param {number} amount - Withdrawal amount in LTC\n * @param {string} toAddress - Destination address\n * @param {string} txid - Transaction ID\n */\nfunction addWithdrawal(userId, amount, toAddress, txid) {\n    const profile = getUserProfile(userId);\n    \n    if (profile.balance < amount) {\n        throw new Error('Insufficient balance');\n    }\n    \n    const withdrawal = {\n        amount: amount,\n        toAddress: toAddress,\n        txid: txid,\n        timestamp: new Date().toISOString()\n    };\n    \n    profile.withdrawalHistory.push(withdrawal);\n    profile.balance -= amount;\n    profile.totalWithdrawn += amount;\n    \n    updateUserProfile(userId, profile);\n    \n    console.log(`üí∏ Added withdrawal: ${amount} LTC for user ${userId}`);\n    return withdrawal;\n}\n\n/**\n * Transfer balance between users\n * @param {string} fromUserId - Sender user ID\n * @param {string} toUserId - Receiver user ID\n * @param {number} amount - Amount to transfer\n */\nfunction transferBalance(fromUserId, toUserId, amount) {\n    const fromProfile = getUserProfile(fromUserId);\n    const toProfile = getUserProfile(toUserId);\n    \n    if (fromProfile.balance < amount) {\n        throw new Error('Insufficient balance');\n    }\n    \n    fromProfile.balance -= amount;\n    toProfile.balance += amount;\n    \n    const transfer = {\n        amount: amount,\n        from: fromUserId,\n        to: toUserId,\n        timestamp: new Date().toISOString(),\n        type: 'transfer'\n    };\n    \n    // Add to both users' histories\n    fromProfile.gameHistory.push({ ...transfer, action: 'sent' });\n    toProfile.gameHistory.push({ ...transfer, action: 'received' });\n    \n    updateUserProfile(fromUserId, fromProfile);\n    updateUserProfile(toUserId, toProfile);\n    \n    console.log(`üîÑ Transfer: ${amount} LTC from ${fromUserId} to ${toUserId}`);\n    return transfer;\n}\n\n/**\n * Link a Litecoin address to a Discord user\n * @param {string} userId - Discord user ID\n * @param {string} address - Litecoin address\n */\nfunction linkAddressToUser(userId, address) {\n    const mapping = loadAddressMapping();\n    const profile = getUserProfile(userId);\n    \n    mapping[address] = userId;\n    profile.addresses.push(address);\n    \n    saveAddressMapping(mapping);\n    updateUserProfile(userId, profile);\n    \n    console.log(`üîó Linked address ${address} to user ${userId}`);\n}\n\n/**\n * Get user ID from Litecoin address\n * @param {string} address - Litecoin address\n * @returns {string|null} Discord user ID or null if not found\n */\nfunction getUserFromAddress(address) {\n    const mapping = loadAddressMapping();\n    return mapping[address] || null;\n}\n\n/**\n * Get all user profiles\n * @returns {Object} All user profiles\n */\nfunction getAllProfiles() {\n    return loadProfiles();\n}\n\n/**\n * Get leaderboard data\n * @param {string} type - 'balance', 'deposited', 'withdrawn'\n * @param {number} limit - Number of users to return\n * @returns {Array} Sorted user data\n */\nfunction getLeaderboard(type = 'balance', limit = 10) {\n    const profiles = loadProfiles();\n    const users = Object.values(profiles);\n    \n    let sortKey;\n    switch (type) {\n        case 'deposited':\n            sortKey = 'totalDeposited';\n            break;\n        case 'withdrawn':\n            sortKey = 'totalWithdrawn';\n            break;\n        default:\n            sortKey = 'balance';\n    }\n    \n    return users\n        .sort((a, b) => b[sortKey] - a[sortKey])\n        .slice(0, limit)\n        .map(user => ({\n            userId: user.userId,\n            value: user[sortKey],\n            balance: user.balance\n        }));\n}\n\n/**\n * Reset user security (password and recovery key) - Admin function\n * @param {string} userId - Discord user ID\n * @returns {Object} Result with success status and new recovery key\n */\nfunction resetUserSecurity(userId) {\n    try {\n        const securityManager = require('./securityManager.js');\n        const profiles = loadProfiles();\n        \n        if (!profiles[userId]) {\n            return { success: false, error: 'User profile not found' };\n        }\n        \n        // Generate new recovery key using securityManager\n        const newRecoveryKey = securityManager.generateRecoveryKey();\n        \n        // Reset password to null (forces user to create new one)\n        const resetResult = securityManager.resetPassword(userId, newRecoveryKey);\n        \n        if (resetResult.success) {\n            console.log(`üîê Admin reset security for user ${userId}`);\n            \n            return {\n                success: true,\n                newRecoveryKey: newRecoveryKey\n            };\n        } else {\n            return { success: false, error: 'Security reset failed' };\n        }\n        \n    } catch (error) {\n        console.error('Error resetting user security:', error);\n        return { success: false, error: 'Reset failed' };\n    }\n}\n\nmodule.exports = {\n    getUserProfile,\n    updateUserProfile,\n    addDeposit,\n    addWithdrawal,\n    transferBalance,\n    linkAddressToUser,\n    getUserFromAddress,\n    getAllProfiles,\n    getLeaderboard,\n    loadProfiles,\n    saveProfiles,\n    resetUserSecurity\n};","size_bytes":9095}},"version":1}