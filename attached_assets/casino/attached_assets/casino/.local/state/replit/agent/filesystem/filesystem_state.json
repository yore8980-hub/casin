{"file_contents":{"index.js":{"content":"","size_bytes":0},"README.md":{"content":"# üé∞ Litecoin Casino Discord Bot\n\nA complete, production-ready Discord bot for running a Litecoin-based casino with automatic deposit detection, balance management, withdrawal functionality, and real-time currency conversion.\n\n## ‚ú® Features\n\n### üéØ Core Casino Features\n- **Automatic Deposit Detection**: Real-time monitoring of Litecoin deposits (30-second intervals)\n- **Balance Management**: Complete user profile system with transaction history\n- **Secure Withdrawals**: Cryptographically secure transaction broadcasting\n- **Address Generation**: Unique Litecoin addresses for each user deposit\n\n### üí¨ Discord Integration\n- **Slash Commands**: Modern Discord slash command interface\n- **Interactive Panels**: Button-based casino interface\n- **Private Channels**: Auto-created private casino sessions\n- **Real-time Notifications**: Instant deposit confirmations via DM\n\n### üí± Currency Features\n- **EUR ‚áÑ USD Conversion**: Real-time exchange rates\n- **LTC Price Display**: Current Litecoin prices in USD/EUR\n- **Multi-currency Support**: Formatted currency displays\n\n### üéÆ Gaming Ready\n- **Modular Architecture**: Easy to add games (blackjack, roulette, slots)\n- **Balance Transfers**: Users can send LTC to each other\n- **Leaderboards**: Top players by balance\n- **Transaction History**: Complete audit trail\n\n## üöÄ Quick Start\n\n### 1. Environment Setup\n\n1. Copy the environment template:\n   ```bash\n   cp .env.example .env\n   ```\n\n2. Fill in your configuration:\n   ```env\n   DISCORD_TOKEN=your_discord_bot_token_here\n   DISCORD_CLIENT_ID=your_discord_application_id_here\n   ```\n\n### 2. Discord Bot Setup\n\n1. Go to [Discord Developer Portal](https://discord.com/developers/applications)\n2. Create a new application\n3. Go to \"Bot\" section and create a bot\n4. Copy the token to your `.env` file\n5. Go to \"General Information\" and copy the Application ID\n6. Enable required bot permissions:\n   - Send Messages\n   - Use Slash Commands\n   - Manage Channels\n   - Read Message History\n\n### 3. API Keys\n\n#### Plus d'API externe requise !\nLe bot utilise maintenant une connexion directe aux explorateurs Litecoin publics.\nAucune cl√© API n'est n√©cessaire pour les op√©rations blockchain.\n\n#### Alternative: Bitquery\n1. Sign up at [Bitquery](https://bitquery.io/)\n2. Get your API key\n3. Add to `.env` as `BITQUERY_API_KEY`\n\n### 4. Deploy Commands\n\n```bash\nnpm run deploy\n```\n\n### 5. Start the Bot\n\n```bash\nnpm start\n```\n\n## üìã Available Commands\n\n### User Commands\n- `/casino` - Open the main casino panel\n- `/profile` - View your casino profile and stats\n- `/balance [@user]` - Check balance (yours or another user's)\n- `/givebal @user amount` - Transfer LTC to another user\n- `/convert-eur-usd amount` - Convert EUR to USD\n- `/convert-usd-eur amount` - Convert USD to EUR\n\n### Interactive Features\n- **Add Balance Button**: Generates unique LTC deposit address\n- **Create Channel Button**: Creates private casino session\n- **Leaderboard**: View top players by balance\n\n## üèóÔ∏è Project Structure\n\n```\n‚îú‚îÄ‚îÄ commands/           # Slash commands\n‚îÇ   ‚îú‚îÄ‚îÄ casino.js      # Main casino panel\n‚îÇ   ‚îú‚îÄ‚îÄ profile.js     # User profile display\n‚îÇ   ‚îú‚îÄ‚îÄ balance.js     # Balance checking\n‚îÇ   ‚îú‚îÄ‚îÄ givebal.js     # Balance transfers\n‚îÇ   ‚îú‚îÄ‚îÄ convert-eur-usd.js\n‚îÇ   ‚îî‚îÄ‚îÄ convert-usd-eur.js\n‚îú‚îÄ‚îÄ events/            # Discord event handlers\n‚îÇ   ‚îú‚îÄ‚îÄ ready.js       # Bot startup & deposit monitoring\n‚îÇ   ‚îî‚îÄ‚îÄ interactionCreate.js\n‚îú‚îÄ‚îÄ utils/             # Utility modules\n‚îÇ   ‚îú‚îÄ‚îÄ userProfiles.js    # User data management\n‚îÇ   ‚îî‚îÄ‚îÄ currencyConverter.js\n‚îú‚îÄ‚îÄ data/              # JSON data storage\n‚îÇ   ‚îú‚îÄ‚îÄ user_profiles.json\n‚îÇ   ‚îî‚îÄ‚îÄ address_mapping.json\n‚îú‚îÄ‚îÄ discord-bot.js     # Main Discord bot file\n‚îú‚îÄ‚îÄ litecoin-casino-bot.js # Litecoin wallet system\n‚îú‚îÄ‚îÄ deploy-commands.js # Command deployment script\n‚îî‚îÄ‚îÄ addresses.json     # Generated LTC addresses\n```\n\n## üîß Core Systems\n\n### Litecoin Wallet System\n- **Address Generation**: Uses `litecore-lib` for secure key generation\n- **UTXO Management**: Automatic unspent output tracking\n- **Transaction Broadcasting**: Direct blockchain submission\n- **Balance Monitoring**: Real-time balance updates\n\n### User Profile System\n- **Persistent Storage**: JSON-based user data\n- **Transaction History**: Complete deposit/withdrawal logs\n- **Balance Tracking**: Real-time balance updates\n- **Address Linking**: Maps LTC addresses to Discord users\n\n### Deposit Detection\n- **Automatic Monitoring**: 30-second interval checks\n- **Real-time Notifications**: Instant Discord DMs\n- **Balance Updates**: Automatic profile updates\n- **Transaction Logging**: Complete audit trail\n\n## üéÆ Adding Casino Games\n\nThe bot is designed for easy game integration. Example blackjack implementation:\n\n```javascript\n// commands/blackjack.js\nconst { SlashCommandBuilder, EmbedBuilder } = require('discord.js');\nconst userProfiles = require('../utils/userProfiles.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('blackjack')\n        .setDescription('Play blackjack')\n        .addNumberOption(option =>\n            option.setName('bet')\n                .setDescription('Bet amount in LTC')\n                .setRequired(true)\n                .setMinValue(0.001)\n        ),\n    \n    async execute(interaction) {\n        // Game implementation here\n        // Deduct bet from user balance\n        // Play game logic\n        // Update balance based on result\n    }\n};\n```\n\n## üîí Security Features\n\n### Private Key Management\n- **Local Generation**: Keys never leave your server\n- **Secure Storage**: JSON file storage with proper permissions\n- **No Exposure**: Private keys never logged or transmitted\n\n### API Security\n- **Token Authentication**: All API calls authenticated\n- **Rate Limiting**: Respects API limits (3 req/sec BlockCypher)\n- **Error Handling**: Graceful degradation on API failures\n\n### Discord Security\n- **Permission Validation**: Proper permission checks\n- **Ephemeral Responses**: Sensitive data hidden from others\n- **DM Notifications**: Private transaction notifications\n\n## üìä Monitoring & Analytics\n\n### Real-time Statistics\n- **Active Users**: Track user engagement\n- **Transaction Volume**: Monitor LTC flow\n- **Deposit Success Rate**: API reliability metrics\n- **Game Performance**: Win/loss statistics (when games added)\n\n### Logging\n- **Comprehensive Logs**: All transactions logged\n- **Error Tracking**: Detailed error information\n- **Performance Metrics**: API response times\n\n## üîß Configuration Options\n\n### Environment Variables\n```env\n# Required\nDISCORD_TOKEN=              # Discord bot token\nDISCORD_CLIENT_ID=          # Discord application ID\nBLOCKCYPHER_TOKEN=          # BlockCypher API token\n\n# Optional\nDISCORD_GUILD_ID=           # For development commands\nBITQUERY_API_KEY=           # Alternative API\n```\n\n### Customization\n- **Check Intervals**: Modify deposit checking frequency\n- **Fee Rates**: Adjust transaction fees\n- **Currencies**: Add more currency pairs\n- **Permissions**: Customize channel permissions\n\n## üöÄ Deployment\n\n### Local Development\n```bash\nnpm install\nnpm run deploy\nnpm start\n```\n\n### Production Deployment\n1. Set up environment variables\n2. Deploy to your preferred hosting service\n3. Ensure persistent file storage for JSON data\n4. Set up monitoring and alerts\n\n### Replit Deployment\n1. Import this project to Replit\n2. Add secrets in the Secrets tab\n3. Run the bot using the Run button\n\n## ü§ù Contributing\n\n1. Fork the repository\n2. Create a feature branch\n3. Add your casino game or feature\n4. Test thoroughly\n5. Submit a pull request\n\n## üìù License\n\nThis project is licensed under the ISC License.\n\n## ‚ö†Ô∏è Disclaimer\n\nThis software is for educational and development purposes. Please ensure compliance with local gambling and cryptocurrency regulations before deploying in production.\n\n## üÜò Support\n\n- **Documentation**: Check this README for common issues\n- **Issues**: Report bugs on GitHub\n- **Discord**: Join our support server (link in bio)\n\n---\n\n**Built with ‚ù§Ô∏è for the crypto casino community**","size_bytes":8181},"SETUP.md":{"content":"# üöÄ Quick Setup Guide\n\n## 1. Get Your API Keys\n\n### Discord Bot Setup\n1. Go to https://discord.com/developers/applications\n2. Click \"New Application\" and give it a name\n3. Go to \"Bot\" section ‚Üí \"Add Bot\"\n4. Copy the **Token** (this is your `DISCORD_TOKEN`)\n5. Go back to \"General Information\" ‚Üí Copy the **Application ID** (this is your `DISCORD_CLIENT_ID`)\n6. Go to \"Bot\" ‚Üí Enable these permissions:\n   - Send Messages\n   - Use Slash Commands\n   - Manage Channels\n   - Read Message History\n\n### BlockCypher API (Free)\n1. Sign up at https://www.blockcypher.com/\n2. Get your free API token (allows 3 requests/second)\n3. This is your `BLOCKCYPHER_TOKEN`\n\n## 2. Configure Environment\n\nAdd these secrets in Replit:\n- `DISCORD_TOKEN` - Your Discord bot token\n- `DISCORD_CLIENT_ID` - Your Discord application ID\n- `BLOCKCYPHER_TOKEN` - Your BlockCypher API token\n\n## 3. Invite Bot to Server\n\nUse this URL (replace YOUR_CLIENT_ID):\n```\nhttps://discord.com/api/oauth2/authorize?client_id=YOUR_CLIENT_ID&permissions=268528640&scope=bot%20applications.commands\n```\n\n## 4. Deploy Commands\n\nRun this once to register slash commands:\n```bash\nnpm run deploy\n```\n\n## 5. Start the Bot\n\n```bash\nnpm start\n```\n\n## üéØ Quick Test\n\n1. In Discord, type `/casino` to open the main panel\n2. Click \"üí∞ Add Balance\" to generate a Litecoin address\n3. Send a small amount of LTC to test deposit detection\n4. Use `/profile` to view your balance\n\n## üîß Troubleshooting\n\n- **\"DISCORD_TOKEN is required\"**: Add your Discord token to secrets\n- **Commands not showing**: Run `npm run deploy` first\n- **No deposit detection**: Check if `BLOCKCYPHER_TOKEN` is set correctly\n- **Permission errors**: Make sure bot has required permissions in your server\n\n## üéÆ Ready Features\n\n### üîí Security System\n- ‚úÖ Password-protected accounts (`/setpassword`)\n- ‚úÖ Recovery key system (`/recoverykey`)\n- ‚úÖ Timed gambling sessions (`/enable`)\n- ‚úÖ 100% wagering requirement before cashout\n\n### üí∞ Financial System  \n- ‚úÖ Smart deposit monitoring (only when needed)\n- ‚úÖ Unique addresses for each deposit\n- ‚úÖ Secure password-protected withdrawals (`/cashout`)\n- ‚úÖ Balance management and transfers\n- ‚úÖ Currency conversion (EUR/USD)\n\n### üé∞ Casino Features\n- ‚úÖ User profiles and statistics\n- ‚úÖ Private channel creation\n- ‚úÖ Test gambling system (`/testgamble`)\n- üöß Games (blackjack, roulette) - Ready for implementation\n\n## üì± Example Usage\n\n### Initial Setup\n```\nUser: /setpassword mypassword123\nBot: ‚úÖ Password set! Recovery key: A1B2C3D4E5F6...\n\nUser: /casino\nBot: [Shows casino panel with Add Balance button]\n```\n\n### Adding Balance\n```\nUser: [Clicks Add Balance]\nBot: Send LTC to: LxxxxxxxxxxxxxxxxxxxxxxxxxxxX\n     [NEW unique address generated]\n\nUser: [Sends 0.01 LTC]\nBot: ‚úÖ Deposit confirmed! 0.01 LTC added\n     Note: Must wager 100% before cashout\n```\n\n### Gambling Session\n```\nUser: /enable 30 mypassword123\nBot: ‚úÖ Gambling session active for 30 minutes\n\nUser: /testgamble 0.005\nBot: üéâ You won! +0.009 LTC\n     Cashout progress: 50% complete\n```\n\n### Secure Cashout\n```\nUser: /cashout LxxxDestinationxxx 0.015 mypassword123\nBot: ‚úÖ Withdrawal successful! TXID: abc123...\n```\n\nYour casino bot is now ready! üé∞","size_bytes":3227},"commands/addwhitelist.js":{"content":"const { SlashCommandBuilder, EmbedBuilder, PermissionFlagsBits } = require('discord.js');\nconst panelManager = require('../utils/panelManager.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('addwhitelist')\n        .setDescription('Add this server to panel management whitelist (Bot Owner only)')\n        .addRoleOption(option =>\n            option.setName('admin_role')\n                .setDescription('Role that can manage panels (optional)')\n                .setRequired(false)\n        ),\n    \n    async execute(interaction) {\n        // Check if interaction is too old\n        const interactionAge = Date.now() - interaction.createdTimestamp;\n        if (interactionAge > 10 * 60 * 1000) {\n            console.log('Interaction trop ancienne, ignor√©e');\n            return;\n        }\n        \n        // Check if user is bot owner (you can change this logic)\n        const botOwnerIds = ['1409315903937449994']; // Add your user ID here\n        \n        if (!botOwnerIds.includes(interaction.user.id)) {\n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Access Denied')\n                .setDescription('Only the bot owner can manage the whitelist.')\n                .setTimestamp();\n            \n            await interaction.reply({ embeds: [errorEmbed], ephemeral: true });\n            return;\n        }\n        \n        await interaction.deferReply({ ephemeral: true });\n        \n        try {\n            const adminRole = interaction.options.getRole('admin_role');\n            const serverId = interaction.guild.id;\n            \n            // Add to whitelist\n            const success = panelManager.addToWhitelist(serverId, adminRole?.id);\n            \n            if (success) {\n                const successEmbed = new EmbedBuilder()\n                    .setColor('#00ff00')\n                    .setTitle('‚úÖ Server Whitelisted')\n                    .setDescription(`Server **${interaction.guild.name}** has been added to the whitelist.`)\n                    .addFields(\n                        {\n                            name: 'üèõÔ∏è Server',\n                            value: interaction.guild.name,\n                            inline: true\n                        },\n                        {\n                            name: 'üëë Admin Role',\n                            value: adminRole ? adminRole.name : 'None (all members can manage)',\n                            inline: true\n                        },\n                        {\n                            name: 'üìã Available Commands',\n                            value: '‚Ä¢ `/setpanel` - Configure casino panels\\n‚Ä¢ `/stopallactives` - Stop active deposits',\n                            inline: false\n                        }\n                    )\n                    .setFooter({ text: `Server ID: ${serverId}` })\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [successEmbed] });\n                \n                console.log(`‚úÖ Serveur ${interaction.guild.name} ajout√© √† la whitelist par ${interaction.user.username}`);\n                \n            } else {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Whitelist Failed')\n                    .setDescription('Failed to add server to whitelist.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n            }\n            \n        } catch (error) {\n            console.error('Erreur addwhitelist:', error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Error')\n                .setDescription('An error occurred while adding server to whitelist.')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};","size_bytes":4028},"commands/balance.js":{"content":"const { SlashCommandBuilder, EmbedBuilder } = require('discord.js');\nconst userProfiles = require('../utils/userProfiles.js');\nconst currencyConverter = require('../utils/currencyConverter.js');\nconst { formatLTC, formatUSD } = require('../utils/formatters.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('balance')\n        .setDescription('Check your current balance')\n        .addUserOption(option =>\n            option.setName('user')\n                .setDescription('User to check balance for (optional)')\n                .setRequired(false)\n        ),\n    \n    async execute(interaction) {\n        // Check if interaction is too old\n        const interactionAge = Date.now() - interaction.createdTimestamp;\n        if (interactionAge > 10 * 60 * 1000) {\n            console.log('Interaction trop ancienne, ignor√©e');\n            return;\n        }\n        \n        await interaction.deferReply();\n        \n        try {\n            const targetUser = interaction.options.getUser('user') || interaction.user;\n            const profile = userProfiles.getUserProfile(targetUser.id);\n            \n            // Get LTC price for USD conversion\n            let ltcPrice = null;\n            let eurPrice = null;\n            \n            try {\n                const [usdData, eurData] = await Promise.all([\n                    currencyConverter.getLitecoinPrice('USD'),\n                    currencyConverter.getLitecoinPrice('EUR')\n                ]);\n                ltcPrice = usdData.price;\n                eurPrice = eurData.price;\n            } catch (error) {\n                console.log('Could not fetch crypto prices:', error.message);\n            }\n            \n            const balanceEmbed = new EmbedBuilder()\n                .setColor('#f7931a')\n                .setTitle('üí∞ Balance Information')\n                .setAuthor({ \n                    name: targetUser.username, \n                    iconURL: targetUser.displayAvatarURL() \n                })\n                .addFields({\n                    name: 'ü™ô Litecoin Balance',\n                    value: `**${formatLTC(profile.balance)} LTC**`,\n                    inline: false\n                })\n                .setThumbnail('https://cryptologos.cc/logos/litecoin-ltc-logo.png')\n                .setTimestamp();\n            \n            // Add USD and EUR conversions if available\n            if (ltcPrice && eurPrice) {\n                const usdValue = profile.balance * ltcPrice;\n                const eurValue = profile.balance * eurPrice;\n                \n                balanceEmbed.addFields(\n                    {\n                        name: 'üíµ USD Equivalent',\n                        value: `$${formatUSD(usdValue)}`,\n                        inline: true\n                    },\n                    {\n                        name: 'üí∂ EUR Equivalent',\n                        value: `‚Ç¨${formatUSD(eurValue)}`,\n                        inline: true\n                    }\n                );\n            }\n            \n            // Add quick stats\n            if (profile.depositHistory.length > 0 || profile.withdrawalHistory.length > 0) {\n                balanceEmbed.addFields({\n                    name: 'üìä Quick Stats',\n                    value: `**Total Deposited:** ${formatLTC(profile.totalDeposited)} LTC\\n**Total Withdrawn:** ${formatLTC(profile.totalWithdrawn)} LTC\\n**Net Gain/Loss:** ${formatLTC(profile.totalDeposited - profile.totalWithdrawn - profile.balance)} LTC`,\n                    inline: false\n                });\n            }\n            \n            // Check if viewing someone else's balance\n            if (targetUser.id !== interaction.user.id) {\n                balanceEmbed.setFooter({ text: `Balance requested by ${interaction.user.username}` });\n            }\n            \n            await interaction.editReply({ embeds: [balanceEmbed] });\n            \n        } catch (error) {\n            console.error('Balance command error:', error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Error')\n                .setDescription('Failed to fetch balance information. Please try again.')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};","size_bytes":4361},"commands/cashout.js":{"content":"const { SlashCommandBuilder, EmbedBuilder } = require('discord.js');\nconst securityManager = require('../utils/securityManager.js');\nconst userProfiles = require('../utils/userProfiles.js');\nconst ltcWallet = require('../litecoin-casino-bot.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('cashout')\n        .setDescription('Withdraw your LTC balance (requires password and 100% wagering)')\n        .addStringOption(option =>\n            option.setName('address')\n                .setDescription('Your LTC address to withdraw to')\n                .setRequired(true)\n        )\n        .addNumberOption(option =>\n            option.setName('amount')\n                .setDescription('Amount to withdraw in LTC')\n                .setRequired(true)\n                .setMinValue(0.001)\n        )\n        .addStringOption(option =>\n            option.setName('password')\n                .setDescription('Your account password')\n                .setRequired(true)\n        ),\n    \n    async execute(interaction) {\n        await interaction.deferReply({ ephemeral: true });\n        \n        try {\n            const toAddress = interaction.options.getString('address');\n            const amount = interaction.options.getNumber('amount');\n            const password = interaction.options.getString('password');\n            const userId = interaction.user.id;\n            \n            // Check if user has a password set\n            const userSec = securityManager.getUserSecurity(userId);\n            if (!userSec.hasPassword) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå No Password Set')\n                    .setDescription('You need to set a password first using `/setpassword` to cashout.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Verify password\n            if (!securityManager.verifyUserPassword(userId, password)) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Wrong Password')\n                    .setDescription('The password you entered is incorrect.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Check cashout eligibility (100% wagering requirement)\n            const cashoutStatus = securityManager.canUserCashout(userId);\n            \n            if (!cashoutStatus.canCashout) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Cashout Not Allowed')\n                    .setDescription('You must wager at least 100% of your deposited amount before cashing out.')\n                    .addFields(\n                        {\n                            name: 'üìä Wagering Status',\n                            value: `**Deposited:** ${cashoutStatus.depositedAmount.toFixed(8)} LTC\\n**Wagered:** ${cashoutStatus.wageredAmount.toFixed(8)} LTC\\n**Progress:** ${cashoutStatus.wageredPercent.toFixed(1)}%`,\n                            inline: true\n                        },\n                        {\n                            name: 'üéØ Remaining to Wager',\n                            value: `${cashoutStatus.remainingToWager.toFixed(8)} LTC`,\n                            inline: true\n                        },\n                        {\n                            name: 'üí° How to Unlock Cashout',\n                            value: 'Play casino games to increase your wagered amount to 100% of deposits.',\n                            inline: false\n                        }\n                    )\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Check user balance\n            const profile = userProfiles.getUserProfile(userId);\n            \n            if (profile.balance < amount) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Insufficient Balance')\n                    .setDescription(`You don't have enough balance to withdraw.`)\n                    .addFields({\n                        name: 'üí∞ Available Balance',\n                        value: `${profile.balance.toFixed(8)} LTC`,\n                        inline: true\n                    })\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Find a source address with sufficient balance\n            const addresses = ltcWallet.loadAddresses();\n            let fromAddress = null;\n            \n            for (const addr of addresses) {\n                if (addr.balance >= amount) {\n                    fromAddress = addr.address;\n                    break;\n                }\n            }\n            \n            if (!fromAddress) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå No Suitable Address')\n                    .setDescription('No address found with sufficient balance for withdrawal.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Process withdrawal\n            const processingEmbed = new EmbedBuilder()\n                .setColor('#ffaa00')\n                .setTitle('‚è≥ Processing Withdrawal')\n                .setDescription('Your withdrawal is being processed...')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [processingEmbed] });\n            \n            // Execute withdrawal\n            const txid = await ltcWallet.withdraw(fromAddress, toAddress, amount);\n            \n            if (!txid) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Withdrawal Failed')\n                    .setDescription('Failed to process withdrawal. Please try again or contact support.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Update user profile\n            userProfiles.addWithdrawal(userId, amount, toAddress, txid);\n            \n            const successEmbed = new EmbedBuilder()\n                .setColor('#00ff00')\n                .setTitle('‚úÖ Withdrawal Successful')\n                .setDescription('Your withdrawal has been processed and broadcasted to the Litecoin network.')\n                .addFields(\n                    {\n                        name: 'üí∞ Amount',\n                        value: `${amount.toFixed(8)} LTC`,\n                        inline: true\n                    },\n                    {\n                        name: 'üìç Destination',\n                        value: `\\`${toAddress}\\``,\n                        inline: false\n                    },\n                    {\n                        name: 'üîó Transaction ID',\n                        value: `\\`${txid}\\``,\n                        inline: false\n                    },\n                    {\n                        name: '‚è∞ Status',\n                        value: 'Transaction broadcasted - confirmations pending',\n                        inline: false\n                    }\n                )\n                .setThumbnail('https://cryptologos.cc/logos/litecoin-ltc-logo.png')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [successEmbed] });\n            \n            console.log(`üí∏ Processed withdrawal: ${amount} LTC for user ${interaction.user.username} - TXID: ${txid}`);\n            \n        } catch (error) {\n            console.error('Cashout error:', error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Cashout Error')\n                .setDescription('An error occurred while processing your withdrawal. Please try again.')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};","size_bytes":8639},"commands/casino.js":{"content":"const { SlashCommandBuilder, EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle } = require('discord.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('casino')\n        .setDescription('Open the casino main panel'),\n    \n    async execute(interaction) {\n        // Check if interaction is too old\n        const interactionAge = Date.now() - interaction.createdTimestamp;\n        if (interactionAge > 10 * 60 * 1000) {\n            console.log('Interaction trop ancienne, ignor√©e');\n            return;\n        }\n        \n        try {\n            const casinoEmbed = new EmbedBuilder()\n                .setColor('#f7931a')\n                .setTitle('üé∞ Litecoin Casino')\n                .setDescription('Welcome to the Litecoin Casino! Choose an option below to get started.')\n                .addFields(\n                    {\n                        name: 'üí∞ Add Balance',\n                        value: 'Generate a unique Litecoin address to deposit funds',\n                        inline: true\n                    },\n                    {\n                        name: 'üéÆ Games Available',\n                        value: 'Blackjack, Roulette - Start playing now!',\n                        inline: true\n                    },\n                    {\n                        name: 'üìä Profile',\n                        value: 'View your balance and transaction history',\n                        inline: true\n                    }\n                )\n                .setThumbnail('https://cryptologos.cc/logos/litecoin-ltc-logo.png')\n                .setImage('https://i.imgur.com/9KpZK8h.png') // Casino banner (optional)\n                .setFooter({ text: 'Secure ‚Ä¢ Fast ‚Ä¢ Transparent' })\n                .setTimestamp();\n            \n            const actionRow = new ActionRowBuilder()\n                .addComponents(\n                    new ButtonBuilder()\n                        .setCustomId('add_balance')\n                        .setLabel('üí∞ Add Balance')\n                        .setStyle(ButtonStyle.Success)\n                        .setEmoji('üí∞'),\n                    new ButtonBuilder()\n                        .setCustomId('view_profile')\n                        .setLabel('üë§ Profile')\n                        .setStyle(ButtonStyle.Primary)\n                        .setEmoji('üë§'),\n                    new ButtonBuilder()\n                        .setCustomId('leaderboard')\n                        .setLabel('üèÜ Leaderboard')\n                        .setStyle(ButtonStyle.Secondary)\n                        .setEmoji('üèÜ')\n                );\n            \n            // Games row (now functional!)\n            const gamesRow = new ActionRowBuilder()\n                .addComponents(\n                    new ButtonBuilder()\n                        .setCustomId('casino_blackjack')\n                        .setLabel('üÉè Blackjack')\n                        .setStyle(ButtonStyle.Primary)\n                        .setEmoji('üÉè'),\n                    new ButtonBuilder()\n                        .setCustomId('casino_roulette')\n                        .setLabel('üé∞ Roulette')\n                        .setStyle(ButtonStyle.Primary)\n                        .setEmoji('üé∞'),\n                    new ButtonBuilder()\n                        .setCustomId('casino_slots')\n                        .setLabel('üé≤ Slots')\n                        .setStyle(ButtonStyle.Secondary)\n                        .setEmoji('üé≤')\n                        .setDisabled(true) // Coming soon\n                );\n            \n            await interaction.reply({ \n                embeds: [casinoEmbed], \n                components: [actionRow, gamesRow]\n            });\n            \n        } catch (error) {\n            console.error('Casino command error:', error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Error')\n                .setDescription('Failed to load casino panel. Please try again.')\n                .setTimestamp();\n            \n            try {\n                if (interaction.replied || interaction.deferred) {\n                    await interaction.followUp({ embeds: [errorEmbed], ephemeral: true });\n                } else {\n                    await interaction.reply({ embeds: [errorEmbed], ephemeral: true });\n                }\n            } catch (replyError) {\n                console.error('Impossible de r√©pondre √† l\\'erreur casino:', replyError.message);\n            }\n        }\n    }\n};","size_bytes":4564},"commands/changepassword.js":{"content":"const { SlashCommandBuilder, EmbedBuilder } = require('discord.js');\nconst securityManager = require('../utils/securityManager.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('changepassword')\n        .setDescription('Change your account password')\n        .addStringOption(option =>\n            option.setName('oldpassword')\n                .setDescription('Your current password')\n                .setRequired(true)\n        )\n        .addStringOption(option =>\n            option.setName('newpassword')\n                .setDescription('Your new password (minimum 6 characters)')\n                .setRequired(true)\n        ),\n    \n    async execute(interaction) {\n        await interaction.deferReply({ ephemeral: true });\n        \n        try {\n            const oldPassword = interaction.options.getString('oldpassword');\n            const newPassword = interaction.options.getString('newpassword');\n            \n            // Validate new password\n            if (newPassword.length < 6) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Invalid Password')\n                    .setDescription('New password must be at least 6 characters long.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Check if user has a password set\n            const userSec = securityManager.getUserSecurity(interaction.user.id);\n            if (!userSec.hasPassword) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå No Password Set')\n                    .setDescription('You need to set a password first using `/setpassword`.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Try to change password\n            const success = securityManager.changeUserPassword(interaction.user.id, oldPassword, newPassword);\n            \n            if (!success) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Wrong Password')\n                    .setDescription('Your current password is incorrect.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            const successEmbed = new EmbedBuilder()\n                .setColor('#00ff00')\n                .setTitle('‚úÖ Password Changed')\n                .setDescription('Your password has been successfully changed.')\n                .addFields({\n                    name: 'üîí Security',\n                    value: 'Your recovery key remains the same and is still valid.',\n                    inline: false\n                })\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [successEmbed] });\n            \n        } catch (error) {\n            console.error('Change password error:', error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Error')\n                .setDescription('Failed to change password. Please try again.')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};","size_bytes":3608},"commands/convert-eur-usd.js":{"content":"const { SlashCommandBuilder, EmbedBuilder } = require('discord.js');\nconst currencyConverter = require('../utils/currencyConverter.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('convert-eur-usd')\n        .setDescription('Convert EUR to USD')\n        .addNumberOption(option =>\n            option.setName('amount')\n                .setDescription('Amount in EUR to convert')\n                .setRequired(true)\n                .setMinValue(0.01)\n        ),\n    \n    async execute(interaction) {\n        await interaction.deferReply();\n        \n        try {\n            const amount = interaction.options.getNumber('amount');\n            \n            // Perform currency conversion\n            const conversion = await currencyConverter.convertCurrency(amount, 'EUR', 'USD');\n            \n            const conversionEmbed = new EmbedBuilder()\n                .setColor('#4CAF50')\n                .setTitle('üí± Currency Conversion')\n                .setDescription('**EUR ‚Üí USD**')\n                .addFields(\n                    {\n                        name: 'üá™üá∫ Euro Amount',\n                        value: `‚Ç¨${conversion.originalAmount.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`,\n                        inline: true\n                    },\n                    {\n                        name: 'üá∫üá∏ US Dollar Equivalent',\n                        value: `$${conversion.convertedAmount.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`,\n                        inline: true\n                    },\n                    {\n                        name: 'üìä Exchange Rate',\n                        value: `1 EUR = $${conversion.exchangeRate.toFixed(4)} USD`,\n                        inline: false\n                    }\n                )\n                .setFooter({ \n                    text: 'Exchange rates are updated in real-time' \n                })\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [conversionEmbed] });\n            \n        } catch (error) {\n            console.error('EUR to USD conversion error:', error);\n            \n            let errorMessage = 'Failed to convert currency. Please try again later.';\n            \n            if (error.message.includes('Amount must be greater than 0')) {\n                errorMessage = 'Please enter a valid amount greater than 0.';\n            } else if (error.message.includes('Failed to fetch exchange rate')) {\n                errorMessage = 'Currency conversion service is temporarily unavailable.';\n            }\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Conversion Failed')\n                .setDescription(errorMessage)\n                .addFields({\n                    name: 'üí° Tip',\n                    value: 'Exchange rates are fetched from external APIs. Please try again in a few moments.',\n                    inline: false\n                })\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};","size_bytes":3206},"commands/convert-usd-eur.js":{"content":"const { SlashCommandBuilder, EmbedBuilder } = require('discord.js');\nconst currencyConverter = require('../utils/currencyConverter.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('convert-usd-eur')\n        .setDescription('Convert USD to EUR')\n        .addNumberOption(option =>\n            option.setName('amount')\n                .setDescription('Amount in USD to convert')\n                .setRequired(true)\n                .setMinValue(0.01)\n        ),\n    \n    async execute(interaction) {\n        await interaction.deferReply();\n        \n        try {\n            const amount = interaction.options.getNumber('amount');\n            \n            // Perform currency conversion\n            const conversion = await currencyConverter.convertCurrency(amount, 'USD', 'EUR');\n            \n            const conversionEmbed = new EmbedBuilder()\n                .setColor('#4CAF50')\n                .setTitle('üí± Currency Conversion')\n                .setDescription('**USD ‚Üí EUR**')\n                .addFields(\n                    {\n                        name: 'üá∫üá∏ US Dollar Amount',\n                        value: `$${conversion.originalAmount.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`,\n                        inline: true\n                    },\n                    {\n                        name: 'üá™üá∫ Euro Equivalent',\n                        value: `‚Ç¨${conversion.convertedAmount.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`,\n                        inline: true\n                    },\n                    {\n                        name: 'üìä Exchange Rate',\n                        value: `1 USD = ‚Ç¨${conversion.exchangeRate.toFixed(4)} EUR`,\n                        inline: false\n                    }\n                )\n                .setFooter({ \n                    text: 'Exchange rates are updated in real-time' \n                })\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [conversionEmbed] });\n            \n        } catch (error) {\n            console.error('USD to EUR conversion error:', error);\n            \n            let errorMessage = 'Failed to convert currency. Please try again later.';\n            \n            if (error.message.includes('Amount must be greater than 0')) {\n                errorMessage = 'Please enter a valid amount greater than 0.';\n            } else if (error.message.includes('Failed to fetch exchange rate')) {\n                errorMessage = 'Currency conversion service is temporarily unavailable.';\n            }\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Conversion Failed')\n                .setDescription(errorMessage)\n                .addFields({\n                    name: 'üí° Tip',\n                    value: 'Exchange rates are fetched from external APIs. Please try again in a few moments.',\n                    inline: false\n                })\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};","size_bytes":3208},"commands/enable.js":{"content":"const { SlashCommandBuilder, EmbedBuilder } = require('discord.js');\nconst securityManager = require('../utils/securityManager.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('enable')\n        .setDescription('Enable gambling session with time limit (requires password)')\n        .addIntegerOption(option =>\n            option.setName('minutes')\n                .setDescription('Session duration in minutes (1-60)')\n                .setRequired(true)\n                .setMinValue(1)\n                .setMaxValue(60)\n        )\n        .addStringOption(option =>\n            option.setName('password')\n                .setDescription('Your account password')\n                .setRequired(true)\n        ),\n    \n    async execute(interaction) {\n        await interaction.deferReply({ ephemeral: true });\n        \n        try {\n            const minutes = interaction.options.getInteger('minutes');\n            const password = interaction.options.getString('password');\n            \n            // Check if user has a password set\n            const userSec = securityManager.getUserSecurity(interaction.user.id);\n            if (!userSec.hasPassword) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå No Password Set')\n                    .setDescription('You need to set a password first using `/setpassword` to enable gambling sessions.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Verify password\n            if (!securityManager.verifyUserPassword(interaction.user.id, password)) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Wrong Password')\n                    .setDescription('The password you entered is incorrect.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Check if user already has an active session\n            if (securityManager.hasActiveGamblingSession(interaction.user.id)) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ffaa00')\n                    .setTitle('‚ö†Ô∏è Session Already Active')\n                    .setDescription('You already have an active gambling session. Wait for it to expire before starting a new one.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Start gambling session\n            const endTime = securityManager.startGamblingSession(interaction.user.id, minutes);\n            \n            const successEmbed = new EmbedBuilder()\n                .setColor('#00ff00')\n                .setTitle('üé∞ Gambling Session Enabled')\n                .setDescription(`Your gambling session is now active for **${minutes} minute${minutes > 1 ? 's' : ''}**.`)\n                .addFields(\n                    {\n                        name: '‚è∞ Session Details',\n                        value: `**Started:** <t:${Math.floor(Date.now()/1000)}:T>\\n**Ends:** <t:${Math.floor(endTime.getTime()/1000)}:T>\\n**Duration:** ${minutes} minute${minutes > 1 ? 's' : ''}`,\n                        inline: false\n                    },\n                    {\n                        name: 'üéÆ What you can do now',\n                        value: '‚Ä¢ Play casino games\\n‚Ä¢ Place bets\\n‚Ä¢ Use gambling features\\n‚Ä¢ All protected by your session',\n                        inline: true\n                    },\n                    {\n                        name: 'üîí Security',\n                        value: '‚Ä¢ Session auto-expires\\n‚Ä¢ Password protected\\n‚Ä¢ Secure gambling environment',\n                        inline: true\n                    }\n                )\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [successEmbed] });\n            \n        } catch (error) {\n            console.error('Enable gambling session error:', error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Error')\n                .setDescription('Failed to enable gambling session. Please try again.')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};","size_bytes":4646},"commands/givebal.js":{"content":"const { SlashCommandBuilder, EmbedBuilder } = require('discord.js');\nconst userProfiles = require('../utils/userProfiles.js');\nconst { formatLTC } = require('../utils/formatters.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('givebal')\n        .setDescription('Transfer balance to another user')\n        .addUserOption(option =>\n            option.setName('user')\n                .setDescription('User to transfer balance to')\n                .setRequired(true)\n        )\n        .addNumberOption(option =>\n            option.setName('amount')\n                .setDescription('Amount to transfer (in LTC)')\n                .setRequired(true)\n                .setMinValue(0.00000001)\n        ),\n    \n    async execute(interaction) {\n        await interaction.deferReply();\n        \n        try {\n            const targetUser = interaction.options.getUser('user');\n            const amount = interaction.options.getNumber('amount');\n            const fromUserId = interaction.user.id;\n            const toUserId = targetUser.id;\n            \n            // Validation checks\n            if (fromUserId === toUserId) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Invalid Transfer')\n                    .setDescription('You cannot transfer balance to yourself!')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            if (amount <= 0) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Invalid Amount')\n                    .setDescription('Amount must be greater than 0!')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Check sender's balance\n            const senderProfile = userProfiles.getUserProfile(fromUserId);\n            \n            if (senderProfile.balance < amount) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Insufficient Balance')\n                    .setDescription(`You don't have enough balance!\\n\\n**Your Balance:** ${formatLTC(senderProfile.balance)} LTC\\n**Required:** ${formatLTC(amount)} LTC`)\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Perform the transfer\n            const transfer = userProfiles.transferBalance(fromUserId, toUserId, amount);\n            \n            // Get updated profiles\n            const updatedSenderProfile = userProfiles.getUserProfile(fromUserId);\n            const updatedReceiverProfile = userProfiles.getUserProfile(toUserId);\n            \n            const successEmbed = new EmbedBuilder()\n                .setColor('#00ff00')\n                .setTitle('‚úÖ Transfer Successful')\n                .setDescription(`Successfully transferred **${formatLTC(amount)} LTC** to ${targetUser}`)\n                .addFields(\n                    {\n                        name: 'üë§ From',\n                        value: `${interaction.user}\\n**New Balance:** ${formatLTC(updatedSenderProfile.balance)} LTC`,\n                        inline: true\n                    },\n                    {\n                        name: 'üë§ To',\n                        value: `${targetUser}\\n**New Balance:** ${formatLTC(updatedReceiverProfile.balance)} LTC`,\n                        inline: true\n                    },\n                    {\n                        name: 'üìã Transaction Details',\n                        value: `**Amount:** ${formatLTC(amount)} LTC\\n**Date:** ${new Date(transfer.timestamp).toLocaleString()}\\n**ID:** ${transfer.timestamp}`,\n                        inline: false\n                    }\n                )\n                .setThumbnail('https://cryptologos.cc/logos/litecoin-ltc-logo.png')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [successEmbed] });\n            \n            // Try to notify the receiver (if they share a server)\n            try {\n                const receiverDM = await targetUser.createDM();\n                \n                const notificationEmbed = new EmbedBuilder()\n                    .setColor('#00ff00')\n                    .setTitle('üí∞ Balance Received')\n                    .setDescription(`You received **${amount.toFixed(8)} LTC** from ${interaction.user.username}!`)\n                    .addFields({\n                        name: 'üí≥ Your New Balance',\n                        value: `${updatedReceiverProfile.balance.toFixed(8)} LTC`,\n                        inline: true\n                    })\n                    .setThumbnail('https://cryptologos.cc/logos/litecoin-ltc-logo.png')\n                    .setTimestamp();\n                \n                await receiverDM.send({ embeds: [notificationEmbed] });\n            } catch (dmError) {\n                console.log('Could not send DM notification:', dmError.message);\n                // This is not critical, so we don't show error to user\n            }\n            \n        } catch (error) {\n            console.error('Transfer command error:', error);\n            \n            let errorMessage = 'Failed to process transfer. Please try again.';\n            \n            if (error.message === 'Insufficient balance') {\n                errorMessage = 'Insufficient balance for this transfer.';\n            }\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Transfer Failed')\n                .setDescription(errorMessage)\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};","size_bytes":6057},"commands/profile.js":{"content":"const { SlashCommandBuilder, EmbedBuilder } = require('discord.js');\nconst userProfiles = require('../utils/userProfiles.js');\nconst currencyConverter = require('../utils/currencyConverter.js');\nconst { formatLTC, formatUSD } = require('../utils/formatters.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('profile')\n        .setDescription('View your casino profile and balance'),\n    \n    async execute(interaction) {\n        // Check if interaction is too old (Discord timeout is 15 minutes)\n        const interactionAge = Date.now() - interaction.createdTimestamp;\n        if (interactionAge > 10 * 60 * 1000) { // 10 minutes safety margin\n            console.log('Interaction trop ancienne, ignor√©e');\n            return;\n        }\n        \n        await interaction.deferReply();\n        \n        try {\n            const profile = userProfiles.getUserProfile(interaction.user.id);\n            \n            // Get recent deposit and withdrawal\n            const recentDeposit = profile.depositHistory.slice(-1)[0];\n            const recentWithdrawal = profile.withdrawalHistory.slice(-1)[0];\n            \n            // Try to get LTC price for reference\n            let ltcPrice = null;\n            try {\n                const priceData = await currencyConverter.getLitecoinPrice('USD');\n                ltcPrice = priceData.price;\n            } catch (error) {\n                console.log('Could not fetch LTC price:', error.message);\n            }\n            \n            const profileEmbed = new EmbedBuilder()\n                .setColor('#f7931a')\n                .setTitle('üé∞ Casino Profile')\n                .setAuthor({ \n                    name: interaction.user.username, \n                    iconURL: interaction.user.displayAvatarURL() \n                })\n                .addFields(\n                    { \n                        name: 'üí∞ Current Balance', \n                        value: `**${formatLTC(profile.balance)} LTC**${ltcPrice ? `\\n‚âà $${formatUSD(profile.balance * ltcPrice)} USD` : ''}`, \n                        inline: true \n                    },\n                    { \n                        name: 'üìä Statistics', \n                        value: `**Deposited:** ${formatLTC(profile.totalDeposited)} LTC\\n**Withdrawn:** ${formatLTC(profile.totalWithdrawn)} LTC\\n**Net:** ${formatLTC(profile.totalDeposited - profile.totalWithdrawn)} LTC`, \n                        inline: true \n                    },\n                    { \n                        name: 'üéÆ Activity', \n                        value: `**Deposits:** ${profile.depositHistory.length}\\n**Withdrawals:** ${profile.withdrawalHistory.length}\\n**Games Played:** ${profile.gameHistory.length}`, \n                        inline: true \n                    }\n                )\n                .setThumbnail('https://cryptologos.cc/logos/litecoin-ltc-logo.png')\n                .setFooter({ \n                    text: `Member since ${new Date(profile.createdAt).toLocaleDateString()}` \n                })\n                .setTimestamp();\n            \n            // Add recent activity if available\n            if (recentDeposit || recentWithdrawal) {\n                let recentActivity = '';\n                \n                if (recentDeposit) {\n                    const depositDate = new Date(recentDeposit.timestamp).toLocaleDateString();\n                    recentActivity += `üì• **Last Deposit:** ${formatLTC(recentDeposit.amount)} LTC (${depositDate})\\n`;\n                }\n                \n                if (recentWithdrawal) {\n                    const withdrawalDate = new Date(recentWithdrawal.timestamp).toLocaleDateString();\n                    recentActivity += `üì§ **Last Withdrawal:** ${formatLTC(recentWithdrawal.amount)} LTC (${withdrawalDate})`;\n                }\n                \n                profileEmbed.addFields({\n                    name: 'üìà Recent Activity',\n                    value: recentActivity,\n                    inline: false\n                });\n            }\n            \n            // Add addresses count if any\n            if (profile.addresses.length > 0) {\n                profileEmbed.addFields({\n                    name: 'üìç Linked Addresses',\n                    value: `${profile.addresses.length} Litecoin address(es)`,\n                    inline: true\n                });\n            }\n            \n            await interaction.editReply({ embeds: [profileEmbed] });\n            \n        } catch (error) {\n            console.error('Profile command error:', error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Error')\n                .setDescription('Failed to load your profile. Please try again.')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};","size_bytes":4915},"commands/recoverykey.js":{"content":"const { SlashCommandBuilder, EmbedBuilder } = require('discord.js');\nconst securityManager = require('../utils/securityManager.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('recoverykey')\n        .setDescription('View your recovery key (requires password)')\n        .addStringOption(option =>\n            option.setName('password')\n                .setDescription('Your account password')\n                .setRequired(true)\n        ),\n    \n    async execute(interaction) {\n        await interaction.deferReply({ ephemeral: true });\n        \n        try {\n            const password = interaction.options.getString('password');\n            \n            // Check if user has a password set\n            const userSec = securityManager.getUserSecurity(interaction.user.id);\n            if (!userSec.hasPassword) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå No Password Set')\n                    .setDescription('You need to set a password first using `/setpassword`.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Verify password\n            if (!securityManager.verifyUserPassword(interaction.user.id, password)) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Wrong Password')\n                    .setDescription('The password you entered is incorrect.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            const recoveryKeyEmbed = new EmbedBuilder()\n                .setColor('#f7931a')\n                .setTitle('üîë Your Recovery Key')\n                .setDescription('**Keep this key safe!** You need it to recover your account.')\n                .addFields(\n                    {\n                        name: 'üîê Recovery Key',\n                        value: `\\`${userSec.recoveryKey}\\``,\n                        inline: false\n                    },\n                    {\n                        name: '‚ö†Ô∏è Security Warning',\n                        value: 'Never share this key with anyone. Store it in a secure location offline.',\n                        inline: false\n                    },\n                    {\n                        name: 'üîÑ Reset Key',\n                        value: 'Use `/resetrecovery` if you want to generate a new recovery key.',\n                        inline: false\n                    }\n                )\n                .setFooter({ text: 'This message will delete automatically for security' })\n                .setTimestamp();\n            \n            const message = await interaction.editReply({ embeds: [recoveryKeyEmbed] });\n            \n            // Auto-delete the message after 30 seconds for security\n            setTimeout(async () => {\n                try {\n                    await message.delete();\n                } catch (error) {\n                    console.log('Could not delete recovery key message:', error.message);\n                }\n            }, 30000);\n            \n        } catch (error) {\n            console.error('Recovery key error:', error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Error')\n                .setDescription('Failed to retrieve recovery key. Please try again.')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};","size_bytes":3766},"commands/resetpassworduser.js":{"content":"const { SlashCommandBuilder, EmbedBuilder } = require('discord.js');\nconst userProfiles = require('../utils/userProfiles.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('resetpassworduser')\n        .setDescription('Reset password for any user (Bot Owner only)')\n        .addUserOption(option =>\n            option.setName('user')\n                .setDescription('User whose password to reset')\n                .setRequired(true)\n        ),\n    \n    async execute(interaction) {\n        // Check if interaction is too old\n        const interactionAge = Date.now() - interaction.createdTimestamp;\n        if (interactionAge > 10 * 60 * 1000) {\n            console.log('Interaction trop ancienne, ignor√©e');\n            return;\n        }\n        \n        // Check if user is bot owner\n        const ownerId = process.env.OWNER_ID;\n        \n        if (!ownerId || interaction.user.id !== ownerId) {\n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Access Denied')\n                .setDescription('Only the bot owner can reset user passwords.')\n                .setTimestamp();\n            \n            await interaction.reply({ embeds: [errorEmbed], ephemeral: true });\n            return;\n        }\n        \n        await interaction.deferReply({ ephemeral: true });\n        \n        try {\n            const targetUser = interaction.options.getUser('user');\n            \n            // Check if user has a profile\n            const profile = userProfiles.getUserProfile(targetUser.id);\n            if (!profile) {\n                const noProfileEmbed = new EmbedBuilder()\n                    .setColor('#ffaa00')\n                    .setTitle('‚ö†Ô∏è User Not Found')\n                    .setDescription(`User ${targetUser.username} doesn't have a casino profile yet.`)\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [noProfileEmbed] });\n                return;\n            }\n            \n            // Reset password and recovery key\n            const resetResult = userProfiles.resetUserSecurity(targetUser.id);\n            \n            if (resetResult.success) {\n                const successEmbed = new EmbedBuilder()\n                    .setColor('#00ff00')\n                    .setTitle('‚úÖ Password Reset Complete')\n                    .setDescription(`Successfully reset security settings for ${targetUser.username}`)\n                    .addFields(\n                        {\n                            name: 'üë§ Target User',\n                            value: `${targetUser.username} (${targetUser.id})`,\n                            inline: false\n                        },\n                        {\n                            name: 'üîê Actions Taken',\n                            value: '‚Ä¢ Password cleared\\n‚Ä¢ Recovery key regenerated\\n‚Ä¢ User can now set new password with `/setpassword`',\n                            inline: false\n                        },\n                        {\n                            name: 'üîë New Recovery Key',\n                            value: `\\`${resetResult.newRecoveryKey}\\``,\n                            inline: false\n                        }\n                    )\n                    .setFooter({ text: 'Owner command executed' })\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [successEmbed] });\n                \n                console.log(`üîê Owner ${interaction.user.username} reset password for user ${targetUser.username} (${targetUser.id})`);\n                \n                // Try to notify the user via DM (optional)\n                try {\n                    const dmEmbed = new EmbedBuilder()\n                        .setColor('#0099ff')\n                        .setTitle('üîê Password Reset by Admin')\n                        .setDescription('Your casino password has been reset by an administrator.')\n                        .addFields(\n                            {\n                                name: 'üìù What to do next',\n                                value: '‚Ä¢ Use `/setpassword` to set a new password\\n‚Ä¢ Your balance and profile are safe',\n                                inline: false\n                            },\n                            {\n                                name: 'üîë Your New Recovery Key',\n                                value: `\\`${resetResult.newRecoveryKey}\\`\\n*Save this somewhere safe!*`,\n                                inline: false\n                            }\n                        )\n                        .setTimestamp();\n                    \n                    await targetUser.send({ embeds: [dmEmbed] });\n                    console.log(`üì© Notification DM envoy√©e √† ${targetUser.username}`);\n                } catch (dmError) {\n                    console.log(`‚ö†Ô∏è Impossible d'envoyer DM √† ${targetUser.username}: ${dmError.message}`);\n                }\n                \n            } else {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Reset Failed')\n                    .setDescription('Failed to reset user password. Please try again.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n            }\n            \n        } catch (error) {\n            console.error('Erreur resetpassworduser:', error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Error')\n                .setDescription('An error occurred while resetting the password.')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};","size_bytes":5893},"commands/resetrecovery.js":{"content":"const { SlashCommandBuilder, EmbedBuilder } = require('discord.js');\nconst securityManager = require('../utils/securityManager.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('resetrecovery')\n        .setDescription('Reset your recovery key (requires old key + password)')\n        .addStringOption(option =>\n            option.setName('oldkey')\n                .setDescription('Your current recovery key')\n                .setRequired(true)\n        )\n        .addStringOption(option =>\n            option.setName('password')\n                .setDescription('Your account password')\n                .setRequired(true)\n        ),\n    \n    async execute(interaction) {\n        await interaction.deferReply({ ephemeral: true });\n        \n        try {\n            const oldKey = interaction.options.getString('oldkey');\n            const password = interaction.options.getString('password');\n            \n            // Check if user has a password set\n            const userSec = securityManager.getUserSecurity(interaction.user.id);\n            if (!userSec.hasPassword) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå No Password Set')\n                    .setDescription('You need to set a password first using `/setpassword`.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Try to reset recovery key\n            const newRecoveryKey = securityManager.resetRecoveryKey(interaction.user.id, oldKey, password);\n            \n            if (!newRecoveryKey) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Reset Failed')\n                    .setDescription('Invalid recovery key or password. Both must be correct to reset.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            const successEmbed = new EmbedBuilder()\n                .setColor('#00ff00')\n                .setTitle('üîÑ Recovery Key Reset')\n                .setDescription('Your recovery key has been successfully reset.')\n                .addFields(\n                    {\n                        name: 'üîë New Recovery Key',\n                        value: `\\`${newRecoveryKey}\\``,\n                        inline: false\n                    },\n                    {\n                        name: '‚ö†Ô∏è IMPORTANT',\n                        value: '**Save this new recovery key immediately!** Your old key is no longer valid.',\n                        inline: false\n                    },\n                    {\n                        name: 'üîí Security',\n                        value: 'Store your new recovery key in a safe place. You will need it to recover your account.',\n                        inline: false\n                    }\n                )\n                .setFooter({ text: 'This message will delete automatically for security' })\n                .setTimestamp();\n            \n            const message = await interaction.editReply({ embeds: [successEmbed] });\n            \n            // Auto-delete the message after 45 seconds for security\n            setTimeout(async () => {\n                try {\n                    await message.delete();\n                } catch (error) {\n                    console.log('Could not delete reset recovery message:', error.message);\n                }\n            }, 45000);\n            \n        } catch (error) {\n            console.error('Reset recovery error:', error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Error')\n                .setDescription('Failed to reset recovery key. Please try again.')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};","size_bytes":4126},"commands/setpanel.js":{"content":"const { SlashCommandBuilder, EmbedBuilder, PermissionFlagsBits } = require('discord.js');\nconst panelManager = require('../utils/panelManager.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('setpanel')\n        .setDescription('Configure a casino panel in a channel')\n        .addStringOption(option =>\n            option.setName('type')\n                .setDescription('Type of panel to create')\n                .setRequired(true)\n                .addChoices(\n                    { name: 'üé∞ Casino Main Panel', value: 'casinoPanel' },\n                    { name: 'üí∞ Add Balance Panel', value: 'addBalancePanel' }\n                )\n        )\n        .addChannelOption(option =>\n            option.setName('channel')\n                .setDescription('Channel to send the panel to')\n                .setRequired(true)\n        )\n        .addChannelOption(option =>\n            option.setName('ticket_category')\n                .setDescription('Category for creating ticket channels')\n                .setRequired(false)\n        )\n        .addRoleOption(option =>\n            option.setName('staff_role')\n                .setDescription('Staff role that can see tickets')\n                .setRequired(false)\n        )\n        .setDefaultMemberPermissions(PermissionFlagsBits.Administrator),\n    \n    async execute(interaction) {\n        // Check if interaction is too old\n        const interactionAge = Date.now() - interaction.createdTimestamp;\n        if (interactionAge > 10 * 60 * 1000) {\n            console.log('Interaction trop ancienne, ignor√©e');\n            return;\n        }\n        \n        await interaction.deferReply({ ephemeral: true });\n        \n        try {\n            const panelType = interaction.options.getString('type');\n            const channel = interaction.options.getChannel('channel');\n            const ticketCategory = interaction.options.getChannel('ticket_category');\n            const staffRole = interaction.options.getRole('staff_role');\n            \n            // Validate channel type\n            if (channel.type !== 0) { // Not a text channel\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Invalid Channel')\n                    .setDescription('Please select a text channel for the panel.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Validate category if provided\n            if (ticketCategory && ticketCategory.type !== 4) { // Not a category\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Invalid Category')\n                    .setDescription('Please select a channel category for tickets.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Save configuration\n            const success = panelManager.setPanelChannel(\n                panelType,\n                channel.id,\n                ticketCategory?.id,\n                staffRole?.id\n            );\n            \n            if (!success) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Configuration Failed')\n                    .setDescription('Failed to save panel configuration.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Create and send the panel\n            const panelEmbed = await createPanelEmbed(panelType, interaction.guild);\n            const components = await createPanelComponents(panelType);\n            \n            try {\n                const message = await channel.send({ \n                    embeds: [panelEmbed], \n                    components: components \n                });\n                \n                // Save message ID\n                panelManager.setPanelMessageId(panelType, message.id);\n                \n                const successEmbed = new EmbedBuilder()\n                    .setColor('#00ff00')\n                    .setTitle('‚úÖ Panel Created')\n                    .setDescription(`${getPanelName(panelType)} has been sent to ${channel}`)\n                    .addFields(\n                        {\n                            name: 'üìã Configuration',\n                            value: `**Channel:** ${channel}\\n**Ticket Category:** ${ticketCategory || 'Not set'}\\n**Staff Role:** ${staffRole || 'Not set'}`,\n                            inline: false\n                        }\n                    )\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [successEmbed] });\n                \n            } catch (sendError) {\n                console.error('Erreur envoi panel:', sendError);\n                \n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Send Failed')\n                    .setDescription('Failed to send panel to channel. Check bot permissions.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n            }\n            \n        } catch (error) {\n            console.error('Erreur setpanel:', error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Error')\n                .setDescription('Failed to configure panel.')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};\n\n/**\n * Create panel embed based on type\n */\nasync function createPanelEmbed(panelType, guild) {\n    const { EmbedBuilder } = require('discord.js');\n    \n    if (panelType === 'casinoPanel') {\n        return new EmbedBuilder()\n            .setColor('#f7931a')\n            .setTitle('üé∞ Welcome to the Casino!')\n            .setDescription('Click the buttons below to start your casino experience.')\n            .addFields(\n                {\n                    name: 'üí∞ Add Balance',\n                    value: 'Generate a unique Litecoin address for deposits',\n                    inline: true\n                },\n                {\n                    name: 'üë§ View Profile',\n                    value: 'Check your balance and casino statistics',\n                    inline: true\n                },\n                {\n                    name: 'üèÜ Leaderboard',\n                    value: 'See the top players and rankings',\n                    inline: true\n                },\n                {\n                    name: 'üéÆ Games Available Soon',\n                    value: '‚Ä¢ üÉè Blackjack\\n‚Ä¢ üé≤ Roulette\\n‚Ä¢ üé∞ Slots',\n                    inline: false\n                }\n            )\n            .setThumbnail('https://cryptologos.cc/logos/litecoin-ltc-logo.png')\n            .setFooter({ \n                text: `${guild.name} Casino ‚Ä¢ Powered by Litecoin`,\n                iconURL: guild.iconURL() \n            })\n            .setTimestamp();\n    }\n    \n    if (panelType === 'addBalancePanel') {\n        return new EmbedBuilder()\n            .setColor('#00ff00')\n            .setTitle('üí∞ Add Balance to Your Casino Account')\n            .setDescription('Click the button below to get a unique deposit address and start playing!')\n            .addFields(\n                {\n                    name: '‚ö° Instant Detection',\n                    value: 'Deposits are detected within 30 seconds',\n                    inline: true\n                },\n                {\n                    name: 'üîí Secure',\n                    value: 'Each deposit gets a unique address',\n                    inline: true\n                },\n                {\n                    name: 'üìà Minimum Deposit',\n                    value: '0.001 LTC',\n                    inline: true\n                }\n            )\n            .setThumbnail('https://cryptologos.cc/logos/litecoin-ltc-logo.png')\n            .setFooter({ \n                text: `${guild.name} Casino ‚Ä¢ Safe & Secure`,\n                iconURL: guild.iconURL() \n            })\n            .setTimestamp();\n    }\n}\n\n/**\n * Create panel components based on type\n */\nasync function createPanelComponents(panelType) {\n    const { ActionRowBuilder, ButtonBuilder, ButtonStyle } = require('discord.js');\n    \n    if (panelType === 'casinoPanel') {\n        return [\n            new ActionRowBuilder()\n                .addComponents(\n                    new ButtonBuilder()\n                        .setCustomId('panel_add_balance')\n                        .setLabel('üí∞ Add Balance')\n                        .setStyle(ButtonStyle.Success)\n                        .setEmoji('üí∞'),\n                    new ButtonBuilder()\n                        .setCustomId('panel_view_profile')\n                        .setLabel('üë§ View Profile')\n                        .setStyle(ButtonStyle.Primary)\n                        .setEmoji('üë§'),\n                    new ButtonBuilder()\n                        .setCustomId('panel_leaderboard')\n                        .setLabel('üèÜ Leaderboard')\n                        .setStyle(ButtonStyle.Secondary)\n                        .setEmoji('üèÜ')\n                ),\n            new ActionRowBuilder()\n                .addComponents(\n                    new ButtonBuilder()\n                        .setCustomId('panel_games_blackjack')\n                        .setLabel('üÉè Blackjack')\n                        .setStyle(ButtonStyle.Secondary)\n                        .setEmoji('üÉè')\n                        .setDisabled(true),\n                    new ButtonBuilder()\n                        .setCustomId('panel_games_roulette')\n                        .setLabel('üé≤ Roulette')\n                        .setStyle(ButtonStyle.Secondary)\n                        .setEmoji('üé≤')\n                        .setDisabled(true),\n                    new ButtonBuilder()\n                        .setCustomId('panel_games_slots')\n                        .setLabel('üé∞ Slots')\n                        .setStyle(ButtonStyle.Secondary)\n                        .setEmoji('üé∞')\n                        .setDisabled(true)\n                )\n        ];\n    }\n    \n    if (panelType === 'addBalancePanel') {\n        return [\n            new ActionRowBuilder()\n                .addComponents(\n                    new ButtonBuilder()\n                        .setCustomId('panel_add_balance')\n                        .setLabel('üí∞ Get Deposit Address')\n                        .setStyle(ButtonStyle.Success)\n                        .setEmoji('üí∞')\n                )\n        ];\n    }\n    \n    return [];\n}\n\n/**\n * Get friendly panel name\n */\nfunction getPanelName(panelType) {\n    const names = {\n        'casinoPanel': 'üé∞ Casino Main Panel',\n        'addBalancePanel': 'üí∞ Add Balance Panel'\n    };\n    return names[panelType] || panelType;\n}","size_bytes":11275},"commands/setpassword.js":{"content":"const { SlashCommandBuilder, EmbedBuilder } = require('discord.js');\nconst securityManager = require('../utils/securityManager.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('setpassword')\n        .setDescription('Set your account password (required for security features)')\n        .addStringOption(option =>\n            option.setName('password')\n                .setDescription('Your new password (minimum 6 characters)')\n                .setRequired(true)\n        ),\n    \n    async execute(interaction) {\n        await interaction.deferReply({ ephemeral: true });\n        \n        try {\n            const password = interaction.options.getString('password');\n            \n            // Validate password\n            if (password.length < 6) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Invalid Password')\n                    .setDescription('Password must be at least 6 characters long.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Check if user already has a password\n            const userSec = securityManager.getUserSecurity(interaction.user.id);\n            if (userSec.hasPassword) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Password Already Set')\n                    .setDescription('You already have a password set. Use `/changepassword` to change it.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Set password and generate recovery key\n            const recoveryKey = securityManager.setUserPassword(interaction.user.id, password);\n            \n            const successEmbed = new EmbedBuilder()\n                .setColor('#00ff00')\n                .setTitle('üîí Password Set Successfully')\n                .setDescription('Your password has been set and your recovery key has been generated.')\n                .addFields(\n                    {\n                        name: 'üîë Recovery Key',\n                        value: `\\`${recoveryKey}\\``,\n                        inline: false\n                    },\n                    {\n                        name: '‚ö†Ô∏è IMPORTANT',\n                        value: '**Save this recovery key immediately!** You need it to recover your account if you lose access. Store it in a safe place.',\n                        inline: false\n                    },\n                    {\n                        name: 'üõ°Ô∏è Security Features Unlocked',\n                        value: '‚Ä¢ View recovery key with password\\n‚Ä¢ Enable gambling sessions\\n‚Ä¢ Secure cashout protection\\n‚Ä¢ Account recovery',\n                        inline: false\n                    }\n                )\n                .setThumbnail('https://em-content.zobj.net/thumbs/120/twitter/351/locked_1f512.png')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [successEmbed] });\n            \n        } catch (error) {\n            console.error('Set password error:', error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Error')\n                .setDescription('Failed to set password. Please try again.')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};","size_bytes":3699},"commands/stopallactives.js":{"content":"const { SlashCommandBuilder, EmbedBuilder, PermissionFlagsBits } = require('discord.js');\nconst securityManager = require('../utils/securityManager.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('stopallactives')\n        .setDescription('Stop all active deposits monitoring (Admin only)')\n        .setDefaultMemberPermissions(PermissionFlagsBits.Administrator),\n    \n    async execute(interaction) {\n        // Check if interaction is too old\n        const interactionAge = Date.now() - interaction.createdTimestamp;\n        if (interactionAge > 10 * 60 * 1000) {\n            console.log('Interaction trop ancienne, ignor√©e');\n            return;\n        }\n        \n        await interaction.deferReply({ ephemeral: true });\n        \n        try {\n            // Get all active deposits before clearing\n            const activeDeposits = securityManager.getAllActiveDeposits();\n            const activeCount = activeDeposits.length;\n            \n            if (activeCount === 0) {\n                const noActiveEmbed = new EmbedBuilder()\n                    .setColor('#ffaa00')\n                    .setTitle('‚ÑπÔ∏è No Active Deposits')\n                    .setDescription('There are no active deposits to stop.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [noActiveEmbed] });\n                return;\n            }\n            \n            // Clear all active deposits\n            const success = securityManager.clearAllActiveDeposits();\n            \n            if (success) {\n                // Stop monitoring\n                const { stopSmartMonitoring } = require('../discord-bot.js');\n                stopSmartMonitoring();\n                \n                const successEmbed = new EmbedBuilder()\n                    .setColor('#00ff00')\n                    .setTitle('‚úÖ All Active Deposits Stopped')\n                    .setDescription(`Successfully stopped monitoring for **${activeCount}** active deposit(s).`)\n                    .addFields(\n                        {\n                            name: 'üõë Actions Taken',\n                            value: '‚Ä¢ All active deposits cleared\\n‚Ä¢ Smart monitoring stopped\\n‚Ä¢ Users will need to generate new addresses',\n                            inline: false\n                        },\n                        {\n                            name: '‚ö†Ô∏è Note',\n                            value: 'Users with pending deposits will need to use `/casino` again to generate new addresses.',\n                            inline: false\n                        }\n                    )\n                    .setFooter({ text: `Executed by ${interaction.user.username}` })\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [successEmbed] });\n                \n                console.log(`üõë Admin ${interaction.user.username} stopped ${activeCount} active deposits`);\n                \n            } else {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Failed to Stop')\n                    .setDescription('Failed to clear active deposits. Please try again.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n            }\n            \n        } catch (error) {\n            console.error('Erreur stopallactives:', error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Error')\n                .setDescription('An error occurred while stopping active deposits.')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};","size_bytes":3853},"commands/testgamble.js":{"content":"const { SlashCommandBuilder, EmbedBuilder } = require('discord.js');\nconst securityManager = require('../utils/securityManager.js');\nconst userProfiles = require('../utils/userProfiles.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('testgamble')\n        .setDescription('Test gambling command to simulate wagering (requires active session)')\n        .addNumberOption(option =>\n            option.setName('amount')\n                .setDescription('Amount to wager in LTC')\n                .setRequired(true)\n                .setMinValue(0.001)\n        ),\n    \n    async execute(interaction) {\n        await interaction.deferReply({ ephemeral: true });\n        \n        try {\n            const amount = interaction.options.getNumber('amount');\n            const userId = interaction.user.id;\n            \n            // Check if user has active gambling session\n            if (!securityManager.hasActiveGamblingSession(userId)) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå No Active Session')\n                    .setDescription('You need to enable a gambling session first using `/enable`.')\n                    .addFields({\n                        name: 'üîí How to Start',\n                        value: 'Use `/enable [minutes] [password]` to start a gambling session.',\n                        inline: false\n                    })\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Check user balance\n            const profile = userProfiles.getUserProfile(userId);\n            \n            if (profile.balance < amount) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Insufficient Balance')\n                    .setDescription('You don\\'t have enough balance to wager this amount.')\n                    .addFields({\n                        name: 'üí∞ Available Balance',\n                        value: `${profile.balance.toFixed(8)} LTC`,\n                        inline: true\n                    })\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Simulate gambling result (50/50 chance for testing)\n            const won = Math.random() > 0.5;\n            const resultAmount = won ? amount * 1.8 : 0; // 1.8x payout if win\n            \n            // Update balance\n            const newBalance = profile.balance - amount + resultAmount;\n            userProfiles.updateUserProfile(userId, { balance: newBalance });\n            \n            // Add wagered amount (for cashout protection)\n            securityManager.addWageredAmount(userId, amount);\n            \n            // Check new cashout status\n            const cashoutStatus = securityManager.canUserCashout(userId);\n            \n            const resultEmbed = new EmbedBuilder()\n                .setColor(won ? '#00ff00' : '#ff0000')\n                .setTitle(won ? 'üéâ You Won!' : 'üíî You Lost!')\n                .setDescription(`Test gambling result: ${won ? 'WIN' : 'LOSS'}`)\n                .addFields(\n                    {\n                        name: 'üé≤ Game Result',\n                        value: `**Wagered:** ${amount.toFixed(8)} LTC\\n**${won ? 'Won' : 'Lost'}:** ${resultAmount.toFixed(8)} LTC\\n**Net:** ${(resultAmount - amount).toFixed(8)} LTC`,\n                        inline: true\n                    },\n                    {\n                        name: 'üí∞ Balance Update',\n                        value: `**Previous:** ${profile.balance.toFixed(8)} LTC\\n**Current:** ${newBalance.toFixed(8)} LTC`,\n                        inline: true\n                    },\n                    {\n                        name: 'üìä Cashout Status',\n                        value: `**Progress:** ${cashoutStatus.wageredPercent.toFixed(1)}%\\n**Can Cashout:** ${cashoutStatus.canCashout ? '‚úÖ Yes' : '‚ùå No'}\\n**Remaining:** ${cashoutStatus.remainingToWager.toFixed(8)} LTC`,\n                        inline: false\n                    }\n                )\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [resultEmbed] });\n            \n            console.log(`üé≤ ${interaction.user.username} ${won ? 'won' : 'lost'} ${amount} LTC - Balance: ${newBalance.toFixed(8)} LTC`);\n            \n        } catch (error) {\n            console.error('Test gamble error:', error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Game Error')\n                .setDescription('An error occurred during the game. Please try again.')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};","size_bytes":5045},"deploy-commands.js":{"content":"const { REST, Routes } = require('discord.js');\nconst fs = require('fs');\nconst path = require('path');\n\n// Load environment variables\nrequire('dotenv').config();\n\nconst commands = [];\n\n// Load all command files\nconst commandsPath = path.join(__dirname, 'commands');\nconst commandFiles = fs.readdirSync(commandsPath).filter(file => file.endsWith('.js'));\n\nfor (const file of commandFiles) {\n    const filePath = path.join(commandsPath, file);\n    const command = require(filePath);\n    \n    if ('data' in command && 'execute' in command) {\n        commands.push(command.data.toJSON());\n        console.log(`‚úÖ Loaded command: ${command.data.name}`);\n    } else {\n        console.log(`‚ö†Ô∏è  Command ${file} is missing required properties`);\n    }\n}\n\n// Deploy commands\nasync function deployCommands() {\n    const token = process.env.DISCORD_TOKEN;\n    const clientId = process.env.DISCORD_CLIENT_ID;\n    const guildId = process.env.DISCORD_GUILD_ID; // Optional: for guild-specific commands\n    \n    if (!token) {\n        console.error('‚ùå DISCORD_TOKEN is required!');\n        process.exit(1);\n    }\n    \n    if (!clientId) {\n        console.error('‚ùå DISCORD_CLIENT_ID is required!');\n        process.exit(1);\n    }\n    \n    const rest = new REST().setToken(token);\n    \n    try {\n        console.log(`üîÑ Started refreshing ${commands.length} application (/) commands.`);\n        \n        let data;\n        \n        if (guildId) {\n            // Deploy to specific guild (faster for development)\n            data = await rest.put(\n                Routes.applicationGuildCommands(clientId, guildId),\n                { body: commands },\n            );\n            console.log(`‚úÖ Successfully reloaded ${data.length} guild commands for guild ${guildId}.`);\n        } else {\n            // Deploy globally (takes up to 1 hour to propagate)\n            data = await rest.put(\n                Routes.applicationCommands(clientId),\n                { body: commands },\n            );\n            console.log(`‚úÖ Successfully reloaded ${data.length} global application commands.`);\n        }\n        \n    } catch (error) {\n        console.error('‚ùå Error deploying commands:', error);\n    }\n}\n\n// Run deployment if this file is executed directly\nif (require.main === module) {\n    deployCommands();\n}\n\nmodule.exports = { deployCommands };","size_bytes":2341},"discord-bot.js":{"content":"const { Client, GatewayIntentBits, Collection, EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle, Events } = require('discord.js');\nconst fs = require('fs');\nconst path = require('path');\n\n// Import Litecoin wallet system\nconst ltcWallet = require('./litecoin-casino-bot.js');\n\n// Create Discord client\nconst client = new Client({\n    intents: [\n        GatewayIntentBits.Guilds,\n        GatewayIntentBits.GuildMessages,\n        GatewayIntentBits.MessageContent,\n        GatewayIntentBits.GuildMembers\n    ]\n});\n\n// Commands collection\nclient.commands = new Collection();\n\n// Load commands\nconst commandsPath = path.join(__dirname, 'commands');\nif (fs.existsSync(commandsPath)) {\n    const commandFiles = fs.readdirSync(commandsPath).filter(file => file.endsWith('.js'));\n    \n    for (const file of commandFiles) {\n        const filePath = path.join(commandsPath, file);\n        const command = require(filePath);\n        \n        if ('data' in command && 'execute' in command) {\n            client.commands.set(command.data.name, command);\n            console.log(`‚úÖ Commande charg√©e: ${command.data.name}`);\n        } else {\n            console.log(`‚ö†Ô∏è  Commande ${file} manque des propri√©t√©s requises`);\n        }\n    }\n}\n\n// Load events\nconst eventsPath = path.join(__dirname, 'events');\nif (fs.existsSync(eventsPath)) {\n    const eventFiles = fs.readdirSync(eventsPath).filter(file => file.endsWith('.js'));\n    \n    for (const file of eventFiles) {\n        const filePath = path.join(eventsPath, file);\n        const event = require(filePath);\n        \n        if (event.once) {\n            client.once(event.name, (...args) => event.execute(...args));\n        } else {\n            client.on(event.name, (...args) => event.execute(...args));\n        }\n        console.log(`‚úÖ √âv√©nement charg√©: ${event.name}`);\n    }\n}\n\n\n// Interaction handling\nclient.on(Events.InteractionCreate, async interaction => {\n    // Handle slash commands\n    if (interaction.isChatInputCommand()) {\n        const command = client.commands.get(interaction.commandName);\n        \n        if (!command) {\n            console.error(`‚ùå Aucune commande correspondant √† ${interaction.commandName} trouv√©e.`);\n            return;\n        }\n        \n        try {\n            await command.execute(interaction);\n        } catch (error) {\n            console.error(`‚ùå Erreur lors de l'ex√©cution de ${interaction.commandName}:`, error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Error')\n                .setDescription('There was an error while executing this command!')\n                .setTimestamp();\n            \n            if (interaction.replied || interaction.deferred) {\n                await interaction.followUp({ embeds: [errorEmbed], ephemeral: true });\n            } else {\n                await interaction.reply({ embeds: [errorEmbed], ephemeral: true });\n            }\n        }\n    }\n    \n    // Handle button interactions\n    if (interaction.isButton()) {\n        console.log(`üîò Button interaction: ${interaction.customId}`);\n        try {\n            // Add Balance button\n            if (interaction.customId === 'add_balance') {\n                await handleAddBalance(interaction);\n            }\n            // Create channel button\n            else if (interaction.customId === 'create_channel') {\n                await handleCreateChannel(interaction);\n            }\n            // Re-add balance button\n            else if (interaction.customId === 'readd_balance') {\n                await handleAddBalance(interaction);\n            }\n            // Close channel button\n            else if (interaction.customId === 'close_channel') {\n                await handleCloseChannel(interaction);\n            }\n            // Blackjack game buttons\n            else if (interaction.customId.startsWith('blackjack_')) {\n                await handleBlackjackInteraction(interaction);\n            }\n            // Roulette game buttons\n            else if (interaction.customId.startsWith('roulette_')) {\n                await handleRouletteInteraction(interaction);\n            }\n            // Casino game quick start buttons\n            else if (interaction.customId === 'casino_blackjack') {\n                console.log('üÉè Casino blackjack button clicked');\n                await handleCasinoBlackjack(interaction);\n            }\n            else if (interaction.customId === 'casino_roulette') {\n                console.log('üé∞ Casino roulette button clicked');\n                await handleCasinoRoulette(interaction);\n            }\n            // Other button handlers can be added here\n            else {\n                console.log(`‚ùì Interaction bouton inconnue: ${interaction.customId}`);\n            }\n        } catch (error) {\n            console.error('‚ùå Erreur d\\'interaction bouton:', error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Error')\n                .setDescription('There was an error processing your request!')\n                .setTimestamp();\n            \n            if (interaction.replied || interaction.deferred) {\n                await interaction.followUp({ embeds: [errorEmbed], ephemeral: true });\n            } else {\n                await interaction.reply({ embeds: [errorEmbed], ephemeral: true });\n            }\n        }\n    }\n    \n    // Handle select menu interactions\n    if (interaction.isStringSelectMenu()) {\n        try {\n            // Roulette number selection\n            if (interaction.customId === 'roulette_bet_number') {\n                await handleRouletteNumberBet(interaction);\n            }\n        } catch (error) {\n            console.error('‚ùå Erreur d\\'interaction menu:', error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Error')\n                .setDescription('There was an error processing your selection!')\n                .setTimestamp();\n            \n            if (interaction.replied || interaction.deferred) {\n                await interaction.followUp({ embeds: [errorEmbed], ephemeral: true });\n            } else {\n                await interaction.reply({ embeds: [errorEmbed], ephemeral: true });\n            }\n        }\n    }\n});\n\n// Add Balance handler\nasync function handleAddBalance(interaction) {\n    await interaction.deferReply({ ephemeral: false });\n    \n    try {\n        // Generate new LTC address for each deposit request (always new address)\n        const newAddress = ltcWallet.generateAddress();\n        \n        if (!newAddress) {\n            throw new Error('Failed to generate Litecoin address');\n        }\n        \n        // Link address to user and add to active deposits monitoring\n        const userProfiles = require('./utils/userProfiles.js');\n        const securityManager = require('./utils/securityManager.js');\n        const logManager = require('./utils/logManager.js');\n        \n        await userProfiles.linkAddressToUser(interaction.user.id, newAddress.address);\n        securityManager.addActiveDeposit(interaction.user.id, newAddress.address, 0);\n        \n        // Log address generation\n        await logManager.sendBalanceLog(client, interaction.guild.id, {\n            type: 'address_generated',\n            user: interaction.user,\n            address: newAddress.address\n        });\n        \n        // Start smart monitoring for this deposit\n        startSmartMonitoring();\n        \n        const depositEmbed = new EmbedBuilder()\n            .setColor('#f7931a')\n            .setTitle('üí∞ Add Balance - New Litecoin Address')\n            .setDescription('Send the amount you want to deposit to the **new unique address** below:')\n            .addFields(\n                { name: 'üìç Deposit Address (NEW)', value: `\\`${newAddress.address}\\``, inline: false },\n                { name: '‚è±Ô∏è Smart Detection', value: 'Monitoring active - deposits detected within 30 seconds', inline: true },\n                { name: 'üîÑ Status', value: 'Waiting for deposit...', inline: true },\n                { name: 'üîí Security', value: 'This address is unique to this deposit request', inline: false }\n            )\n            .setThumbnail('https://cryptologos.cc/logos/litecoin-ltc-logo.png')\n            .setFooter({ text: 'Casino Bot ‚Ä¢ Smart Monitoring Active' })\n            .setTimestamp();\n        \n        await interaction.editReply({ \n            embeds: [depositEmbed]\n        });\n        \n        // Send address as plain text in a separate message\n        await interaction.followUp({\n            content: `**Adresse de d√©p√¥t:** \\`${newAddress.address}\\`\\n\\n‚ö†Ô∏è **Important:**\\n‚Ä¢ Votre balance sera ajout√©e une fois le paiement confirm√© √† **100%**\\n‚Ä¢ Si apr√®s **20 minutes** votre balance n'a toujours pas √©t√© ajout√©e ou qu'il y a un souci, veuillez ping un staff`,\n            ephemeral: false\n        });\n        \n        console.log(`üîç Surveillance d√©marr√©e pour l'adresse ${newAddress.address} (utilisateur ${interaction.user.username})`);\n        \n    } catch (error) {\n        console.error('‚ùå Add balance error:', error);\n        \n        const errorEmbed = new EmbedBuilder()\n            .setColor('#ff0000')\n            .setTitle('‚ùå Error')\n            .setDescription('Failed to generate deposit address. Please try again.')\n            .setTimestamp();\n        \n        await interaction.editReply({ embeds: [errorEmbed] });\n    }\n}\n\n// Create Channel handler\nasync function handleCreateChannel(interaction) {\n    await interaction.deferReply({ ephemeral: false });\n    \n    try {\n        const guild = interaction.guild;\n        const user = interaction.user;\n        \n        // Check if user already has a channel\n        const existingChannel = guild.channels.cache.find(channel => \n            channel.name === `casino-${user.username.toLowerCase()}` && \n            channel.type === 0 // Text channel\n        );\n        \n        if (existingChannel) {\n            const alreadyExistsEmbed = new EmbedBuilder()\n                .setColor('#ffaa00')\n                .setTitle('‚ö†Ô∏è Channel Already Exists')\n                .setDescription(`You already have a private channel: ${existingChannel}`)\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [alreadyExistsEmbed] });\n            return;\n        }\n        \n        // Create private channel\n        const channel = await guild.channels.create({\n            name: `casino-${user.username.toLowerCase()}`,\n            type: 0, // Text channel\n            topic: `Private casino session for ${user.username}`,\n            permissionOverwrites: [\n                {\n                    id: guild.id,\n                    deny: ['ViewChannel', 'SendMessages']\n                },\n                {\n                    id: user.id,\n                    allow: ['ViewChannel', 'SendMessages', 'ReadMessageHistory']\n                }\n                // Add staff role permissions here if needed\n                // {\n                //     id: 'STAFF_ROLE_ID',\n                //     allow: ['ViewChannel', 'SendMessages', 'ReadMessageHistory']\n                // }\n            ]\n        });\n        \n        const successEmbed = new EmbedBuilder()\n            .setColor('#00ff00')\n            .setTitle('‚úÖ Private Channel Created')\n            .setDescription(`Your private casino channel has been created: ${channel}`)\n            .addFields(\n                { name: 'üé∞ Features Available', value: '‚Ä¢ Check balance\\n‚Ä¢ Play casino games\\n‚Ä¢ Withdraw funds\\n‚Ä¢ Get support', inline: false },\n                { name: '‚è∞ Auto-Delete', value: 'Channel will be deleted after 24 hours of inactivity', inline: false }\n            )\n            .setTimestamp();\n        \n        await interaction.editReply({ embeds: [successEmbed] });\n        \n        // Send welcome message in the new channel\n        const welcomeEmbed = new EmbedBuilder()\n            .setColor('#f7931a')\n            .setTitle('üé∞ Welcome to Your Private Casino!')\n            .setDescription(`Hello ${user}! This is your private casino session.`)\n            .addFields(\n                { name: 'üí∞ Available Commands', value: '‚Ä¢ `/profile` - View your profile\\n‚Ä¢ `/balance` - Check balance\\n‚Ä¢ `/givebal` - Transfer balance\\n‚Ä¢ `/convert-eur-usd` - Currency converter', inline: false },\n                { name: 'üéÆ Coming Soon', value: '‚Ä¢ Blackjack\\n‚Ä¢ Roulette\\n‚Ä¢ Slots', inline: true },\n                { name: 'üîß Support', value: 'Need help? Staff can access this channel.', inline: true }\n            )\n            .setThumbnail(user.displayAvatarURL())\n            .setTimestamp();\n        \n        await channel.send({ embeds: [welcomeEmbed] });\n        \n        console.log(`üè† Private channel created: ${channel.name} for ${user.username}`);\n        \n        // Auto-close channel after 20 minutes\n        setTimeout(async () => {\n            try {\n                const logManager = require('./utils/logManager.js');\n                await logManager.sendBalanceLog(client, interaction.guild.id, {\n                    type: 'channel_closed',\n                    user: interaction.user,\n                    details: 'Auto-close after 20 minutes'\n                });\n                \n                await channel.delete('Auto-close after 20 minutes');\n                console.log(`üîí Auto-closed channel ${channel.name} after 20 minutes`);\n            } catch (autoCloseError) {\n                console.error('Error auto-closing channel:', autoCloseError);\n            }\n        }, 20 * 60 * 1000); // 20 minutes\n        \n    } catch (error) {\n        console.error('‚ùå Create channel error:', error);\n        \n        const errorEmbed = new EmbedBuilder()\n            .setColor('#ff0000')\n            .setTitle('‚ùå Error')\n            .setDescription('Failed to create private channel. Please contact staff.')\n            .setTimestamp();\n        \n        await interaction.editReply({ embeds: [errorEmbed] });\n    }\n}\n\n// Close Channel handler\nasync function handleCloseChannel(interaction) {\n    await interaction.deferReply({ ephemeral: false });\n    \n    try {\n        const channel = interaction.channel;\n        \n        // Log channel closure\n        const logManager = require('./utils/logManager.js');\n        await logManager.sendBalanceLog(client, interaction.guild.id, {\n            type: 'channel_closed',\n            user: interaction.user,\n            details: 'Manually closed by user'\n        });\n        \n        const confirmEmbed = new EmbedBuilder()\n            .setColor('#ff6600')\n            .setTitle('üîí Channel Closing')\n            .setDescription('This channel will be deleted in 5 seconds...')\n            .setTimestamp();\n        \n        await interaction.editReply({ embeds: [confirmEmbed] });\n        \n        // Delete channel after 5 seconds\n        setTimeout(async () => {\n            try {\n                await channel.delete('Manually closed by user');\n                console.log(`üîí Channel ${channel.name} closed by ${interaction.user.username}`);\n            } catch (deleteError) {\n                console.error('Error deleting channel:', deleteError);\n            }\n        }, 5000);\n        \n    } catch (error) {\n        console.error('‚ùå Close channel error:', error);\n        \n        const errorEmbed = new EmbedBuilder()\n            .setColor('#ff0000')\n            .setTitle('‚ùå Error')\n            .setDescription('Unable to close the channel. Please try again.')\n            .setTimestamp();\n        \n        await interaction.editReply({ embeds: [errorEmbed] });\n    }\n}\n\n// Blackjack interaction handler\nasync function handleBlackjackInteraction(interaction) {\n    const { activeGames, calculateHandValue, dealCard, createGameEmbed, createGameButtons } = require('./commands/blackjack.js');\n    const userProfiles = require('./utils/userProfiles.js');\n    const securityManager = require('./utils/securityManager.js');\n    const logManager = require('./utils/logManager.js');\n    const { formatLTC } = require('./utils/formatters.js');\n    \n    await interaction.deferUpdate();\n    \n    const userId = interaction.user.id;\n    const game = activeGames.get(userId);\n    \n    if (!game || game.status !== 'playing') {\n        return;\n    }\n    \n    try {\n        if (interaction.customId === 'blackjack_hit') {\n            // Player hits\n            game.playerHand.push(dealCard(game));\n            game.playerValue = calculateHandValue(game.playerHand);\n            game.canDoubleDown = false;\n            \n            if (game.playerValue > 21) {\n                game.status = 'lost';\n                activeGames.delete(userId);\n                \n                // Log the game\n                await logManager.sendGamblingLog(client, interaction.guild.id, {\n                    type: 'blackjack',\n                    user: interaction.user,\n                    game: 'blackjack',\n                    bet: game.bet,\n                    result: 'lose',\n                    payout: 0,\n                    details: `Player busted with ${game.playerValue}`\n                });\n            }\n            \n        } else if (interaction.customId === 'blackjack_stand') {\n            // Player stands - dealer plays\n            while (game.dealerValue < 17) {\n                game.dealerHand.push(dealCard(game));\n                game.dealerValue = calculateHandValue(game.dealerHand);\n            }\n            \n            // Determine winner\n            let payout = 0;\n            if (game.dealerValue > 21) {\n                game.status = 'won';\n                payout = game.bet * 2;\n            } else if (game.playerValue > game.dealerValue) {\n                game.status = 'won';\n                payout = game.bet * 2;\n            } else if (game.playerValue < game.dealerValue) {\n                game.status = 'lost';\n                payout = 0;\n            } else {\n                game.status = 'push';\n                payout = game.bet; // Return bet\n            }\n            \n            // Update balance\n            if (payout > 0) {\n                const profile = userProfiles.getUserProfile(userId);\n                userProfiles.updateUserProfile(userId, { \n                    balance: profile.balance + payout \n                });\n            }\n            \n            // Log the game\n            await logManager.sendGamblingLog(client, interaction.guild.id, {\n                type: 'blackjack',\n                user: interaction.user,\n                game: 'blackjack',\n                bet: game.bet,\n                result: game.status === 'won' ? 'win' : game.status === 'lost' ? 'lose' : 'push',\n                payout: payout,\n                details: `Player: ${game.playerValue}, Dealer: ${game.dealerValue}`\n            });\n            \n            activeGames.delete(userId);\n            \n        } else if (interaction.customId === 'blackjack_double') {\n            // Player doubles down\n            const profile = userProfiles.getUserProfile(userId);\n            if (profile.balance >= game.bet) {\n                userProfiles.updateUserProfile(userId, { \n                    balance: profile.balance - game.bet \n                });\n                securityManager.addWageredAmount(userId, game.bet);\n                \n                game.bet *= 2;\n                game.playerHand.push(dealCard(game));\n                game.playerValue = calculateHandValue(game.playerHand);\n                \n                if (game.playerValue > 21) {\n                    game.status = 'lost';\n                } else {\n                    // Dealer plays\n                    while (game.dealerValue < 17) {\n                        game.dealerHand.push(dealCard(game));\n                        game.dealerValue = calculateHandValue(game.dealerHand);\n                    }\n                    \n                    // Determine winner\n                    let payout = 0;\n                    if (game.dealerValue > 21 || game.playerValue > game.dealerValue) {\n                        game.status = 'won';\n                        payout = game.bet * 2;\n                    } else if (game.playerValue < game.dealerValue) {\n                        game.status = 'lost';\n                        payout = 0;\n                    } else {\n                        game.status = 'push';\n                        payout = game.bet;\n                    }\n                    \n                    if (payout > 0) {\n                        const updatedProfile = userProfiles.getUserProfile(userId);\n                        userProfiles.updateUserProfile(userId, { \n                            balance: updatedProfile.balance + payout \n                        });\n                    }\n                }\n                \n                // Log the game\n                await logManager.sendGamblingLog(client, interaction.guild.id, {\n                    type: 'blackjack',\n                    user: interaction.user,\n                    game: 'blackjack',\n                    bet: game.bet,\n                    result: game.status === 'won' ? 'win' : game.status === 'lost' ? 'lose' : 'push',\n                    payout: payout || 0,\n                    details: `Double Down - Player: ${game.playerValue}, Dealer: ${game.dealerValue}`\n                });\n                \n                activeGames.delete(userId);\n            }\n        }\n        \n        // Update the game display\n        const gameEmbed = createGameEmbed(game, interaction.user);\n        const gameButtons = createGameButtons(game);\n        \n        await interaction.editReply({ \n            embeds: [gameEmbed],\n            components: game.status === 'playing' ? [gameButtons] : []\n        });\n        \n    } catch (error) {\n        console.error('Erreur blackjack interaction:', error);\n    }\n}\n\n// Roulette interaction handler\nasync function handleRouletteInteraction(interaction) {\n    const { activeSpins, spinWheel, calculatePayout, createResultEmbed, createBettingEmbed, createBettingComponents } = require('./commands/roulette.js');\n    const userProfiles = require('./utils/userProfiles.js');\n    const securityManager = require('./utils/securityManager.js');\n    const logManager = require('./utils/logManager.js');\n    const { formatLTC } = require('./utils/formatters.js');\n    \n    await interaction.deferUpdate();\n    \n    const userId = interaction.user.id;\n    const spin = activeSpins.get(userId);\n    \n    if (!spin || spin.status !== 'betting') {\n        return;\n    }\n    \n    try {\n        if (interaction.customId === 'roulette_spin') {\n            if (spin.bets.size === 0) {\n                return; // No bets placed\n            }\n            \n            // Deduct total bet amount\n            let totalBet = 0;\n            for (const [, amount] of spin.bets) {\n                totalBet += amount;\n            }\n            \n            const profile = userProfiles.getUserProfile(userId);\n            userProfiles.updateUserProfile(userId, { \n                balance: profile.balance - totalBet \n            });\n            securityManager.addWageredAmount(userId, totalBet);\n            \n            // Spin the wheel\n            const result = spinWheel();\n            const { totalPayout, winningBets } = calculatePayout(spin.bets, result);\n            \n            // Add winnings to balance\n            if (totalPayout > 0) {\n                const updatedProfile = userProfiles.getUserProfile(userId);\n                userProfiles.updateUserProfile(userId, { \n                    balance: updatedProfile.balance + totalPayout \n                });\n            }\n            \n            // Log the game\n            await logManager.sendGamblingLog(client, interaction.guild.id, {\n                type: 'roulette',\n                user: interaction.user,\n                game: 'roulette',\n                bet: totalBet,\n                result: totalPayout > 0 ? 'win' : 'lose',\n                payout: totalPayout,\n                details: `Number ${result}, Total Bet: ${formatLTC(totalBet)} LTC`\n            });\n            \n            // Check for big win (5x or more)\n            if (totalPayout >= totalBet * 5) {\n                await logManager.sendGamblingLog(client, interaction.guild.id, {\n                    type: 'big_win',\n                    user: interaction.user,\n                    game: 'roulette',\n                    bet: totalBet,\n                    result: 'win',\n                    payout: totalPayout\n                });\n            }\n            \n            spin.status = 'finished';\n            spin.result = result;\n            spin.totalPayout = totalPayout;\n            \n            const resultEmbed = createResultEmbed(spin, result, totalPayout, winningBets, interaction.user);\n            \n            await interaction.editReply({ \n                embeds: [resultEmbed],\n                components: []\n            });\n            \n            activeSpins.delete(userId);\n            \n        } else if (interaction.customId === 'roulette_clear') {\n            spin.bets.clear();\n            const bettingEmbed = createBettingEmbed(spin, interaction.user);\n            const bettingComponents = createBettingComponents();\n            \n            await interaction.editReply({ \n                embeds: [bettingEmbed],\n                components: bettingComponents\n            });\n            \n        } else if (interaction.customId === 'roulette_cancel') {\n            activeSpins.delete(userId);\n            \n            const cancelEmbed = new EmbedBuilder()\n                .setColor('#ff6600')\n                .setTitle('üö´ Roulette Cancelled')\n                .setDescription('Your roulette game has been cancelled.')\n                .setTimestamp();\n            \n            await interaction.editReply({ \n                embeds: [cancelEmbed],\n                components: []\n            });\n            \n        } else {\n            // Handle bet buttons\n            const betType = interaction.customId.replace('roulette_bet_', '');\n            const betAmount = spin.bet / 4; // Split bet into quarters\n            \n            if (spin.bets.has(betType)) {\n                spin.bets.set(betType, spin.bets.get(betType) + betAmount);\n            } else {\n                spin.bets.set(betType, betAmount);\n            }\n            \n            const bettingEmbed = createBettingEmbed(spin, interaction.user);\n            const bettingComponents = createBettingComponents();\n            \n            await interaction.editReply({ \n                embeds: [bettingEmbed],\n                components: bettingComponents\n            });\n        }\n        \n    } catch (error) {\n        console.error('Erreur roulette interaction:', error);\n    }\n}\n\n// Roulette number bet handler\nasync function handleRouletteNumberBet(interaction) {\n    const { activeSpins, createBettingEmbed, createBettingComponents } = require('./commands/roulette.js');\n    \n    await interaction.deferUpdate();\n    \n    const userId = interaction.user.id;\n    const spin = activeSpins.get(userId);\n    \n    if (!spin || spin.status !== 'betting') {\n        return;\n    }\n    \n    try {\n        const selectedValue = interaction.values[0];\n        const betAmount = spin.bet / 4; // Split bet into quarters\n        \n        if (spin.bets.has(selectedValue)) {\n            spin.bets.set(selectedValue, spin.bets.get(selectedValue) + betAmount);\n        } else {\n            spin.bets.set(selectedValue, betAmount);\n        }\n        \n        const bettingEmbed = createBettingEmbed(spin, interaction.user);\n        const bettingComponents = createBettingComponents();\n        \n        await interaction.editReply({ \n            embeds: [bettingEmbed],\n            components: bettingComponents\n        });\n        \n    } catch (error) {\n        console.error('Erreur roulette number bet:', error);\n    }\n}\n\n// Casino game quick start handlers\nasync function handleCasinoBlackjack(interaction) {\n    await interaction.deferUpdate();\n    \n    const quickPlayEmbed = new EmbedBuilder()\n        .setColor('#9932cc')\n        .setTitle('üÉè Quick Play Blackjack')\n        .setDescription('Ready to play Blackjack? Use the command `/blackjack <bet>` to start!')\n        .addFields(\n            {\n                name: 'üéØ How to Play',\n                value: '‚Ä¢ Beat the dealer by getting closer to 21 without going over\\n‚Ä¢ Face cards are worth 10, Aces are 1 or 11\\n‚Ä¢ You can Hit, Stand, or Double Down',\n                inline: false\n            },\n            {\n                name: 'üí∞ Example Commands',\n                value: '‚Ä¢ `/blackjack bet:0.01` - Play with 0.01 LTC\\n‚Ä¢ `/blackjack bet:0.1` - Play with 0.1 LTC',\n                inline: false\n            }\n        )\n        .setFooter({ text: 'Good luck at the tables!' })\n        .setTimestamp();\n    \n    await interaction.editReply({ embeds: [quickPlayEmbed] });\n}\n\nasync function handleCasinoRoulette(interaction) {\n    await interaction.deferUpdate();\n    \n    const quickPlayEmbed = new EmbedBuilder()\n        .setColor('#9932cc')\n        .setTitle('üé∞ Quick Play Roulette')\n        .setDescription('Ready to spin the wheel? Use the command `/roulette <bet>` to start!')\n        .addFields(\n            {\n                name: 'üéØ How to Play',\n                value: '‚Ä¢ Choose your bets: numbers (35:1), colors (1:1), even/odd (1:1)\\n‚Ä¢ The ball will land on a number from 0-36\\n‚Ä¢ Multiple bets allowed per spin',\n                inline: false\n            },\n            {\n                name: 'üí∞ Example Commands',\n                value: '‚Ä¢ `/roulette bet:0.01` - Play with 0.01 LTC\\n‚Ä¢ `/roulette bet:0.1` - Play with 0.1 LTC',\n                inline: false\n            }\n        )\n        .setFooter({ text: 'Place your bets!' })\n        .setTimestamp();\n    \n    await interaction.editReply({ embeds: [quickPlayEmbed] });\n}\n\n// Smart monitoring system\nlet monitoringInterval = null;\n\n/**\n * Start smart monitoring for active deposits\n */\nfunction startSmartMonitoring() {\n    // Don't start if already running\n    if (monitoringInterval) return;\n    \n    console.log('üîç D√©marrage de la surveillance des d√©p√¥ts...');\n    \n    // Surveillance automatique toutes les 2 minutes pour respecter les limites API gratuites\n    monitoringInterval = setInterval(async () => {\n        try {\n            const securityManager = require('./utils/securityManager.js');\n            const userProfiles = require('./utils/userProfiles.js');\n            \n            // Get all active deposits\n            const activeDeposits = securityManager.getAllActiveDeposits();\n            \n            if (activeDeposits.length === 0) {\n                console.log('‚ÑπÔ∏è  Aucun d√©p√¥t actif - arr√™t de la surveillance');\n                stopSmartMonitoring();\n                return;\n            }\n            \n            // Check for new deposits\n            const detectedDeposits = await ltcWallet.smartDepositCheck(activeDeposits);\n            \n            // Process detected deposits\n            for (const deposit of detectedDeposits) {\n                try {\n                    // Add deposit to user profile\n                    userProfiles.addDeposit(deposit.userId, deposit.amount, deposit.address);\n                    \n                    // Add to deposited amount for cashout protection\n                    securityManager.addDepositedAmount(deposit.userId, deposit.amount);\n                    \n                    // Mark deposit as completed\n                    securityManager.completeDepositRequest(deposit.userId, deposit.address);\n                    \n                    // Notify user\n                    await notifyUserOfDeposit(deposit);\n                    \n                } catch (error) {\n                    console.error('Erreur traitement d√©p√¥t:', error);\n                }\n            }\n            \n        } catch (error) {\n            console.error('Erreur surveillance intelligente:', error);\n        }\n    }, 120000); // Check every 2 minutes pour respecter les limites BlockCypher gratuit\n}\n\n/**\n * Stop smart monitoring\n */\nfunction stopSmartMonitoring() {\n    if (monitoringInterval) {\n        clearInterval(monitoringInterval);\n        monitoringInterval = null;\n        console.log('üõë Surveillance intelligente arr√™t√©e');\n    }\n}\n\n/**\n * Notify user of detected deposit\n */\nasync function notifyUserOfDeposit(deposit) {\n    try {\n        const user = await client.users.fetch(deposit.userId);\n        \n        if (user) {\n            const depositEmbed = new EmbedBuilder()\n                .setColor('#00ff00')\n                .setTitle('‚úÖ Deposit Confirmed!')\n                .setDescription('Your Litecoin deposit has been confirmed and added to your balance.')\n                .addFields(\n                    {\n                        name: 'üí∞ Deposit Amount',\n                        value: `**${deposit.amount.toFixed(8)} LTC**`,\n                        inline: true\n                    },\n                    {\n                        name: 'üìç Address',\n                        value: `\\`${deposit.address}\\``,\n                        inline: false\n                    },\n                    {\n                        name: 'üé∞ Ready to Play',\n                        value: 'Use `/casino` to start playing!\\n**Note:** You must wager 100% of deposited amount before cashout.',\n                        inline: false\n                    }\n                )\n                .setThumbnail('https://cryptologos.cc/logos/litecoin-ltc-logo.png')\n                .setTimestamp();\n            \n            // Try to send DM\n            try {\n                await user.send({ embeds: [depositEmbed] });\n                console.log(`üí∞ Utilisateur ${user.username} notifi√© du d√©p√¥t de ${deposit.amount} LTC`);\n            } catch (dmError) {\n                console.log(`Impossible d'envoyer un MP √† ${user.username}:`, dmError.message);\n            }\n        }\n    } catch (error) {\n        console.log('Impossible de notifier l\\'utilisateur du d√©p√¥t:', error.message);\n    }\n}\n\n// Export for external use\nmodule.exports = {\n    client,\n    handleAddBalance,\n    handleCreateChannel,\n    startSmartMonitoring,\n    stopSmartMonitoring\n};\n\n// Gestion d'erreurs globales pour √©viter les d√©connexions\nprocess.on('uncaughtException', (error) => {\n    console.error('‚ö†Ô∏è Erreur non g√©r√©e captur√©e:', error);\n    console.log('üîÑ Le bot continue de fonctionner...');\n});\n\nprocess.on('unhandledRejection', (reason, promise) => {\n    console.error('‚ö†Ô∏è Promesse rejet√©e non g√©r√©e:', reason);\n    console.log('üîÑ Le bot continue de fonctionner...');\n});\n\n// Gestion des erreurs Discord\nclient.on('error', (error) => {\n    console.error('‚ö†Ô∏è Erreur client Discord:', error);\n    console.log('üîÑ Tentative de reconnexion...');\n});\n\nclient.on('warn', (info) => {\n    console.warn('‚ö†Ô∏è Avertissement Discord:', info);\n});\n\nclient.on('disconnect', () => {\n    console.log('‚ö†Ô∏è Bot d√©connect√©, tentative de reconnexion...');\n});\n\nclient.on('reconnecting', () => {\n    console.log('üîÑ Reconnexion en cours...');\n});\n\n// Fonction de reconnexion automatique\nasync function startBotWithRetry() {\n    const token = process.env.DISCORD_TOKEN;\n    \n    if (!token) {\n        console.error('‚ùå DISCORD_TOKEN environment variable is required!');\n        process.exit(1);\n    }\n    \n    let retryCount = 0;\n    const maxRetries = 5;\n    \n    while (retryCount < maxRetries) {\n        try {\n            await client.login(token);\n            console.log('‚úÖ Bot connect√© avec succ√®s!');\n            break;\n        } catch (error) {\n            retryCount++;\n            console.error(`‚ùå √âchec de connexion (tentative ${retryCount}/${maxRetries}):`, error.message);\n            \n            if (retryCount < maxRetries) {\n                const delay = retryCount * 5000; // D√©lai croissant: 5s, 10s, 15s...\n                console.log(`‚è≥ Nouvelle tentative dans ${delay/1000}s...`);\n                await new Promise(resolve => setTimeout(resolve, delay));\n            } else {\n                console.error('‚ùå Impossible de se connecter apr√®s plusieurs tentatives');\n                process.exit(1);\n            }\n        }\n    }\n}\n\n// Start the bot if this file is run directly\nif (require.main === module) {\n    startBotWithRetry();\n}","size_bytes":36563},"events/interactionCreate.js":{"content":"const { Events, EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle } = require('discord.js');\n\nmodule.exports = {\n    name: Events.InteractionCreate,\n    async execute(interaction) {\n        // Handle slash commands\n        if (interaction.isChatInputCommand()) {\n            const command = interaction.client.commands.get(interaction.commandName);\n\n            if (!command) {\n                console.error(`‚ùå No command matching ${interaction.commandName} was found.`);\n                return;\n            }\n\n            try {\n                await command.execute(interaction);\n                console.log(`‚úÖ ${interaction.user.username} a utilis√© /${interaction.commandName}`);\n            } catch (error) {\n                console.error(`‚ùå Erreur lors de l'ex√©cution de ${interaction.commandName}:`, error);\n\n                try {\n                    const errorEmbed = new EmbedBuilder()\n                        .setColor('#ff0000')\n                        .setTitle('‚ùå Command Error')\n                        .setDescription('There was an error while executing this command!')\n                        .setTimestamp();\n\n                    if (interaction.replied || interaction.deferred) {\n                        await interaction.followUp({ embeds: [errorEmbed], ephemeral: true });\n                    } else {\n                        await interaction.reply({ embeds: [errorEmbed], ephemeral: true });\n                    }\n                } catch (replyError) {\n                    console.error('‚ö†Ô∏è Impossible de r√©pondre √† l\\'interaction:', replyError.message);\n                }\n            }\n        }\n\n        // Handle button interactions\n        if (interaction.isButton()) {\n            try {\n                // Check for panel interactions\n                if (interaction.customId.startsWith('panel_')) {\n                    await handlePanelInteraction(interaction);\n                } else {\n                    await handleButtonInteraction(interaction);\n                }\n            } catch (error) {\n                console.error('‚ùå Erreur d\\'interaction bouton:', error);\n\n                try {\n                    const errorEmbed = new EmbedBuilder()\n                        .setColor('#ff0000')\n                        .setTitle('‚ùå Error')\n                        .setDescription('There was an error processing your request!')\n                        .setTimestamp();\n\n                    if (interaction.replied || interaction.deferred) {\n                        await interaction.followUp({ embeds: [errorEmbed], ephemeral: true });\n                    } else {\n                        await interaction.reply({ embeds: [errorEmbed], ephemeral: true });\n                    }\n                } catch (replyError) {\n                    console.error('‚ö†Ô∏è Impossible de r√©pondre √† l\\'interaction bouton:', replyError.message);\n                }\n            }\n        }\n    },\n};\n\n/**\n * Handle button interactions\n */\nasync function handleButtonInteraction(interaction) {\n    const { customId } = interaction;\n    \n    switch (customId) {\n        case 'add_balance':\n            await handleAddBalance(interaction);\n            break;\n        case 'view_profile':\n            await handleViewProfile(interaction);\n            break;\n        case 'leaderboard':\n            await handleLeaderboard(interaction);\n            break;\n        case 'create_channel':\n            await handleCreateChannel(interaction);\n            break;\n        case 'blackjack':\n        case 'roulette':\n        case 'slots':\n            await handleGameNotAvailable(interaction);\n            break;\n        default:\n            console.log(`Interaction bouton inconnue: ${customId}`);\n    }\n}\n\n/**\n * Handle Add Balance button\n */\nasync function handleAddBalance(interaction) {\n    // Avoid duplicate calls from panel interactions\n    if (interaction.customId === 'panel_add_balance') {\n        return; // This is handled by handlePanelInteraction\n    }\n    \n    const { handleAddBalance } = require('../discord-bot.js');\n    await handleAddBalance(interaction);\n}\n\n/**\n * Handle View Profile button\n */\nasync function handleViewProfile(interaction) {\n    // Avoid duplicate calls from panel interactions\n    if (interaction.customId === 'panel_view_profile') {\n        return; // This is handled by handlePanelInteraction\n    }\n    \n    await interaction.deferReply({ ephemeral: true });\n    \n    const profileCommand = require('../commands/profile.js');\n    await profileCommand.execute(interaction);\n}\n\n/**\n * Handle Leaderboard button\n */\nasync function handleLeaderboard(interaction) {\n    await interaction.deferReply({ ephemeral: true });\n    \n    try {\n        const userProfiles = require('../utils/userProfiles.js');\n        const { formatLTC } = require('../utils/formatters.js');\n        const leaderboard = userProfiles.getLeaderboard('balance', 10);\n        \n        if (leaderboard.length === 0) {\n            const emptyEmbed = new EmbedBuilder()\n                .setColor('#ffaa00')\n                .setTitle('üèÜ Casino Leaderboard')\n                .setDescription('No players yet! Be the first to add balance.')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [emptyEmbed] });\n            return;\n        }\n        \n        let leaderboardText = '';\n        const medals = ['ü•á', 'ü•à', 'ü•â'];\n        \n        for (let i = 0; i < leaderboard.length; i++) {\n            const user = leaderboard[i];\n            const medal = i < 3 ? medals[i] : `${i + 1}.`;\n            \n            try {\n                const discordUser = await interaction.client.users.fetch(user.userId);\n                leaderboardText += `${medal} **${discordUser.username}** - ${formatLTC(user.value)} LTC\\n`;\n            } catch (error) {\n                leaderboardText += `${medal} **Unknown User** - ${formatLTC(user.value)} LTC\\n`;\n            }\n        }\n        \n        const leaderboardEmbed = new EmbedBuilder()\n            .setColor('#ffd700')\n            .setTitle('üèÜ Casino Leaderboard')\n            .setDescription('**Top Players by Balance**\\n\\n' + leaderboardText)\n            .setThumbnail('https://cryptologos.cc/logos/litecoin-ltc-logo.png')\n            .setFooter({ text: 'Rankings update in real-time' })\n            .setTimestamp();\n        \n        await interaction.editReply({ embeds: [leaderboardEmbed] });\n        \n    } catch (error) {\n        console.error('Leaderboard error:', error);\n        \n        const errorEmbed = new EmbedBuilder()\n            .setColor('#ff0000')\n            .setTitle('‚ùå Error')\n            .setDescription('Failed to load leaderboard. Please try again.')\n            .setTimestamp();\n        \n        await interaction.editReply({ embeds: [errorEmbed] });\n    }\n}\n\n/**\n * Handle Create Channel button\n */\nasync function handleCreateChannel(interaction) {\n    const { handleCreateChannel } = require('../discord-bot.js');\n    await handleCreateChannel(interaction);\n}\n\n/**\n * Handle panel interactions (creates tickets)\n */\nasync function handlePanelInteraction(interaction) {\n    // Check if interaction is too old\n    const interactionAge = Date.now() - interaction.createdTimestamp;\n    if (interactionAge > 10 * 60 * 1000) {\n        console.log('Interaction trop ancienne, ignor√©e');\n        return;\n    }\n    \n    const ticketManager = require('../utils/ticketManager.js');\n    const panelManager = require('../utils/panelManager.js');\n    \n    const { customId } = interaction;\n    \n    // Determine ticket type based on button\n    let ticketType = 'general';\n    let actionName = 'Casino';\n    \n    if (customId === 'panel_add_balance') {\n        ticketType = 'balance';\n        actionName = 'Add Balance';\n    } else if (customId === 'panel_view_profile') {\n        ticketType = 'profile';\n        actionName = 'Profile';\n    }\n    \n    await interaction.deferReply({ ephemeral: true });\n    \n    try {\n        // Get panel configuration for ticket category\n        const panelConfig = panelManager.getPanelConfig('casinoPanel');\n        const categoryId = panelConfig?.ticketCategory;\n        const staffRoleId = panelConfig?.staffRole;\n        \n        // Create ticket\n        const result = await ticketManager.createTicket(\n            interaction.guild,\n            interaction.user,\n            categoryId,\n            staffRoleId,\n            ticketType\n        );\n        \n        if (result.success) {\n            const successEmbed = new EmbedBuilder()\n                .setColor('#00ff00')\n                .setTitle('‚úÖ Private Channel Created')\n                .setDescription(`Your private ${actionName.toLowerCase()} channel has been created!`)\n                .addFields({\n                    name: 'üé´ Your Channel',\n                    value: `${result.channel}`,\n                    inline: false\n                })\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [successEmbed] });\n            \n            // Send welcome message in ticket\n            await sendTicketWelcome(result.channel, interaction.user, ticketType);\n            \n        } else if (result.error === 'existing') {\n            const existingEmbed = new EmbedBuilder()\n                .setColor('#ffaa00')\n                .setTitle('‚ö†Ô∏è Channel Already Exists')\n                .setDescription(`You already have a private ${actionName.toLowerCase()} channel!`)\n                .addFields({\n                    name: 'üé´ Your Existing Channel',\n                    value: `${result.channel}`,\n                    inline: false\n                })\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [existingEmbed] });\n            \n        } else {\n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Failed to Create Channel')\n                .setDescription('Unable to create your private channel. Please contact staff.')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n        \n    } catch (error) {\n        console.error('Erreur panel interaction:', error);\n        \n        const errorEmbed = new EmbedBuilder()\n            .setColor('#ff0000')\n            .setTitle('‚ùå Error')\n            .setDescription('An error occurred while processing your request.')\n            .setTimestamp();\n        \n        await interaction.editReply({ embeds: [errorEmbed] });\n    }\n}\n\n/**\n * Send welcome message in ticket channel\n */\nasync function sendTicketWelcome(channel, user, ticketType) {\n    try {\n        let welcomeEmbed;\n        \n        if (ticketType === 'balance') {\n            const { handleAddBalance } = require('../discord-bot.js');\n            \n            welcomeEmbed = new EmbedBuilder()\n                .setColor('#00ff00')\n                .setTitle('üí∞ Private Balance Channel')\n                .setDescription(`Welcome ${user}! This is your private channel for balance operations.`)\n                .addFields(\n                    {\n                        name: 'üìã Available Actions',\n                        value: '‚Ä¢ Click the button below to generate a deposit address\\n‚Ä¢ Check your balance with commands\\n‚Ä¢ Safe and private environment',\n                        inline: false\n                    }\n                )\n                .setThumbnail(user.displayAvatarURL())\n                .setTimestamp();\n            \n            const balanceButton = new ActionRowBuilder()\n                .addComponents(\n                    new ButtonBuilder()\n                        .setCustomId('add_balance')\n                        .setLabel('üí∞ Generate Deposit Address')\n                        .setStyle(ButtonStyle.Success)\n                        .setEmoji('üí∞')\n                );\n            \n            await channel.send({ \n                embeds: [welcomeEmbed],\n                components: [balanceButton]\n            });\n            \n        } else if (ticketType === 'profile') {\n            welcomeEmbed = new EmbedBuilder()\n                .setColor('#0099ff')\n                .setTitle('üë§ Private Profile Channel')\n                .setDescription(`Welcome ${user}! This is your private channel for profile management.`)\n                .addFields(\n                    {\n                        name: 'üìã Available Actions',\n                        value: '‚Ä¢ Use `/profile` to view your statistics\\n‚Ä¢ Use `/balance` to check your funds\\n‚Ä¢ Use `/givebal` to transfer to other users',\n                        inline: false\n                    }\n                )\n                .setThumbnail(user.displayAvatarURL())\n                .setTimestamp();\n            \n            await channel.send({ embeds: [welcomeEmbed] });\n            \n        } else {\n            welcomeEmbed = new EmbedBuilder()\n                .setColor('#f7931a')\n                .setTitle('üé∞ Private Casino Channel')\n                .setDescription(`Welcome ${user}! This is your private casino session.`)\n                .addFields(\n                    {\n                        name: 'üéÆ Available Commands',\n                        value: '‚Ä¢ `/profile` - View your profile\\n‚Ä¢ `/balance` - Check balance\\n‚Ä¢ `/casino` - Access main panel\\n‚Ä¢ `/convert-eur-usd` - Currency converter',\n                        inline: false\n                    }\n                )\n                .setThumbnail(user.displayAvatarURL())\n                .setTimestamp();\n            \n            await channel.send({ embeds: [welcomeEmbed] });\n        }\n        \n    } catch (error) {\n        console.error('Erreur envoi welcome message:', error);\n    }\n}\n\n/**\n * Handle game buttons (not yet implemented)\n */\nasync function handleGameNotAvailable(interaction) {\n    const gameNames = {\n        'blackjack': 'üÉè Blackjack',\n        'roulette': 'üé≤ Roulette',\n        'slots': 'üé∞ Slots'\n    };\n    \n    const gameName = gameNames[interaction.customId] || 'Game';\n    \n    const comingSoonEmbed = new EmbedBuilder()\n        .setColor('#ffaa00')\n        .setTitle('üöß Coming Soon!')\n        .setDescription(`${gameName} is currently under development and will be available soon!`)\n        .addFields({\n            name: 'üéÆ Available Features',\n            value: '‚Ä¢ Balance management\\n‚Ä¢ Currency conversion\\n‚Ä¢ Deposit/withdrawal system\\n‚Ä¢ User profiles',\n            inline: false\n        })\n        .setFooter({ text: 'Stay tuned for exciting casino games!' })\n        .setTimestamp();\n    \n    await interaction.reply({ embeds: [comingSoonEmbed], ephemeral: true });\n}","size_bytes":14699},"events/ready.js":{"content":"const { Events } = require('discord.js');\n\nmodule.exports = {\n    name: Events.ClientReady,\n    once: true,\n    execute(client) {\n        console.log(`üé∞ Bot Casino Discord pr√™t! Connect√© en tant que ${client.user.tag}`);\n        console.log(`üîó Connect√© √† ${client.guilds.cache.size} serveur(s)`);\n        console.log(`üë• Au service de ${client.users.cache.size} utilisateur(s)`);\n        \n        // Set bot status\n        client.user.setActivity('üé∞ Litecoin Casino | /casino', { type: 'PLAYING' });\n        \n        // Initialize smart monitoring if there are active deposits\n        checkAndStartSmartMonitoring(client);\n    },\n};\n\n/**\n * Check for active deposits and start smart monitoring if needed\n */\nfunction checkAndStartSmartMonitoring(client) {\n    const securityManager = require('../utils/securityManager.js');\n    const { startSmartMonitoring } = require('../discord-bot.js');\n    \n    // Check if there are any active deposits\n    const activeDeposits = securityManager.getAllActiveDeposits();\n    \n    if (activeDeposits.length > 0) {\n        console.log(`üîç ${activeDeposits.length} d√©p√¥t(s) actif(s) trouv√©(s) - d√©marrage de la surveillance intelligente`);\n        startSmartMonitoring();\n    } else {\n        console.log('‚ÑπÔ∏è  Aucun d√©p√¥t actif trouv√© - la surveillance d√©marrera quand n√©cessaire');\n    }\n}","size_bytes":1355},"litecoin-casino-bot.js":{"content":"const fs = require('fs');\nconst litecore = require('litecore-lib');\nconst litecoinDirect = require('./utils/litecoinDirect.js');\n\n// Configuration pour connexion directe (pas d'API key n√©cessaire)\nconst NETWORK = 'ltc'; // Litecoin mainnet\n\n// File to store generated addresses\nconst ADDRESSES_FILE = 'addresses.json';\n\n/**\n * Load saved addresses from JSON file\n * @returns {Array} List of addresses with their private keys\n */\nfunction loadAddresses() {\n    try {\n        if (fs.existsSync(ADDRESSES_FILE)) {\n            const data = fs.readFileSync(ADDRESSES_FILE, 'utf8');\n            return JSON.parse(data);\n        }\n    } catch (error) {\n        console.error('Error loading addresses:', error.message);\n    }\n    return [];\n}\n\n/**\n * Save addresses to JSON file\n * @param {Array} addresses - List of addresses to save\n */\nfunction saveAddresses(addresses) {\n    try {\n        fs.writeFileSync(ADDRESSES_FILE, JSON.stringify(addresses, null, 2));\n        console.log(`‚úÖ Addresses saved to ${ADDRESSES_FILE}`);\n    } catch (error) {\n        console.error('Error saving addresses:', error.message);\n    }\n}\n\n/**\n * Generate a new Litecoin address with its private key\n * This function uses litecore-lib to create a private key/public address pair\n * Perfect for later integration into a Discord bot with games like blackjack/roulette\n * @returns {Object} Object containing the address and private key\n */\nfunction generateAddress() {\n    try {\n        // Generate a new random private key\n        const privateKey = new litecore.PrivateKey();\n        \n        // Create the corresponding public address\n        const address = privateKey.toAddress();\n        \n        const newAddress = {\n            address: address.toString(),\n            privateKey: privateKey.toString(),\n            createdAt: new Date().toISOString(),\n            balance: 0 // Will be updated during checks\n        };\n        \n        // Load existing addresses\n        const addresses = loadAddresses();\n        \n        // Add the new address\n        addresses.push(newAddress);\n        \n        // Save\n        saveAddresses(addresses);\n        \n        console.log(`üîë New address generated: ${newAddress.address}`);\n        return newAddress;\n        \n    } catch (error) {\n        console.error('Error generating address:', error.message);\n        return null;\n    }\n}\n\n/**\n * V√©rifie le solde d'une adresse via connexion directe (sans API key)\n * @param {string} address - L'adresse Litecoin √† v√©rifier\n * @returns {Promise<number>} Le solde en LTC\n */\nasync function getAddressBalance(address) {\n    try {\n        return await litecoinDirect.getAddressBalance(address, false); // false = mainnet\n    } catch (error) {\n        console.error(`‚ùå Erreur v√©rification pour ${address.substring(0, 10)}...:`, error.message);\n        return 0;\n    }\n}\n\n/**\n * V√©rifie automatiquement les d√©p√¥ts sur toutes les adresses\n * Cette fonction peut √™tre appel√©e p√©riodiquement pour d√©tecter les nouveaux d√©p√¥ts\n * Id√©al pour un bot casino qui doit cr√©diter automatiquement les joueurs\n */\nasync function checkDeposits() {\n    const addresses = loadAddresses();\n    \n    if (addresses.length === 0) {\n        console.log('‚ÑπÔ∏è  Aucune adresse √† v√©rifier');\n        return;\n    }\n    \n    console.log(`üîç V√©rification de ${addresses.length} adresse(s)...`);\n    \n    for (let i = 0; i < addresses.length; i++) {\n        const addressData = addresses[i];\n        console.log(`üîç V√©rification ${i + 1}/${addresses.length}: ${addressData.address.substring(0, 10)}...`);\n        \n        const currentBalance = await getAddressBalance(addressData.address);\n        \n        // Check if there was a new deposit\n        if (currentBalance > addressData.balance) {\n            const deposit = currentBalance - addressData.balance;\n            console.log(`üí∞ Deposit detected: ${deposit} LTC on address ${addressData.address}`);\n            \n            // Update balance\n            addresses[i].balance = currentBalance;\n            addresses[i].lastChecked = new Date().toISOString();\n        } else if (currentBalance === addressData.balance) {\n            console.log(`‚ÑπÔ∏è  Aucun nouveau d√©p√¥t pour ${addressData.address.substring(0, 10)}...`);\n        }\n        \n        // D√©lai de 5 secondes pour √™tre respectueux envers les explorateurs publics\n        await new Promise(resolve => setTimeout(resolve, 5000));\n    }\n    \n    // Sauvegarde des soldes mis √† jour\n    saveAddresses(addresses);\n}\n\n/**\n * Obtient les UTXOs (unspent outputs) d'une adresse via connexion directe\n * N√©cessaire pour construire des transactions de retrait\n * @param {string} address - L'adresse Litecoin\n * @returns {Promise<Array>} Liste des UTXOs\n */\nasync function getAddressUTXOs(address) {\n    try {\n        return await litecoinDirect.getAddressUTXOs(address, false); // false = mainnet\n    } catch (error) {\n        console.error('Erreur UTXO:', error.message);\n        return [];\n    }\n}\n\n/**\n * Diffuse une transaction sur le r√©seau Litecoin via connexion directe\n * @param {string} txHex - Transaction s√©rialis√©e en hexad√©cimal\n * @returns {Promise<string|null>} L'ID de la transaction ou null en cas d'erreur\n */\nasync function broadcastTransaction(txHex) {\n    try {\n        return await litecoinDirect.broadcastTransaction(txHex, false); // false = mainnet\n    } catch (error) {\n        console.error('Erreur de diffusion:', error.message);\n        return null;\n    }\n}\n\n/**\n * Effectue un retrait depuis une adresse vers une destination\n * Fonction principale pour les retraits du casino - peut √™tre int√©gr√©e facilement\n * dans un bot Discord pour permettre aux joueurs de retirer leurs gains\n * @param {string} fromAddress - Adresse source (doit √™tre dans notre fichier)\n * @param {string} toAddress - Adresse de destination\n * @param {number} amount - Montant en LTC √† envoyer\n * @param {number} feeRate - Frais en satoshis par byte (d√©faut: 1000 sat/kb = 1 sat/byte)\n * @returns {Promise<string|null>} L'ID de la transaction ou null en cas d'erreur\n */\nasync function withdraw(fromAddress, toAddress, amount, feeRate = 1) {\n    try {\n        // Recherche de la cl√© priv√©e correspondante\n        const addresses = loadAddresses();\n        const addressData = addresses.find(addr => addr.address === fromAddress);\n        \n        if (!addressData) {\n            console.error(`‚ùå Adresse ${fromAddress} non trouv√©e dans notre portefeuille`);\n            return null;\n        }\n        \n        console.log(`üè¶ Pr√©paration du retrait de ${amount} LTC depuis ${fromAddress} vers ${toAddress}`);\n        \n        // R√©cup√©ration des UTXOs\n        const utxos = await getAddressUTXOs(fromAddress);\n        if (utxos.length === 0) {\n            console.error('‚ùå Aucun UTXO disponible pour cette adresse');\n            return null;\n        }\n        \n        // Conversion du montant en satoshis\n        const amountSatoshis = Math.round(amount * 100000000);\n        \n        // Cr√©ation de la transaction\n        const transaction = new litecore.Transaction();\n        \n        // Ajout des inputs (UTXOs) avec script P2PKH standard\n        let totalInputs = 0;\n        for (const utxo of utxos) {\n            // G√©n√©ration du script P2PKH standard pour l'adresse\n            const address = litecore.Address.fromString(fromAddress);\n            const script = litecore.Script.buildPublicKeyHashOut(address);\n            \n            transaction.from({\n                txId: utxo.txid,\n                outputIndex: utxo.outputIndex,\n                address: fromAddress,\n                script: script.toHex(),\n                satoshis: utxo.satoshis\n            });\n            totalInputs += utxo.satoshis;\n        }\n        \n        // Estimation des frais (taille approximative * fee rate)\n        const estimatedSize = 180 + (utxos.length * 180); // Estimation basique\n        const fees = estimatedSize * feeRate;\n        \n        // V√©rification que nous avons assez de fonds\n        if (totalInputs < amountSatoshis + fees) {\n            console.error(`‚ùå Fonds insuffisants. Disponible: ${totalInputs/100000000} LTC, Requis: ${(amountSatoshis + fees)/100000000} LTC`);\n            return null;\n        }\n        \n        // Ajout de l'output principal (destination)\n        transaction.to(toAddress, amountSatoshis);\n        \n        // Calcul et ajout du change (monnaie rendue)\n        const change = totalInputs - amountSatoshis - fees;\n        if (change > 5460) { // Dust limit pour Litecoin\n            transaction.to(fromAddress, change);\n        }\n        \n        // Signature de la transaction avec la cl√© priv√©e\n        const privateKey = new litecore.PrivateKey(addressData.privateKey);\n        transaction.sign(privateKey);\n        \n        // S√©rialisation de la transaction\n        const txHex = transaction.serialize();\n        console.log(`üì§ Transaction cr√©√©e (${txHex.length/2} bytes): ${txHex.substring(0, 64)}...`);\n        \n        // Diffusion sur le r√©seau\n        const txid = await broadcastTransaction(txHex);\n        \n        if (txid) {\n            // Mise √† jour du solde local (approximatif)\n            const addressIndex = addresses.findIndex(addr => addr.address === fromAddress);\n            if (addressIndex !== -1) {\n                addresses[addressIndex].balance -= amount;\n                addresses[addressIndex].lastWithdrawal = {\n                    amount: amount,\n                    to: toAddress,\n                    txid: txid,\n                    timestamp: new Date().toISOString()\n                };\n                saveAddresses(addresses);\n            }\n        }\n        \n        return txid;\n        \n    } catch (error) {\n        console.error('‚ùå Erreur lors du retrait:', error.message);\n        return null;\n    }\n}\n\n/**\n * Affiche le statut de toutes les adresses\n */\nfunction showWalletStatus() {\n    const addresses = loadAddresses();\n    \n    if (addresses.length === 0) {\n        console.log('üíº Portefeuille vide - aucune adresse g√©n√©r√©e');\n        return;\n    }\n    \n    console.log('\\nüíº === STATUT DU PORTEFEUILLE ===');\n    let totalBalance = 0;\n    \n    addresses.forEach((addr, index) => {\n        console.log(`\\n${index + 1}. Adresse: ${addr.address}`);\n        console.log(`   Solde: ${addr.balance} LTC`);\n        console.log(`   Cr√©√©e: ${new Date(addr.createdAt).toLocaleString()}`);\n        if (addr.lastChecked) {\n            console.log(`   Derni√®re v√©rif: ${new Date(addr.lastChecked).toLocaleString()}`);\n        }\n        totalBalance += addr.balance;\n    });\n    \n    console.log(`\\nüí∞ SOLDE TOTAL: ${totalBalance} LTC`);\n    console.log('===================================\\n');\n}\n\n/**\n * Smart deposit monitoring - only check active deposit requests\n * Called by Discord bot when needed\n */\nasync function smartDepositCheck(activeAddresses = []) {\n    if (activeAddresses.length === 0) {\n        console.log('‚ÑπÔ∏è  No active deposit requests to monitor');\n        return [];\n    }\n    \n    console.log(`üîç Smart monitoring ${activeAddresses.length} active deposit(s)...`);\n    const detectedDeposits = [];\n    \n    for (const addressData of activeAddresses) {\n        const currentBalance = await getAddressBalance(addressData.address);\n        \n        // Check if there was a new deposit\n        if (currentBalance > addressData.lastKnownBalance) {\n            const depositAmount = currentBalance - addressData.lastKnownBalance;\n            \n            detectedDeposits.push({\n                address: addressData.address,\n                amount: depositAmount,\n                newBalance: currentBalance,\n                userId: addressData.userId\n            });\n            \n            console.log(`üí∞ Deposit detected: ${depositAmount} LTC on address ${addressData.address}`);\n        }\n        \n        // Small delay to avoid API overload\n        await new Promise(resolve => setTimeout(resolve, 1000));\n    }\n    \n    return detectedDeposits;\n}\n\n/**\n * Initialize wallet system (no automatic monitoring)\n */\nfunction initializeWallet() {\n    console.log('üé∞ === LITECOIN CASINO WALLET SYSTEM ===');\n    console.log('‚úÖ Wallet system initialized - Smart monitoring mode');\n    console.log('üìã AVAILABLE FUNCTIONS:');\n    console.log('- generateAddress(): Create new address');\n    console.log('- smartDepositCheck(): Check active deposits only');\n    console.log('- withdraw(from, to, amount): Process withdrawal');\n    console.log('- showWalletStatus(): Display wallet status');\n}\n\n// Point d'entr√©e - initialise le syst√®me\nif (require.main === module) {\n    initializeWallet();\n}\n\n// Export des fonctions pour utilisation externe (bot Discord, etc.)\nmodule.exports = {\n    generateAddress,\n    checkDeposits,\n    smartDepositCheck,\n    withdraw,\n    showWalletStatus,\n    loadAddresses,\n    getAddressBalance,\n    initializeWallet\n};","size_bytes":12903},"replit.md":{"content":"# Overview\n\nThis project is a complete Litecoin casino Discord bot system built with Node.js and Discord.js v14+. The application provides full wallet management including address generation, deposit monitoring, withdrawal capabilities, and a complete Discord bot interface with slash commands, interactive panels, and real-time notifications. The system integrates BlockCypher API for fast blockchain interactions and litecore-lib for cryptographic operations. The bot features automatic deposit detection, balance management, currency conversion, user profiles, and is designed as a foundation for casino gaming features like blackjack and roulette.\n\n# User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n# System Architecture\n\n## Core Application Structure\nThe application follows a modular Discord bot architecture with separate command handlers, event listeners, and utility modules. The system includes both a standalone Litecoin wallet system and a complete Discord bot integration with slash commands, interactive panels, and real-time user notifications.\n\n## Discord Bot Architecture\n- **Main Bot File**: `discord-bot.js` - Central Discord client and interaction handling\n- **Commands System**: Modular slash commands in `/commands/` directory\n- **Events System**: Discord event handlers in `/events/` directory\n- **User Profiles**: Complete user management system with balance tracking\n- **Currency Conversion**: Real-time EUR/USD exchange rates with external APIs\n\n## Address Management System\n- **Address Generation**: Uses litecore-lib to create cryptographically secure Litecoin address pairs\n- **Data Persistence**: JSON file-based storage system for addresses and private keys\n- **Address Structure**: Each address record contains the public address, private key, creation timestamp, and balance tracking\n\n## Blockchain Integration\n- **Direct Library Integration**: Uses litecore-lib and direct blockchain explorers, eliminating API rate limits and costs\n- **Network Configuration**: Configured for Litecoin mainnet (LTC) operations\n- **Real-time Monitoring**: 2-minute interval deposit detection with Discord notifications\n- **No External API Dependencies**: Completely self-contained system without third-party API costs\n\n## File System Design\n- **Configuration Management**: Environment-based API key handling with fallback defaults\n- **Data Storage**: JSON-based persistence with error handling and data validation\n- **Modular Functions**: Clear separation between address generation, loading, and saving operations\n\n## Security Considerations\n- Private keys are generated using cryptographically secure random number generation\n- Local file storage for sensitive data (suitable for development, would need enhancement for production)\n- API key configuration system for secure third-party service integration\n\n# External Dependencies\n\n## Discord Integration\n- **discord.js**: Discord API wrapper v14+ for bot functionality, slash commands, and interactions\n- **Discord Bot Features**: Slash commands, button interactions, embed messages, and real-time notifications\n\n## Blockchain Libraries\n- **litecore-lib**: Core Litecoin cryptographic library for address generation and private key management\n- **Direct Blockchain Integration**: Direct connection to blockchain explorers without paid APIs\n- **No Rate Limits**: Unlimited transactions and monitoring without API restrictions\n\n## HTTP and Utility Libraries  \n- **axios**: HTTP client for API communications with blockchain and currency services\n- **dotenv**: Environment variable management for secure API key storage\n- **Node.js fs module**: File system operations for local data persistence\n\n## Currency APIs\n- **ExchangeRate-API**: Real-time currency conversion for EUR/USD pairs\n- **CoinGecko API**: Cryptocurrency price data for Litecoin USD/EUR prices\n\n## Development Dependencies\n- **@types/node**: TypeScript definitions for Node.js development support\n\n## Implemented Features\nThe Discord bot includes complete casino functionality with:\n\n### Core Casino System\n- User profiles with balance tracking and recovery systems\n- Complete deposit detection and monitoring with direct blockchain integration\n- Currency conversion between EUR/USD with real-time exchange rates\n- Secure password protection system with recovery keys\n- Enhanced balance display (shows \"0\" instead of \"0.00000000\" for zero balances)\n\n### Panel and Ticket Management System\n- **Panel Management**: Channel-specific casino panels that can be configured with `/setpanel`\n- **Ticket System**: Private ticket channels created when users interact with panels (similar to TicketTool)\n- **Whitelist System**: Server whitelisting with `/addwhitelist` command for panel management\n- **Smart Interactions**: Panel buttons (`panel_add_balance`, `panel_view_profile`) create private channels for users\n\n### Advanced Features\n- **Rate Limit Protection**: Smart API rate limiting with 8-second delays and proper 429 error handling\n- **French Console Logs**: Console output in French while maintaining English user interface\n- **Robust Error Handling**: Automatic reconnection system preventing bot disconnections\n- **Private Channel Management**: Automatic ticket cleanup and category organization\n- **Active Deposit Management**: `/stopallactives` command to manage monitoring\n\n### Available Slash Commands (20 total)\n- `/balance`, `/profile`, `/casino` - Core user functions\n- `/setpassword`, `/changepassword`, `/recoverykey` - Security system  \n- `/givebal`, `/cashout` - Balance management\n- `/setpanel`, `/addwhitelist` - Panel and server management\n- `/convert-eur-usd`, `/convert-usd-eur` - Currency tools\n- `/enable`, `/stopallactives` - Monitoring controls\n- `/testgamble`, `/resetrecovery` - Testing and recovery\n- `/blackjack`, `/roulette` - Casino games\n- `/setlogbal`, `/setloggamble` - Logging configuration\n\n### Casino Games System (New!)\n- **Blackjack Game**: Complete blackjack implementation with hit, stand, and double down mechanics\n- **Roulette Game**: Full European roulette with number bets (35:1), color bets (1:1), and even/odd bets (1:1)\n- **Game State Management**: Active games tracking with 2-minute auto-timeout\n- **Interactive Controls**: Button-based gameplay with real-time updates\n- **Comprehensive Logging**: All game results logged to configured channels\n\n### Enhanced Deposit System\n- **Always New Addresses**: Each deposit request generates a completely new address\n- **Enhanced Channel Management**: Private channels with auto-close after 20 minutes\n- **Non-Ephemeral Messages**: Deposit addresses sent as normal messages for easy copying\n- **Staff Ping Instructions**: Clear 20-minute timeout warnings with staff ping guidance\n- **Advanced Logging**: Comprehensive logging system for all deposit and gambling activities\n\n### Logging System (New!)\n- **Balance Log Channel**: Configure with `/setlogbal` for deposit confirmations and address generations\n- **Gambling Log Channel**: Configure with `/setloggamble` for game results and big wins\n- **Automated Big Win Detection**: Special notifications for wins 5x or larger\n- **Channel Auto-Management**: Automatic ticket cleanup and category organization\n\nThe system is now production-ready with complete casino functionality including blackjack and roulette games, enhanced user experience, and comprehensive logging systems.","size_bytes":7377},"utils/currencyConverter.js":{"content":"const axios = require('axios');\n\n// Free currency conversion API (you can change this to your preferred service)\nconst API_BASE_URL = 'https://api.exchangerate-api.com/v4/latest';\n\n/**\n * Get exchange rate between two currencies\n * @param {string} from - Source currency (e.g., 'EUR')\n * @param {string} to - Target currency (e.g., 'USD')\n * @returns {Promise<number>} Exchange rate\n */\nasync function getExchangeRate(from, to) {\n    try {\n        const response = await axios.get(`${API_BASE_URL}/${from}`, {\n            timeout: 5000\n        });\n        \n        if (response.data && response.data.rates && response.data.rates[to]) {\n            return response.data.rates[to];\n        } else {\n            throw new Error(`Exchange rate not found for ${from} to ${to}`);\n        }\n    } catch (error) {\n        console.error('Currency API error:', error.message);\n        throw new Error('Failed to fetch exchange rate. Please try again later.');\n    }\n}\n\n/**\n * Convert amount from one currency to another\n * @param {number} amount - Amount to convert\n * @param {string} from - Source currency\n * @param {string} to - Target currency\n * @returns {Promise<Object>} Conversion result\n */\nasync function convertCurrency(amount, from, to) {\n    if (amount <= 0) {\n        throw new Error('Amount must be greater than 0');\n    }\n    \n    const rate = await getExchangeRate(from, to);\n    const convertedAmount = amount * rate;\n    \n    return {\n        originalAmount: amount,\n        convertedAmount: parseFloat(convertedAmount.toFixed(2)),\n        fromCurrency: from.toUpperCase(),\n        toCurrency: to.toUpperCase(),\n        exchangeRate: rate,\n        timestamp: new Date().toISOString()\n    };\n}\n\n/**\n * Get multiple currency rates for display\n * @param {string} baseCurrency - Base currency (e.g., 'USD')\n * @returns {Promise<Object>} Multiple exchange rates\n */\nasync function getMultipleRates(baseCurrency = 'USD') {\n    try {\n        const response = await axios.get(`${API_BASE_URL}/${baseCurrency}`, {\n            timeout: 5000\n        });\n        \n        if (response.data && response.data.rates) {\n            return {\n                base: baseCurrency.toUpperCase(),\n                rates: response.data.rates,\n                lastUpdated: response.data.date || new Date().toISOString().split('T')[0]\n            };\n        } else {\n            throw new Error('Failed to fetch exchange rates');\n        }\n    } catch (error) {\n        console.error('Currency API error:', error.message);\n        throw new Error('Failed to fetch exchange rates. Please try again later.');\n    }\n}\n\n/**\n * Format currency amount for display\n * @param {number} amount - Amount to format\n * @param {string} currency - Currency code\n * @returns {string} Formatted currency string\n */\nfunction formatCurrency(amount, currency) {\n    const symbols = {\n        'USD': '$',\n        'EUR': '‚Ç¨',\n        'GBP': '¬£',\n        'JPY': '¬•',\n        'BTC': '‚Çø',\n        'LTC': '≈Å'\n    };\n    \n    const symbol = symbols[currency.toUpperCase()] || currency.toUpperCase();\n    \n    if (currency.toUpperCase() === 'JPY') {\n        return `${symbol}${Math.round(amount).toLocaleString()}`;\n    }\n    \n    return `${symbol}${amount.toLocaleString('en-US', { \n        minimumFractionDigits: 2, \n        maximumFractionDigits: 2 \n    })}`;\n}\n\n/**\n * Get current Litecoin price in specified currency\n * @param {string} currency - Target currency (default: USD)\n * @returns {Promise<Object>} LTC price data\n */\nasync function getLitecoinPrice(currency = 'USD') {\n    try {\n        // Using CoinGecko API for crypto prices (free tier)\n        const response = await axios.get(`https://api.coingecko.com/api/v3/simple/price?ids=litecoin&vs_currencies=${currency.toLowerCase()}`, {\n            timeout: 5000\n        });\n        \n        if (response.data && response.data.litecoin) {\n            const price = response.data.litecoin[currency.toLowerCase()];\n            return {\n                price: price,\n                currency: currency.toUpperCase(),\n                symbol: 'LTC',\n                timestamp: new Date().toISOString()\n            };\n        } else {\n            throw new Error('Litecoin price not found');\n        }\n    } catch (error) {\n        console.error('Crypto price API error:', error.message);\n        throw new Error('Failed to fetch Litecoin price. Please try again later.');\n    }\n}\n\nmodule.exports = {\n    getExchangeRate,\n    convertCurrency,\n    getMultipleRates,\n    formatCurrency,\n    getLitecoinPrice\n};","size_bytes":4527},"utils/formatters.js":{"content":"/**\n * Utilities for formatting numbers and currencies\n */\n\n/**\n * Format LTC amount to remove unnecessary trailing zeros\n * @param {number} amount - LTC amount\n * @returns {string} - Formatted LTC string\n */\nfunction formatLTC(amount) {\n    if (amount === 0) {\n        return '0';\n    }\n    \n    // Convert to fixed 8 decimal places first\n    const fixed = amount.toFixed(8);\n    \n    // Remove trailing zeros and unnecessary decimal point\n    const formatted = parseFloat(fixed).toString();\n    \n    // If the number is very small, show scientific notation\n    if (amount < 0.00001 && amount > 0) {\n        return amount.toExponential(3);\n    }\n    \n    return formatted;\n}\n\n/**\n * Format USD amount with 2 decimal places\n * @param {number} amount - USD amount\n * @returns {string} - Formatted USD string\n */\nfunction formatUSD(amount) {\n    return amount.toFixed(2);\n}\n\n/**\n * Format percentage with 1 decimal place\n * @param {number} percentage - Percentage value\n * @returns {string} - Formatted percentage string\n */\nfunction formatPercentage(percentage) {\n    return percentage.toFixed(1);\n}\n\nmodule.exports = {\n    formatLTC,\n    formatUSD,\n    formatPercentage\n};","size_bytes":1172},"utils/litecoinDirect.js":{"content":"/**\n * Litecoin Direct Connection - No API Keys Required\n * Uses public blockchain explorers and direct libraries\n */\n\nconst axios = require('axios');\nconst bitcoin = require('bitcoinjs-lib');\n\n// Public Litecoin explorer APIs (no API key required)\nconst EXPLORERS = {\n    mainnet: {\n        base: 'https://litecoinspace.org/api',\n        fallback: 'https://insight.litecore.io/api'\n    },\n    testnet: {\n        base: 'https://litecoinspace.org/testnet/api',\n        fallback: 'https://testnet.litecore.io/api'\n    }\n};\n\n// Network configuration\nconst NETWORK = bitcoin.networks.bitcoin; // Litecoin uses Bitcoin network params\n\n/**\n * Get address balance using public explorer\n * @param {string} address - Litecoin address\n * @param {boolean} testnet - Use testnet (default: false)\n * @returns {Promise<number>} Balance in LTC\n */\nasync function getAddressBalance(address, testnet = false) {\n    const explorer = testnet ? EXPLORERS.testnet : EXPLORERS.mainnet;\n    \n    try {\n        // Try primary explorer\n        const response = await axios.get(`${explorer.base}/address/${address}`, {\n            timeout: 10000\n        });\n        \n        if (response.data && typeof response.data.chain_stats !== 'undefined') {\n            // Litecoin Space format\n            const confirmedBalance = response.data.chain_stats.funded_txo_sum || 0;\n            const spentBalance = response.data.chain_stats.spent_txo_sum || 0;\n            const balance = (confirmedBalance - spentBalance) / 100000000; // Convert satoshis to LTC\n            \n            if (balance > 0) {\n                console.log(`‚úÖ ${address.substring(0, 10)}...: ${balance} LTC`);\n            }\n            return balance;\n        }\n        \n        return 0;\n        \n    } catch (error) {\n        console.log(`‚ö†Ô∏è Erreur explorer principal pour ${address.substring(0, 10)}...: ${error.message}`);\n        \n        // Try fallback explorer\n        try {\n            const fallbackResponse = await axios.get(`${explorer.fallback}/addr/${address}`, {\n                timeout: 10000\n            });\n            \n            if (fallbackResponse.data && typeof fallbackResponse.data.balance !== 'undefined') {\n                // Insight API format\n                const balance = parseFloat(fallbackResponse.data.balance);\n                \n                if (balance > 0) {\n                    console.log(`‚úÖ ${address.substring(0, 10)}... (fallback): ${balance} LTC`);\n                }\n                return balance;\n            }\n            \n        } catch (fallbackError) {\n            console.log(`‚ö†Ô∏è Fallback √©galement √©chou√© pour ${address.substring(0, 10)}...: ${fallbackError.message}`);\n        }\n        \n        return 0;\n    }\n}\n\n/**\n * Get UTXO list for address\n * @param {string} address - Litecoin address\n * @param {boolean} testnet - Use testnet (default: false)\n * @returns {Promise<Array>} Array of UTXOs\n */\nasync function getAddressUTXOs(address, testnet = false) {\n    const explorer = testnet ? EXPLORERS.testnet : EXPLORERS.mainnet;\n    \n    try {\n        // Get UTXOs from Litecoin Space\n        const response = await axios.get(`${explorer.base}/address/${address}/utxo`, {\n            timeout: 10000\n        });\n        \n        if (response.data && Array.isArray(response.data)) {\n            return response.data.map(utxo => ({\n                txid: utxo.txid,\n                outputIndex: utxo.vout,\n                script: utxo.scriptpubkey || '',\n                satoshis: utxo.value\n            }));\n        }\n        \n        return [];\n        \n    } catch (error) {\n        console.error(`Erreur UTXO pour ${address}:`, error.message);\n        return [];\n    }\n}\n\n/**\n * Get transaction details\n * @param {string} txid - Transaction ID\n * @param {boolean} testnet - Use testnet (default: false)\n * @returns {Promise<Object|null>} Transaction details\n */\nasync function getTransaction(txid, testnet = false) {\n    const explorer = testnet ? EXPLORERS.testnet : EXPLORERS.mainnet;\n    \n    try {\n        const response = await axios.get(`${explorer.base}/tx/${txid}`, {\n            timeout: 10000\n        });\n        \n        return response.data;\n        \n    } catch (error) {\n        console.error(`Erreur transaction ${txid}:`, error.message);\n        return null;\n    }\n}\n\n/**\n * Broadcast transaction to network\n * @param {string} txHex - Raw transaction hex\n * @param {boolean} testnet - Use testnet (default: false)\n * @returns {Promise<string|null>} Transaction ID if successful\n */\nasync function broadcastTransaction(txHex, testnet = false) {\n    const explorer = testnet ? EXPLORERS.testnet : EXPLORERS.mainnet;\n    \n    try {\n        const response = await axios.post(`${explorer.base}/tx`, txHex, {\n            headers: { 'Content-Type': 'text/plain' },\n            timeout: 15000\n        });\n        \n        if (typeof response.data === 'string') {\n            console.log(`‚úÖ Transaction diffus√©e avec succ√®s: ${response.data}`);\n            return response.data; // Transaction ID\n        }\n        \n        return null;\n        \n    } catch (error) {\n        console.error('Erreur diffusion transaction:', error.message);\n        return null;\n    }\n}\n\n/**\n * Check for new transactions on an address\n * @param {string} address - Litecoin address\n * @param {number} lastCheckedTimestamp - Last check timestamp\n * @param {boolean} testnet - Use testnet (default: false)\n * @returns {Promise<Array>} Array of new transactions\n */\nasync function getNewTransactions(address, lastCheckedTimestamp, testnet = false) {\n    const explorer = testnet ? EXPLORERS.testnet : EXPLORERS.mainnet;\n    \n    try {\n        const response = await axios.get(`${explorer.base}/address/${address}/txs`, {\n            timeout: 10000\n        });\n        \n        if (response.data && Array.isArray(response.data)) {\n            // Filter transactions newer than last check\n            const newTxs = response.data.filter(tx => {\n                const txTimestamp = tx.status?.block_time ? tx.status.block_time * 1000 : Date.now();\n                return txTimestamp > lastCheckedTimestamp;\n            });\n            \n            return newTxs;\n        }\n        \n        return [];\n        \n    } catch (error) {\n        console.error(`Erreur nouvelles transactions pour ${address}:`, error.message);\n        return [];\n    }\n}\n\n/**\n * Check multiple addresses efficiently\n * @param {Array<string>} addresses - Array of addresses to check\n * @param {boolean} testnet - Use testnet (default: false)\n * @returns {Promise<Object>} Object with address -> balance mapping\n */\nasync function checkMultipleAddresses(addresses, testnet = false) {\n    const results = {};\n    \n    // Process addresses with delay to avoid rate limiting\n    for (let i = 0; i < addresses.length; i++) {\n        const address = addresses[i];\n        \n        try {\n            results[address] = await getAddressBalance(address, testnet);\n        } catch (error) {\n            console.error(`Erreur pour ${address}:`, error.message);\n            results[address] = 0;\n        }\n        \n        // Small delay between requests to be respectful to public APIs\n        if (i < addresses.length - 1) {\n            await new Promise(resolve => setTimeout(resolve, 1000)); // 1 second delay\n        }\n    }\n    \n    return results;\n}\n\n/**\n * Health check for explorer APIs\n * @param {boolean} testnet - Use testnet (default: false)\n * @returns {Promise<boolean>} True if APIs are responsive\n */\nasync function healthCheck(testnet = false) {\n    const explorer = testnet ? EXPLORERS.testnet : EXPLORERS.mainnet;\n    \n    try {\n        // Test with a known address (Litecoin Foundation donation address)\n        const testAddress = testnet ? 'mkYY3QRCJKJHZczVz6mJ6ztNKYZrn4s7hS' : 'LTC1QH7KYTQZ9ZXQX3Y8ZGX7ZXQX3Y8ZGX7ZXQX3Y8ZGX7Z';\n        \n        const response = await axios.get(`${explorer.base}/address/${testAddress}`, {\n            timeout: 5000\n        });\n        \n        return response.status === 200;\n        \n    } catch (error) {\n        console.error('Health check failed:', error.message);\n        return false;\n    }\n}\n\nmodule.exports = {\n    getAddressBalance,\n    getAddressUTXOs,\n    getTransaction,\n    broadcastTransaction,\n    getNewTransactions,\n    checkMultipleAddresses,\n    healthCheck,\n    NETWORK\n};","size_bytes":8312},"utils/panelManager.js":{"content":"/**\n * Panel Manager for Casino Bot\n * Manages channel configurations and panel systems\n */\n\nconst fs = require('fs');\n\nconst CONFIG_FILE = './data/panel_config.json';\n\n/**\n * Get default configuration\n */\nfunction getDefaultConfig() {\n    return {\n        panels: {\n            casinoPanel: {\n                channelId: null,\n                messageId: null,\n                ticketCategory: null,\n                staffRole: null\n            },\n            addBalancePanel: {\n                channelId: null,\n                messageId: null,\n                ticketCategory: null,\n                staffRole: null\n            }\n        },\n        whitelist: {\n            serverIds: [],\n            adminRoles: []\n        }\n    };\n}\n\n/**\n * Load panel configuration\n */\nfunction loadConfig() {\n    try {\n        if (!fs.existsSync('./data')) {\n            fs.mkdirSync('./data', { recursive: true });\n        }\n        \n        if (fs.existsSync(CONFIG_FILE)) {\n            const data = fs.readFileSync(CONFIG_FILE, 'utf8');\n            return JSON.parse(data);\n        }\n    } catch (error) {\n        console.error('Erreur lors du chargement de la config des panels:', error);\n    }\n    \n    return getDefaultConfig();\n}\n\n/**\n * Save panel configuration\n */\nfunction saveConfig(config) {\n    try {\n        if (!fs.existsSync('./data')) {\n            fs.mkdirSync('./data', { recursive: true });\n        }\n        \n        fs.writeFileSync(CONFIG_FILE, JSON.stringify(config, null, 2));\n        console.log('‚úÖ Configuration des panels sauvegard√©e');\n        return true;\n    } catch (error) {\n        console.error('Erreur lors de la sauvegarde config panels:', error);\n        return false;\n    }\n}\n\n/**\n * Set channel for a specific panel type\n */\nfunction setPanelChannel(panelType, channelId, categoryId = null, staffRole = null) {\n    const config = loadConfig();\n    \n    if (!config.panels[panelType]) {\n        config.panels[panelType] = {\n            channelId: null,\n            messageId: null,\n            ticketCategory: null,\n            staffRole: null\n        };\n    }\n    \n    config.panels[panelType].channelId = channelId;\n    if (categoryId) config.panels[panelType].ticketCategory = categoryId;\n    if (staffRole) config.panels[panelType].staffRole = staffRole;\n    \n    return saveConfig(config);\n}\n\n/**\n * Get panel configuration for a specific type\n */\nfunction getPanelConfig(panelType) {\n    const config = loadConfig();\n    return config.panels[panelType] || null;\n}\n\n/**\n * Check if user/server is whitelisted for panel management\n */\nfunction isWhitelisted(serverId, userId, userRoles) {\n    const config = loadConfig();\n    \n    // Check server whitelist\n    if (!config.whitelist.serverIds.includes(serverId)) {\n        return false;\n    }\n    \n    // Check admin roles\n    if (config.whitelist.adminRoles.length > 0) {\n        const hasAdminRole = config.whitelist.adminRoles.some(roleId => \n            userRoles.includes(roleId)\n        );\n        return hasAdminRole;\n    }\n    \n    return true; // If no admin roles defined, allow all users in whitelisted servers\n}\n\n/**\n * Add server to whitelist\n */\nfunction addToWhitelist(serverId, adminRoleId = null) {\n    const config = loadConfig();\n    \n    if (!config.whitelist.serverIds.includes(serverId)) {\n        config.whitelist.serverIds.push(serverId);\n    }\n    \n    if (adminRoleId && !config.whitelist.adminRoles.includes(adminRoleId)) {\n        config.whitelist.adminRoles.push(adminRoleId);\n    }\n    \n    return saveConfig(config);\n}\n\n/**\n * Remove server from whitelist\n */\nfunction removeFromWhitelist(serverId) {\n    const config = loadConfig();\n    \n    config.whitelist.serverIds = config.whitelist.serverIds.filter(id => id !== serverId);\n    \n    return saveConfig(config);\n}\n\n/**\n * Set message ID for panel (after sending)\n */\nfunction setPanelMessageId(panelType, messageId) {\n    const config = loadConfig();\n    \n    if (config.panels[panelType]) {\n        config.panels[panelType].messageId = messageId;\n        return saveConfig(config);\n    }\n    \n    return false;\n}\n\n/**\n * Get all panel configurations\n */\nfunction getAllPanels() {\n    const config = loadConfig();\n    return config.panels;\n}\n\nmodule.exports = {\n    loadConfig,\n    saveConfig,\n    setPanelChannel,\n    getPanelConfig,\n    isWhitelisted,\n    addToWhitelist,\n    removeFromWhitelist,\n    setPanelMessageId,\n    getAllPanels\n};","size_bytes":4405},"utils/securityManager.js":{"content":"const fs = require('fs');\nconst path = require('path');\nconst crypto = require('crypto');\n\nconst SECURITY_FILE = path.join(__dirname, '../data/user_security.json');\nconst ACTIVE_DEPOSITS_FILE = path.join(__dirname, '../data/active_deposits.json');\nconst GAMBLING_SESSIONS_FILE = path.join(__dirname, '../data/gambling_sessions.json');\n\n// Ensure data directory exists\nconst dataDir = path.join(__dirname, '../data');\nif (!fs.existsSync(dataDir)) {\n    fs.mkdirSync(dataDir, { recursive: true });\n}\n\n/**\n * Load user security data\n * @returns {Object} Security data\n */\nfunction loadSecurityData() {\n    try {\n        if (fs.existsSync(SECURITY_FILE)) {\n            const data = fs.readFileSync(SECURITY_FILE, 'utf8');\n            return JSON.parse(data);\n        }\n    } catch (error) {\n        console.error('Error loading security data:', error.message);\n    }\n    return {};\n}\n\n/**\n * Save user security data\n * @param {Object} data - Security data to save\n */\nfunction saveSecurityData(data) {\n    try {\n        fs.writeFileSync(SECURITY_FILE, JSON.stringify(data, null, 2));\n        console.log('‚úÖ Security data saved');\n    } catch (error) {\n        console.error('Error saving security data:', error.message);\n    }\n}\n\n/**\n * Load active deposits\n * @returns {Object} Active deposits data\n */\nfunction loadActiveDeposits() {\n    try {\n        if (fs.existsSync(ACTIVE_DEPOSITS_FILE)) {\n            const data = fs.readFileSync(ACTIVE_DEPOSITS_FILE, 'utf8');\n            return JSON.parse(data);\n        }\n    } catch (error) {\n        console.error('Error loading active deposits:', error.message);\n    }\n    return {};\n}\n\n/**\n * Save active deposits\n * @param {Object} data - Active deposits data to save\n */\nfunction saveActiveDeposits(data) {\n    try {\n        fs.writeFileSync(ACTIVE_DEPOSITS_FILE, JSON.stringify(data, null, 2));\n        console.log('‚úÖ Active deposits saved');\n    } catch (error) {\n        console.error('Error saving active deposits:', error.message);\n    }\n}\n\n/**\n * Load gambling sessions\n * @returns {Object} Gambling sessions data\n */\nfunction loadGamblingSessions() {\n    try {\n        if (fs.existsSync(GAMBLING_SESSIONS_FILE)) {\n            const data = fs.readFileSync(GAMBLING_SESSIONS_FILE, 'utf8');\n            return JSON.parse(data);\n        }\n    } catch (error) {\n        console.error('Error loading gambling sessions:', error.message);\n    }\n    return {};\n}\n\n/**\n * Save gambling sessions\n * @param {Object} data - Gambling sessions data to save\n */\nfunction saveGamblingSessions(data) {\n    try {\n        fs.writeFileSync(GAMBLING_SESSIONS_FILE, JSON.stringify(data, null, 2));\n        console.log('‚úÖ Gambling sessions saved');\n    } catch (error) {\n        console.error('Error saving gambling sessions:', error.message);\n    }\n}\n\n/**\n * Generate secure recovery key\n * @returns {string} Recovery key\n */\nfunction generateRecoveryKey() {\n    return crypto.randomBytes(16).toString('hex').toUpperCase();\n}\n\n/**\n * Hash password securely\n * @param {string} password - Plain text password\n * @returns {string} Hashed password\n */\nfunction hashPassword(password) {\n    const salt = crypto.randomBytes(16).toString('hex');\n    const hash = crypto.pbkdf2Sync(password, salt, 10000, 64, 'sha512').toString('hex');\n    return `${salt}:${hash}`;\n}\n\n/**\n * Verify password\n * @param {string} password - Plain text password\n * @param {string} hashedPassword - Stored hashed password\n * @returns {boolean} True if password matches\n */\nfunction verifyPassword(password, hashedPassword) {\n    try {\n        const [salt, hash] = hashedPassword.split(':');\n        const verifyHash = crypto.pbkdf2Sync(password, salt, 10000, 64, 'sha512').toString('hex');\n        return hash === verifyHash;\n    } catch (error) {\n        return false;\n    }\n}\n\n/**\n * Get or create user security profile\n * @param {string} userId - Discord user ID\n * @returns {Object} Security profile\n */\nfunction getUserSecurity(userId) {\n    const security = loadSecurityData();\n    \n    if (!security[userId]) {\n        security[userId] = {\n            userId: userId,\n            hasPassword: false,\n            passwordHash: null,\n            recoveryKey: null,\n            depositRequests: [],\n            lastGamblingSession: null,\n            wageredAmount: 0,\n            depositedAmount: 0,\n            canCashout: true,\n            createdAt: new Date().toISOString()\n        };\n        saveSecurityData(security);\n    }\n    \n    return security[userId];\n}\n\n/**\n * Set user password and generate recovery key\n * @param {string} userId - Discord user ID\n * @param {string} password - New password\n * @returns {string} Recovery key\n */\nfunction setUserPassword(userId, password) {\n    const security = loadSecurityData();\n    const userSec = getUserSecurity(userId);\n    \n    const recoveryKey = generateRecoveryKey();\n    \n    userSec.hasPassword = true;\n    userSec.passwordHash = hashPassword(password);\n    userSec.recoveryKey = recoveryKey;\n    \n    security[userId] = userSec;\n    saveSecurityData(security);\n    \n    return recoveryKey;\n}\n\n/**\n * Change user password\n * @param {string} userId - Discord user ID\n * @param {string} oldPassword - Current password\n * @param {string} newPassword - New password\n * @returns {boolean} Success\n */\nfunction changeUserPassword(userId, oldPassword, newPassword) {\n    const security = loadSecurityData();\n    const userSec = getUserSecurity(userId);\n    \n    if (!userSec.hasPassword || !verifyPassword(oldPassword, userSec.passwordHash)) {\n        return false;\n    }\n    \n    userSec.passwordHash = hashPassword(newPassword);\n    security[userId] = userSec;\n    saveSecurityData(security);\n    \n    return true;\n}\n\n/**\n * Verify user password\n * @param {string} userId - Discord user ID\n * @param {string} password - Password to verify\n * @returns {boolean} True if password is correct\n */\nfunction verifyUserPassword(userId, password) {\n    const userSec = getUserSecurity(userId);\n    \n    if (!userSec.hasPassword) {\n        return false;\n    }\n    \n    return verifyPassword(password, userSec.passwordHash);\n}\n\n/**\n * Reset recovery key with old key + password\n * @param {string} userId - Discord user ID\n * @param {string} oldRecoveryKey - Old recovery key\n * @param {string} password - Current password\n * @returns {string|null} New recovery key or null if failed\n */\nfunction resetRecoveryKey(userId, oldRecoveryKey, password) {\n    const security = loadSecurityData();\n    const userSec = getUserSecurity(userId);\n    \n    if (!userSec.hasPassword || \n        userSec.recoveryKey !== oldRecoveryKey.toUpperCase() ||\n        !verifyPassword(password, userSec.passwordHash)) {\n        return null;\n    }\n    \n    const newRecoveryKey = generateRecoveryKey();\n    userSec.recoveryKey = newRecoveryKey;\n    \n    security[userId] = userSec;\n    saveSecurityData(security);\n    \n    return newRecoveryKey;\n}\n\n/**\n * Reset user password and recovery key (Admin function)\n * @param {string} userId - Discord user ID  \n * @param {string} newRecoveryKey - New recovery key to set\n * @returns {Object} Result with success status\n */\nfunction resetPassword(userId, newRecoveryKey) {\n    try {\n        const security = loadSecurityData();\n        const userSec = getUserSecurity(userId);\n        \n        // Reset password to null (user will need to set new one)\n        userSec.hasPassword = false;\n        userSec.passwordHash = null;\n        userSec.recoveryKey = newRecoveryKey;\n        \n        security[userId] = userSec;\n        saveSecurityData(security);\n        \n        console.log(`üîê Admin reset password for user ${userId}`);\n        return { success: true };\n        \n    } catch (error) {\n        console.error('Error resetting password:', error);\n        return { success: false, error: error.message };\n    }\n}\n\n/**\n * Add active deposit request\n * @param {string} userId - Discord user ID\n * @param {string} address - LTC address\n * @param {number} initialBalance - Initial balance of address\n */\nfunction addActiveDeposit(userId, address, initialBalance = 0) {\n    const activeDeposits = loadActiveDeposits();\n    \n    if (!activeDeposits[userId]) {\n        activeDeposits[userId] = [];\n    }\n    \n    activeDeposits[userId].push({\n        address: address,\n        userId: userId,\n        lastKnownBalance: initialBalance,\n        createdAt: new Date().toISOString(),\n        active: true\n    });\n    \n    saveActiveDeposits(activeDeposits);\n}\n\n/**\n * Get active deposits for user\n * @param {string} userId - Discord user ID\n * @returns {Array} Active deposit requests\n */\nfunction getActiveDeposits(userId) {\n    const activeDeposits = loadActiveDeposits();\n    return activeDeposits[userId] || [];\n}\n\n/**\n * Get all active deposits across all users\n * @returns {Array} All active deposit requests\n */\nfunction getAllActiveDeposits() {\n    const activeDeposits = loadActiveDeposits();\n    const allDeposits = [];\n    \n    for (const userId in activeDeposits) {\n        allDeposits.push(...activeDeposits[userId].filter(deposit => deposit.active));\n    }\n    \n    return allDeposits;\n}\n\n/**\n * Complete deposit request\n * @param {string} userId - Discord user ID\n * @param {string} address - LTC address\n */\nfunction completeDepositRequest(userId, address) {\n    const activeDeposits = loadActiveDeposits();\n    \n    if (activeDeposits[userId]) {\n        const deposit = activeDeposits[userId].find(d => d.address === address);\n        if (deposit) {\n            deposit.active = false;\n            deposit.completedAt = new Date().toISOString();\n        }\n    }\n    \n    saveActiveDeposits(activeDeposits);\n}\n\n/**\n * Start gambling session\n * @param {string} userId - Discord user ID\n * @param {number} minutes - Session duration in minutes\n * @returns {Date} Session end time\n */\nfunction startGamblingSession(userId, minutes) {\n    const sessions = loadGamblingSessions();\n    const endTime = new Date(Date.now() + minutes * 60 * 1000);\n    \n    sessions[userId] = {\n        userId: userId,\n        startTime: new Date().toISOString(),\n        endTime: endTime.toISOString(),\n        durationMinutes: minutes,\n        active: true\n    };\n    \n    saveGamblingSessions(sessions);\n    \n    // Update user security\n    const security = loadSecurityData();\n    const userSec = getUserSecurity(userId);\n    userSec.lastGamblingSession = sessions[userId];\n    security[userId] = userSec;\n    saveSecurityData(security);\n    \n    return endTime;\n}\n\n/**\n * Check if user has active gambling session\n * @param {string} userId - Discord user ID\n * @returns {boolean} True if session is active\n */\nfunction hasActiveGamblingSession(userId) {\n    const sessions = loadGamblingSessions();\n    \n    if (!sessions[userId] || !sessions[userId].active) {\n        return false;\n    }\n    \n    const now = new Date();\n    const endTime = new Date(sessions[userId].endTime);\n    \n    if (now > endTime) {\n        // Session expired\n        sessions[userId].active = false;\n        saveGamblingSessions(sessions);\n        return false;\n    }\n    \n    return true;\n}\n\n/**\n * Add wagered amount for user\n * @param {string} userId - Discord user ID\n * @param {number} amount - Amount wagered\n */\nfunction addWageredAmount(userId, amount) {\n    const security = loadSecurityData();\n    const userSec = getUserSecurity(userId);\n    \n    userSec.wageredAmount += amount;\n    security[userId] = userSec;\n    saveSecurityData(security);\n}\n\n/**\n * Add deposited amount for user\n * @param {string} userId - Discord user ID\n * @param {number} amount - Amount deposited\n */\nfunction addDepositedAmount(userId, amount) {\n    const security = loadSecurityData();\n    const userSec = getUserSecurity(userId);\n    \n    userSec.depositedAmount += amount;\n    // Check if user can cashout (wagered >= deposited)\n    userSec.canCashout = userSec.wageredAmount >= userSec.depositedAmount;\n    \n    security[userId] = userSec;\n    saveSecurityData(security);\n}\n\n/**\n * Clear all active deposits (Admin function)\n * @returns {boolean} Success status\n */\nfunction clearAllActiveDeposits() {\n    try {\n        const emptyDeposits = {};\n        saveActiveDeposits(emptyDeposits);\n        console.log('üóØÔ∏è All active deposits cleared');\n        return true;\n    } catch (error) {\n        console.error('Error clearing active deposits:', error);\n        return false;\n    }\n}\n\n/**\n * Check if user can cashout\n * @param {string} userId - Discord user ID\n * @returns {Object} Cashout status and info\n */\nfunction canUserCashout(userId) {\n    const userSec = getUserSecurity(userId);\n    \n    const wageredPercent = userSec.depositedAmount > 0 ? \n        (userSec.wageredAmount / userSec.depositedAmount) * 100 : 100;\n    \n    return {\n        canCashout: userSec.canCashout,\n        wageredAmount: userSec.wageredAmount,\n        depositedAmount: userSec.depositedAmount,\n        wageredPercent: wageredPercent,\n        remainingToWager: Math.max(0, userSec.depositedAmount - userSec.wageredAmount)\n    };\n}\n\nmodule.exports = {\n    getUserSecurity,\n    setUserPassword,\n    changeUserPassword,\n    verifyUserPassword,\n    resetRecoveryKey,\n    resetPassword,\n    addActiveDeposit,\n    getActiveDeposits,\n    getAllActiveDeposits,\n    completeDepositRequest,\n    clearAllActiveDeposits,\n    startGamblingSession,\n    hasActiveGamblingSession,\n    addWageredAmount,\n    addDepositedAmount,\n    canUserCashout,\n    generateRecoveryKey\n};","size_bytes":13379},"utils/ticketManager.js":{"content":"/**\n * Ticket Manager for Casino Bot\n * Handles creation and management of private ticket channels\n */\n\nconst fs = require('fs');\nconst TICKETS_FILE = './data/tickets.json';\n\n/**\n * Get default tickets data\n */\nfunction getDefaultData() {\n    return {\n        activeTickets: {},\n        ticketCounter: 0\n    };\n}\n\n/**\n * Load tickets data\n */\nfunction loadTickets() {\n    try {\n        if (!fs.existsSync('./data')) {\n            fs.mkdirSync('./data', { recursive: true });\n        }\n        \n        if (fs.existsSync(TICKETS_FILE)) {\n            const data = fs.readFileSync(TICKETS_FILE, 'utf8');\n            return JSON.parse(data);\n        }\n    } catch (error) {\n        console.error('Erreur lors du chargement des tickets:', error);\n    }\n    \n    return getDefaultData();\n}\n\n/**\n * Save tickets data\n */\nfunction saveTickets(data) {\n    try {\n        if (!fs.existsSync('./data')) {\n            fs.mkdirSync('./data', { recursive: true });\n        }\n        \n        fs.writeFileSync(TICKETS_FILE, JSON.stringify(data, null, 2));\n        return true;\n    } catch (error) {\n        console.error('Erreur lors de la sauvegarde des tickets:', error);\n        return false;\n    }\n}\n\n/**\n * Create a private ticket channel for user\n */\nasync function createTicket(guild, user, categoryId, staffRoleId, ticketType = 'general') {\n    try {\n        const data = loadTickets();\n        \n        // Check if user already has an active ticket\n        const existingTicket = Object.values(data.activeTickets).find(ticket => \n            ticket.userId === user.id && ticket.type === ticketType\n        );\n        \n        if (existingTicket) {\n            try {\n                const existingChannel = guild.channels.cache.get(existingTicket.channelId);\n                if (existingChannel) {\n                    return { \n                        success: false, \n                        error: 'existing',\n                        channel: existingChannel \n                    };\n                } else {\n                    // Channel doesn't exist anymore, remove from data\n                    delete data.activeTickets[existingTicket.ticketId];\n                    saveTickets(data);\n                }\n            } catch (error) {\n                console.log('Erreur v√©rification channel existant:', error);\n            }\n        }\n        \n        // Increment counter and create ticket ID\n        data.ticketCounter++;\n        const ticketId = `ticket-${data.ticketCounter}`;\n        \n        // Determine ticket name based on type\n        const ticketNames = {\n            'balance': 'üí∞-balance',\n            'profile': 'üë§-profile', \n            'general': 'üé´-casino'\n        };\n        \n        const channelName = `${ticketNames[ticketType] || 'üé´-casino'}-${user.username}`.toLowerCase();\n        \n        // Set up permissions\n        const permissionOverwrites = [\n            {\n                id: guild.id, // @everyone\n                deny: ['ViewChannel', 'SendMessages', 'ReadMessageHistory']\n            },\n            {\n                id: user.id,\n                allow: ['ViewChannel', 'SendMessages', 'ReadMessageHistory', 'AttachFiles', 'EmbedLinks']\n            }\n        ];\n        \n        // Add staff role permissions if provided\n        if (staffRoleId) {\n            permissionOverwrites.push({\n                id: staffRoleId,\n                allow: ['ViewChannel', 'SendMessages', 'ReadMessageHistory', 'AttachFiles', 'EmbedLinks', 'ManageMessages']\n            });\n        }\n        \n        // Create the channel\n        const channel = await guild.channels.create({\n            name: channelName,\n            type: 0, // Text channel\n            topic: `Private ${ticketType} session for ${user.username} ‚Ä¢ Ticket ID: ${ticketId}`,\n            parent: categoryId,\n            permissionOverwrites: permissionOverwrites\n        });\n        \n        // Save ticket data\n        data.activeTickets[ticketId] = {\n            ticketId,\n            channelId: channel.id,\n            userId: user.id,\n            username: user.username,\n            type: ticketType,\n            createdAt: Date.now(),\n            staffRoleId\n        };\n        \n        saveTickets(data);\n        \n        return {\n            success: true,\n            channel,\n            ticketId\n        };\n        \n    } catch (error) {\n        console.error('Erreur cr√©ation ticket:', error);\n        return {\n            success: false,\n            error: 'create_failed'\n        };\n    }\n}\n\n/**\n * Close a ticket channel\n */\nasync function closeTicket(ticketId, guild) {\n    try {\n        const data = loadTickets();\n        const ticket = data.activeTickets[ticketId];\n        \n        if (!ticket) {\n            return { success: false, error: 'not_found' };\n        }\n        \n        // Try to delete the channel\n        try {\n            const channel = guild.channels.cache.get(ticket.channelId);\n            if (channel) {\n                await channel.delete();\n            }\n        } catch (error) {\n            console.log('Erreur suppression channel:', error);\n        }\n        \n        // Remove from data\n        delete data.activeTickets[ticketId];\n        saveTickets(data);\n        \n        return { success: true };\n        \n    } catch (error) {\n        console.error('Erreur fermeture ticket:', error);\n        return { success: false, error: 'close_failed' };\n    }\n}\n\n/**\n * Get ticket by channel ID\n */\nfunction getTicketByChannel(channelId) {\n    const data = loadTickets();\n    return Object.values(data.activeTickets).find(ticket => \n        ticket.channelId === channelId\n    );\n}\n\n/**\n * Get ticket by user ID and type\n */\nfunction getTicketByUser(userId, ticketType = null) {\n    const data = loadTickets();\n    return Object.values(data.activeTickets).find(ticket => \n        ticket.userId === userId && (ticketType ? ticket.type === ticketType : true)\n    );\n}\n\n/**\n * Get all active tickets\n */\nfunction getAllTickets() {\n    const data = loadTickets();\n    return data.activeTickets;\n}\n\n/**\n * Clean up old/invalid tickets\n */\nasync function cleanupTickets(guild) {\n    try {\n        const data = loadTickets();\n        let cleanedCount = 0;\n        \n        for (const [ticketId, ticket] of Object.entries(data.activeTickets)) {\n            try {\n                const channel = guild.channels.cache.get(ticket.channelId);\n                if (!channel) {\n                    // Channel doesn't exist, remove ticket\n                    delete data.activeTickets[ticketId];\n                    cleanedCount++;\n                }\n            } catch (error) {\n                // Error checking channel, remove ticket\n                delete data.activeTickets[ticketId];\n                cleanedCount++;\n            }\n        }\n        \n        if (cleanedCount > 0) {\n            saveTickets(data);\n            console.log(`üßπ Nettoy√© ${cleanedCount} ticket(s) invalide(s)`);\n        }\n        \n        return cleanedCount;\n        \n    } catch (error) {\n        console.error('Erreur nettoyage tickets:', error);\n        return 0;\n    }\n}\n\nmodule.exports = {\n    createTicket,\n    closeTicket,\n    getTicketByChannel,\n    getTicketByUser,\n    getAllTickets,\n    cleanupTickets\n};","size_bytes":7231},"utils/userProfiles.js":{"content":"const fs = require('fs');\nconst path = require('path');\n\nconst PROFILES_FILE = path.join(__dirname, '../data/user_profiles.json');\nconst ADDRESS_MAPPING_FILE = path.join(__dirname, '../data/address_mapping.json');\n\n// Ensure data directory exists\nconst dataDir = path.join(__dirname, '../data');\nif (!fs.existsSync(dataDir)) {\n    fs.mkdirSync(dataDir, { recursive: true });\n}\n\n/**\n * Load user profiles from JSON file\n * @returns {Object} User profiles object\n */\nfunction loadProfiles() {\n    try {\n        if (fs.existsSync(PROFILES_FILE)) {\n            const data = fs.readFileSync(PROFILES_FILE, 'utf8');\n            return JSON.parse(data);\n        }\n    } catch (error) {\n        console.error('Error loading user profiles:', error.message);\n    }\n    return {};\n}\n\n/**\n * Save user profiles to JSON file\n * @param {Object} profiles - User profiles to save\n */\nfunction saveProfiles(profiles) {\n    try {\n        fs.writeFileSync(PROFILES_FILE, JSON.stringify(profiles, null, 2));\n        console.log('‚úÖ User profiles saved');\n    } catch (error) {\n        console.error('Error saving user profiles:', error.message);\n    }\n}\n\n/**\n * Load address mapping from JSON file\n * @returns {Object} Address mapping object\n */\nfunction loadAddressMapping() {\n    try {\n        if (fs.existsSync(ADDRESS_MAPPING_FILE)) {\n            const data = fs.readFileSync(ADDRESS_MAPPING_FILE, 'utf8');\n            return JSON.parse(data);\n        }\n    } catch (error) {\n        console.error('Error loading address mapping:', error.message);\n    }\n    return {};\n}\n\n/**\n * Save address mapping to JSON file\n * @param {Object} mapping - Address mapping to save\n */\nfunction saveAddressMapping(mapping) {\n    try {\n        fs.writeFileSync(ADDRESS_MAPPING_FILE, JSON.stringify(mapping, null, 2));\n        console.log('‚úÖ Address mapping saved');\n    } catch (error) {\n        console.error('Error saving address mapping:', error.message);\n    }\n}\n\n/**\n * Get or create user profile\n * @param {string} userId - Discord user ID\n * @returns {Object} User profile\n */\nfunction getUserProfile(userId) {\n    const profiles = loadProfiles();\n    \n    if (!profiles[userId]) {\n        profiles[userId] = {\n            userId: userId,\n            balance: 0,\n            totalDeposited: 0,\n            totalWithdrawn: 0,\n            depositHistory: [],\n            withdrawalHistory: [],\n            gameHistory: [],\n            addresses: [],\n            createdAt: new Date().toISOString(),\n            lastActivity: new Date().toISOString()\n        };\n        saveProfiles(profiles);\n    }\n    \n    return profiles[userId];\n}\n\n/**\n * Update user profile\n * @param {string} userId - Discord user ID\n * @param {Object} updates - Updates to apply to profile\n */\nfunction updateUserProfile(userId, updates) {\n    const profiles = loadProfiles();\n    \n    if (!profiles[userId]) {\n        profiles[userId] = getUserProfile(userId);\n    }\n    \n    // Merge updates\n    profiles[userId] = { ...profiles[userId], ...updates };\n    profiles[userId].lastActivity = new Date().toISOString();\n    \n    saveProfiles(profiles);\n    return profiles[userId];\n}\n\n/**\n * Add deposit to user profile\n * @param {string} userId - Discord user ID\n * @param {number} amount - Deposit amount in LTC\n * @param {string} address - Deposit address\n * @param {string} txid - Transaction ID\n */\nfunction addDeposit(userId, amount, address, txid = null) {\n    const profile = getUserProfile(userId);\n    \n    const deposit = {\n        amount: amount,\n        address: address,\n        txid: txid,\n        timestamp: new Date().toISOString(),\n        confirmed: txid !== null\n    };\n    \n    profile.depositHistory.push(deposit);\n    profile.balance += amount;\n    profile.totalDeposited += amount;\n    \n    updateUserProfile(userId, profile);\n    \n    console.log(`üí∞ Added deposit: ${amount} LTC for user ${userId}`);\n    return deposit;\n}\n\n/**\n * Add withdrawal to user profile\n * @param {string} userId - Discord user ID\n * @param {number} amount - Withdrawal amount in LTC\n * @param {string} toAddress - Destination address\n * @param {string} txid - Transaction ID\n */\nfunction addWithdrawal(userId, amount, toAddress, txid) {\n    const profile = getUserProfile(userId);\n    \n    if (profile.balance < amount) {\n        throw new Error('Insufficient balance');\n    }\n    \n    const withdrawal = {\n        amount: amount,\n        toAddress: toAddress,\n        txid: txid,\n        timestamp: new Date().toISOString()\n    };\n    \n    profile.withdrawalHistory.push(withdrawal);\n    profile.balance -= amount;\n    profile.totalWithdrawn += amount;\n    \n    updateUserProfile(userId, profile);\n    \n    console.log(`üí∏ Added withdrawal: ${amount} LTC for user ${userId}`);\n    return withdrawal;\n}\n\n/**\n * Transfer balance between users\n * @param {string} fromUserId - Sender user ID\n * @param {string} toUserId - Receiver user ID\n * @param {number} amount - Amount to transfer\n */\nfunction transferBalance(fromUserId, toUserId, amount) {\n    const fromProfile = getUserProfile(fromUserId);\n    const toProfile = getUserProfile(toUserId);\n    \n    if (fromProfile.balance < amount) {\n        throw new Error('Insufficient balance');\n    }\n    \n    fromProfile.balance -= amount;\n    toProfile.balance += amount;\n    \n    const transfer = {\n        amount: amount,\n        from: fromUserId,\n        to: toUserId,\n        timestamp: new Date().toISOString(),\n        type: 'transfer'\n    };\n    \n    // Add to both users' histories\n    fromProfile.gameHistory.push({ ...transfer, action: 'sent' });\n    toProfile.gameHistory.push({ ...transfer, action: 'received' });\n    \n    updateUserProfile(fromUserId, fromProfile);\n    updateUserProfile(toUserId, toProfile);\n    \n    console.log(`üîÑ Transfer: ${amount} LTC from ${fromUserId} to ${toUserId}`);\n    return transfer;\n}\n\n/**\n * Link a Litecoin address to a Discord user\n * @param {string} userId - Discord user ID\n * @param {string} address - Litecoin address\n */\nfunction linkAddressToUser(userId, address) {\n    const mapping = loadAddressMapping();\n    const profile = getUserProfile(userId);\n    \n    mapping[address] = userId;\n    profile.addresses.push(address);\n    \n    saveAddressMapping(mapping);\n    updateUserProfile(userId, profile);\n    \n    console.log(`üîó Linked address ${address} to user ${userId}`);\n}\n\n/**\n * Get user ID from Litecoin address\n * @param {string} address - Litecoin address\n * @returns {string|null} Discord user ID or null if not found\n */\nfunction getUserFromAddress(address) {\n    const mapping = loadAddressMapping();\n    return mapping[address] || null;\n}\n\n/**\n * Get all user profiles\n * @returns {Object} All user profiles\n */\nfunction getAllProfiles() {\n    return loadProfiles();\n}\n\n/**\n * Get leaderboard data\n * @param {string} type - 'balance', 'deposited', 'withdrawn'\n * @param {number} limit - Number of users to return\n * @returns {Array} Sorted user data\n */\nfunction getLeaderboard(type = 'balance', limit = 10) {\n    const profiles = loadProfiles();\n    const users = Object.values(profiles);\n    \n    let sortKey;\n    switch (type) {\n        case 'deposited':\n            sortKey = 'totalDeposited';\n            break;\n        case 'withdrawn':\n            sortKey = 'totalWithdrawn';\n            break;\n        default:\n            sortKey = 'balance';\n    }\n    \n    return users\n        .sort((a, b) => b[sortKey] - a[sortKey])\n        .slice(0, limit)\n        .map(user => ({\n            userId: user.userId,\n            value: user[sortKey],\n            balance: user.balance\n        }));\n}\n\n/**\n * Reset user security (password and recovery key) - Admin function\n * @param {string} userId - Discord user ID\n * @returns {Object} Result with success status and new recovery key\n */\nfunction resetUserSecurity(userId) {\n    try {\n        const securityManager = require('./securityManager.js');\n        const profiles = loadProfiles();\n        \n        if (!profiles[userId]) {\n            return { success: false, error: 'User profile not found' };\n        }\n        \n        // Generate new recovery key using securityManager\n        const newRecoveryKey = securityManager.generateRecoveryKey();\n        \n        // Reset password to null (forces user to create new one)\n        const resetResult = securityManager.resetPassword(userId, newRecoveryKey);\n        \n        if (resetResult.success) {\n            console.log(`üîê Admin reset security for user ${userId}`);\n            \n            return {\n                success: true,\n                newRecoveryKey: newRecoveryKey\n            };\n        } else {\n            return { success: false, error: 'Security reset failed' };\n        }\n        \n    } catch (error) {\n        console.error('Error resetting user security:', error);\n        return { success: false, error: 'Reset failed' };\n    }\n}\n\nmodule.exports = {\n    getUserProfile,\n    updateUserProfile,\n    addDeposit,\n    addWithdrawal,\n    transferBalance,\n    linkAddressToUser,\n    getUserFromAddress,\n    getAllProfiles,\n    getLeaderboard,\n    loadProfiles,\n    saveProfiles,\n    resetUserSecurity\n};","size_bytes":9095},"commands/blackjack.js":{"content":"const { SlashCommandBuilder, EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle } = require('discord.js');\nconst userProfiles = require('../utils/userProfiles.js');\nconst securityManager = require('../utils/securityManager.js');\nconst logManager = require('../utils/logManager.js');\nconst { formatLTC } = require('../utils/formatters.js');\n\n// Card deck\nconst suits = ['‚ô†Ô∏è', '‚ô•Ô∏è', '‚ô¶Ô∏è', '‚ô£Ô∏è'];\nconst ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];\n\n// Active games storage\nconst activeGames = new Map();\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('blackjack')\n        .setDescription('Play Blackjack against the dealer')\n        .addNumberOption(option =>\n            option.setName('bet')\n                .setDescription('Amount to bet in LTC')\n                .setRequired(true)\n                .setMinValue(0.001)\n        ),\n    \n    async execute(interaction) {\n        // Check if interaction is too old\n        const interactionAge = Date.now() - interaction.createdTimestamp;\n        if (interactionAge > 10 * 60 * 1000) {\n            console.log('Interaction trop ancienne, ignor√©e');\n            return;\n        }\n        \n        await interaction.deferReply({ ephemeral: false });\n        \n        try {\n            const bet = interaction.options.getNumber('bet');\n            const userId = interaction.user.id;\n            \n            // Check if user has active game\n            if (activeGames.has(userId)) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Game Already Active')\n                    .setDescription('You already have an active blackjack game. Finish it first!')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Get user profile and verify balance\n            const profile = userProfiles.getUserProfile(userId);\n            \n            if (profile.balance < bet) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Insufficient Balance')\n                    .setDescription(`You need **${formatLTC(bet)} LTC** to play but only have **${formatLTC(profile.balance)} LTC**.`)\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Check password protection\n            const userSec = securityManager.getUserSecurity(userId);\n            if (!userSec.hasPassword) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ffaa00')\n                    .setTitle('üîí Password Required')\n                    .setDescription('You need to set a password before gambling. Use `/setpassword` first.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Deduct bet from balance\n            userProfiles.updateUserProfile(userId, { \n                balance: profile.balance - bet \n            });\n            \n            // Add wagered amount\n            securityManager.addWageredAmount(userId, bet);\n            \n            // Create new game\n            const game = createNewGame(bet, userId);\n            activeGames.set(userId, game);\n            \n            // Deal initial cards\n            dealInitialCards(game);\n            \n            // Create game embed\n            const gameEmbed = createGameEmbed(game, interaction.user);\n            const gameButtons = createGameButtons(game);\n            \n            await interaction.editReply({ \n                embeds: [gameEmbed],\n                components: [gameButtons]\n            });\n            \n            // Auto-timeout after 2 minutes\n            setTimeout(() => {\n                if (activeGames.has(userId)) {\n                    const timeoutGame = activeGames.get(userId);\n                    if (timeoutGame.status === 'playing') {\n                        timeoutGame.status = 'timeout';\n                        activeGames.delete(userId);\n                        console.log(`üïê Blackjack game timed out for ${interaction.user.username}`);\n                    }\n                }\n            }, 120000); // 2 minutes\n            \n        } catch (error) {\n            console.error('Erreur blackjack:', error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Error')\n                .setDescription('An error occurred while starting the blackjack game.')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};\n\nfunction createNewGame(bet, userId) {\n    return {\n        userId: userId,\n        bet: bet,\n        deck: createDeck(),\n        playerHand: [],\n        dealerHand: [],\n        playerValue: 0,\n        dealerValue: 0,\n        status: 'playing', // playing, won, lost, push, timeout\n        canDoubleDown: true,\n        startTime: Date.now()\n    };\n}\n\nfunction createDeck() {\n    const deck = [];\n    for (const suit of suits) {\n        for (const rank of ranks) {\n            deck.push({ suit, rank });\n        }\n    }\n    return shuffleDeck(deck);\n}\n\nfunction shuffleDeck(deck) {\n    for (let i = deck.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        [deck[i], deck[j]] = [deck[j], deck[i]];\n    }\n    return deck;\n}\n\nfunction dealCard(game) {\n    return game.deck.pop();\n}\n\nfunction dealInitialCards(game) {\n    // Deal 2 cards to player and dealer\n    game.playerHand.push(dealCard(game));\n    game.dealerHand.push(dealCard(game));\n    game.playerHand.push(dealCard(game));\n    game.dealerHand.push(dealCard(game));\n    \n    game.playerValue = calculateHandValue(game.playerHand);\n    game.dealerValue = calculateHandValue(game.dealerHand);\n    \n    // Check for natural blackjack\n    if (game.playerValue === 21) {\n        if (game.dealerValue === 21) {\n            game.status = 'push'; // Tie\n        } else {\n            game.status = 'blackjack'; // Player blackjack\n        }\n    }\n}\n\nfunction calculateHandValue(hand) {\n    let value = 0;\n    let aces = 0;\n    \n    for (const card of hand) {\n        if (card.rank === 'A') {\n            aces++;\n            value += 11;\n        } else if (['J', 'Q', 'K'].includes(card.rank)) {\n            value += 10;\n        } else {\n            value += parseInt(card.rank);\n        }\n    }\n    \n    // Handle aces\n    while (value > 21 && aces > 0) {\n        value -= 10;\n        aces--;\n    }\n    \n    return value;\n}\n\nfunction formatHand(hand, hideFirst = false) {\n    return hand.map((card, index) => {\n        if (hideFirst && index === 0) {\n            return 'üÉè';\n        }\n        return `${card.rank}${card.suit}`;\n    }).join(' ');\n}\n\nfunction createGameEmbed(game, user) {\n    const playerHandStr = formatHand(game.playerHand);\n    const dealerHandStr = formatHand(game.dealerHand, game.status === 'playing');\n    \n    let title = 'üÉè Blackjack Game';\n    let color = '#f7931a';\n    let description = `Bet: **${formatLTC(game.bet)} LTC**`;\n    \n    if (game.status === 'won') {\n        title = 'üéâ You Win!';\n        color = '#00ff00';\n        description = `You won **${formatLTC(game.bet * 2)} LTC**!`;\n    } else if (game.status === 'lost') {\n        title = 'üí∏ You Lost';\n        color = '#ff0000';\n        description = `You lost **${formatLTC(game.bet)} LTC**`;\n    } else if (game.status === 'push') {\n        title = 'ü§ù Push (Tie)';\n        color = '#ffaa00';\n        description = `Your bet of **${formatLTC(game.bet)} LTC** has been returned`;\n    } else if (game.status === 'blackjack') {\n        title = 'üéØ BLACKJACK!';\n        color = '#ffd700';\n        description = `You won **${formatLTC(game.bet * 2.5)} LTC** with Blackjack!`;\n    }\n    \n    const embed = new EmbedBuilder()\n        .setColor(color)\n        .setTitle(title)\n        .setDescription(description)\n        .addFields(\n            {\n                name: `üë§ ${user.username}'s Hand (${game.playerValue})`,\n                value: playerHandStr,\n                inline: false\n            },\n            {\n                name: `üé∞ Dealer's Hand ${game.status === 'playing' ? '(?)' : `(${game.dealerValue})`}`,\n                value: dealerHandStr,\n                inline: false\n            }\n        )\n        .setFooter({ text: 'Good luck!' })\n        .setTimestamp();\n    \n    if (game.status !== 'playing') {\n        const profile = userProfiles.getUserProfile(game.userId);\n        embed.addFields({\n            name: 'üí∞ New Balance',\n            value: `${formatLTC(profile.balance)} LTC`,\n            inline: true\n        });\n    }\n    \n    return embed;\n}\n\nfunction createGameButtons(game) {\n    const row = new ActionRowBuilder();\n    \n    if (game.status === 'playing') {\n        row.addComponents(\n            new ButtonBuilder()\n                .setCustomId('blackjack_hit')\n                .setLabel('Hit')\n                .setStyle(ButtonStyle.Primary)\n                .setEmoji('üéØ'),\n            new ButtonBuilder()\n                .setCustomId('blackjack_stand')\n                .setLabel('Stand')\n                .setStyle(ButtonStyle.Secondary)\n                .setEmoji('‚úã')\n        );\n        \n        if (game.canDoubleDown && game.playerHand.length === 2) {\n            const profile = userProfiles.getUserProfile(game.userId);\n            if (profile.balance >= game.bet) {\n                row.addComponents(\n                    new ButtonBuilder()\n                        .setCustomId('blackjack_double')\n                        .setLabel('Double Down')\n                        .setStyle(ButtonStyle.Success)\n                        .setEmoji('üí∞')\n                );\n            }\n        }\n    }\n    \n    return row;\n}\n\n// Export game functions for button handlers\nmodule.exports.activeGames = activeGames;\nmodule.exports.calculateHandValue = calculateHandValue;\nmodule.exports.dealCard = dealCard;\nmodule.exports.createGameEmbed = createGameEmbed;\nmodule.exports.createGameButtons = createGameButtons;\nmodule.exports.formatHand = formatHand;","size_bytes":10444},"commands/roulette.js":{"content":"const { SlashCommandBuilder, EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle, StringSelectMenuBuilder } = require('discord.js');\nconst userProfiles = require('../utils/userProfiles.js');\nconst securityManager = require('../utils/securityManager.js');\nconst logManager = require('../utils/logManager.js');\nconst { formatLTC } = require('../utils/formatters.js');\n\n// Roulette wheel numbers and colors\nconst wheel = {\n    0: 'green',\n    1: 'red', 2: 'black', 3: 'red', 4: 'black', 5: 'red', 6: 'black',\n    7: 'red', 8: 'black', 9: 'red', 10: 'black', 11: 'black', 12: 'red',\n    13: 'black', 14: 'red', 15: 'black', 16: 'red', 17: 'black', 18: 'red',\n    19: 'red', 20: 'black', 21: 'red', 22: 'black', 23: 'red', 24: 'black',\n    25: 'red', 26: 'black', 27: 'red', 28: 'black', 29: 'black', 30: 'red',\n    31: 'black', 32: 'red', 33: 'black', 34: 'red', 35: 'black', 36: 'red'\n};\n\n// Active spins storage\nconst activeSpins = new Map();\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('roulette')\n        .setDescription('Play Roulette - place your bets!')\n        .addNumberOption(option =>\n            option.setName('bet')\n                .setDescription('Amount to bet in LTC')\n                .setRequired(true)\n                .setMinValue(0.001)\n        ),\n    \n    async execute(interaction) {\n        // Check if interaction is too old\n        const interactionAge = Date.now() - interaction.createdTimestamp;\n        if (interactionAge > 10 * 60 * 1000) {\n            console.log('Interaction trop ancienne, ignor√©e');\n            return;\n        }\n        \n        await interaction.deferReply({ ephemeral: false });\n        \n        try {\n            const bet = interaction.options.getNumber('bet');\n            const userId = interaction.user.id;\n            \n            // Check if user has active spin\n            if (activeSpins.has(userId)) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Spin Already Active')\n                    .setDescription('You already have an active roulette spin. Wait for it to finish!')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Get user profile and verify balance\n            const profile = userProfiles.getUserProfile(userId);\n            \n            if (profile.balance < bet) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ff0000')\n                    .setTitle('‚ùå Insufficient Balance')\n                    .setDescription(`You need **${formatLTC(bet)} LTC** to play but only have **${formatLTC(profile.balance)} LTC**.`)\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Check password protection\n            const userSec = securityManager.getUserSecurity(userId);\n            if (!userSec.hasPassword) {\n                const errorEmbed = new EmbedBuilder()\n                    .setColor('#ffaa00')\n                    .setTitle('üîí Password Required')\n                    .setDescription('You need to set a password before gambling. Use `/setpassword` first.')\n                    .setTimestamp();\n                \n                await interaction.editReply({ embeds: [errorEmbed] });\n                return;\n            }\n            \n            // Create new spin\n            const spin = {\n                userId: userId,\n                bet: bet,\n                bets: new Map(),\n                status: 'betting',\n                result: null,\n                totalPayout: 0,\n                startTime: Date.now()\n            };\n            \n            activeSpins.set(userId, spin);\n            \n            // Show betting interface\n            const bettingEmbed = createBettingEmbed(spin, interaction.user);\n            const bettingComponents = createBettingComponents();\n            \n            await interaction.editReply({ \n                embeds: [bettingEmbed],\n                components: bettingComponents\n            });\n            \n            // Auto-timeout after 2 minutes\n            setTimeout(() => {\n                if (activeSpins.has(userId)) {\n                    const timeoutSpin = activeSpins.get(userId);\n                    if (timeoutSpin.status === 'betting') {\n                        timeoutSpin.status = 'timeout';\n                        activeSpins.delete(userId);\n                        console.log(`üïê Roulette spin timed out for ${interaction.user.username}`);\n                    }\n                }\n            }, 120000);\n            \n        } catch (error) {\n            console.error('Erreur roulette:', error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Error')\n                .setDescription('An error occurred while starting the roulette game.')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};\n\nfunction createBettingEmbed(spin, user) {\n    const embed = new EmbedBuilder()\n        .setColor('#9932cc')\n        .setTitle('üé∞ Roulette - Place Your Bets!')\n        .setDescription(`**Available to bet:** ${formatLTC(spin.bet)} LTC`)\n        .addFields(\n            {\n                name: 'üéØ How to Play',\n                value: '‚Ä¢ Choose your betting options below\\n‚Ä¢ Numbers pay 35:1\\n‚Ä¢ Colors (Red/Black) pay 1:1\\n‚Ä¢ Even/Odd pay 1:1\\n‚Ä¢ High/Low pay 1:1',\n                inline: false\n            },\n            {\n                name: 'üí∞ Current Bets',\n                value: spin.bets.size > 0 ? formatBets(spin.bets) : 'No bets placed yet',\n                inline: false\n            }\n        )\n        .setFooter({ text: 'Select your bets below, then click Spin!' })\n        .setTimestamp();\n    \n    return embed;\n}\n\nfunction createBettingComponents() {\n    const colorRow = new ActionRowBuilder()\n        .addComponents(\n            new ButtonBuilder()\n                .setCustomId('roulette_bet_red')\n                .setLabel('Red (1:1)')\n                .setStyle(ButtonStyle.Danger)\n                .setEmoji('üî¥'),\n            new ButtonBuilder()\n                .setCustomId('roulette_bet_black')\n                .setLabel('Black (1:1)')\n                .setStyle(ButtonStyle.Secondary)\n                .setEmoji('‚ö´'),\n            new ButtonBuilder()\n                .setCustomId('roulette_bet_green')\n                .setLabel('Green (35:1)')\n                .setStyle(ButtonStyle.Success)\n                .setEmoji('üü¢')\n        );\n    \n    const oddEvenRow = new ActionRowBuilder()\n        .addComponents(\n            new ButtonBuilder()\n                .setCustomId('roulette_bet_even')\n                .setLabel('Even (1:1)')\n                .setStyle(ButtonStyle.Primary)\n                .setEmoji('2Ô∏è‚É£'),\n            new ButtonBuilder()\n                .setCustomId('roulette_bet_odd')\n                .setLabel('Odd (1:1)')\n                .setStyle(ButtonStyle.Primary)\n                .setEmoji('1Ô∏è‚É£'),\n            new ButtonBuilder()\n                .setCustomId('roulette_bet_low')\n                .setLabel('Low 1-18 (1:1)')\n                .setStyle(ButtonStyle.Primary)\n                .setEmoji('üîΩ'),\n            new ButtonBuilder()\n                .setCustomId('roulette_bet_high')\n                .setLabel('High 19-36 (1:1)')\n                .setStyle(ButtonStyle.Primary)\n                .setEmoji('üîº')\n        );\n    \n    const numberSelect = new ActionRowBuilder()\n        .addComponents(\n            new StringSelectMenuBuilder()\n                .setCustomId('roulette_bet_number')\n                .setPlaceholder('Choose a number (0-36) for 35:1 payout')\n                .addOptions(\n                    Array.from({ length: 37 }, (_, i) => ({\n                        label: `Number ${i}`,\n                        value: `number_${i}`,\n                        description: `Bet on ${i} (35:1 payout)`,\n                        emoji: i === 0 ? 'üü¢' : (wheel[i] === 'red' ? 'üî¥' : '‚ö´')\n                    }))\n                )\n        );\n    \n    const actionRow = new ActionRowBuilder()\n        .addComponents(\n            new ButtonBuilder()\n                .setCustomId('roulette_spin')\n                .setLabel('üé∞ SPIN!')\n                .setStyle(ButtonStyle.Success)\n                .setEmoji('üé∞'),\n            new ButtonBuilder()\n                .setCustomId('roulette_clear')\n                .setLabel('Clear Bets')\n                .setStyle(ButtonStyle.Secondary)\n                .setEmoji('üóëÔ∏è'),\n            new ButtonBuilder()\n                .setCustomId('roulette_cancel')\n                .setLabel('Cancel')\n                .setStyle(ButtonStyle.Danger)\n                .setEmoji('‚ùå')\n        );\n    \n    return [colorRow, oddEvenRow, numberSelect, actionRow];\n}\n\nfunction formatBets(bets) {\n    let betString = '';\n    let totalBet = 0;\n    \n    for (const [betType, amount] of bets) {\n        betString += `‚Ä¢ **${betType}**: ${formatLTC(amount)} LTC\\n`;\n        totalBet += amount;\n    }\n    \n    betString += `\\n**Total Bet**: ${formatLTC(totalBet)} LTC`;\n    return betString;\n}\n\nfunction spinWheel() {\n    return Math.floor(Math.random() * 37);\n}\n\nfunction calculatePayout(bets, result) {\n    let totalPayout = 0;\n    const winningBets = [];\n    \n    for (const [betType, amount] of bets) {\n        let won = false;\n        let multiplier = 0;\n        \n        if (betType.startsWith('number_')) {\n            const number = parseInt(betType.split('_')[1]);\n            if (number === result) {\n                won = true;\n                multiplier = 35;\n            }\n        } else if (betType === 'red' && wheel[result] === 'red') {\n            won = true;\n            multiplier = 1;\n        } else if (betType === 'black' && wheel[result] === 'black') {\n            won = true;\n            multiplier = 1;\n        } else if (betType === 'green' && wheel[result] === 'green') {\n            won = true;\n            multiplier = 35;\n        } else if (betType === 'even' && result !== 0 && result % 2 === 0) {\n            won = true;\n            multiplier = 1;\n        } else if (betType === 'odd' && result % 2 === 1) {\n            won = true;\n            multiplier = 1;\n        } else if (betType === 'low' && result >= 1 && result <= 18) {\n            won = true;\n            multiplier = 1;\n        } else if (betType === 'high' && result >= 19 && result <= 36) {\n            won = true;\n            multiplier = 1;\n        }\n        \n        if (won) {\n            const payout = amount * (multiplier + 1);\n            totalPayout += payout;\n            winningBets.push({ betType, amount, payout, multiplier });\n        }\n    }\n    \n    return { totalPayout, winningBets };\n}\n\nfunction createResultEmbed(spin, result, payout, winningBets, user) {\n    const resultColor = wheel[result];\n    const colorEmoji = resultColor === 'red' ? 'üî¥' : resultColor === 'black' ? '‚ö´' : 'üü¢';\n    \n    let title = 'üé∞ Roulette Result';\n    let color = '#9932cc';\n    let description = `The ball landed on **${result}** ${colorEmoji}`;\n    \n    if (payout > 0) {\n        title = 'üéâ You Win!';\n        color = '#00ff00';\n        description += `\\n\\nYou won **${formatLTC(payout)} LTC**!`;\n    } else {\n        title = 'üí∏ House Wins';\n        color = '#ff0000';\n        description += `\\n\\nBetter luck next time!`;\n    }\n    \n    const embed = new EmbedBuilder()\n        .setColor(color)\n        .setTitle(title)\n        .setDescription(description)\n        .addFields(\n            {\n                name: 'üéØ Winning Number',\n                value: `**${result}** ${colorEmoji} (${resultColor})`,\n                inline: true\n            }\n        );\n    \n    if (winningBets.length > 0) {\n        const winningBetsStr = winningBets.map(bet => \n            `‚Ä¢ **${bet.betType}**: ${formatLTC(bet.amount)} LTC ‚Üí ${formatLTC(bet.payout)} LTC (${bet.multiplier + 1}x)`\n        ).join('\\n');\n        \n        embed.addFields({\n            name: 'üèÜ Winning Bets',\n            value: winningBetsStr,\n            inline: false\n        });\n    }\n    \n    const profile = userProfiles.getUserProfile(spin.userId);\n    embed.addFields({\n        name: 'üí∞ New Balance',\n        value: `${formatLTC(profile.balance)} LTC`,\n        inline: true\n    });\n    \n    return embed;\n}\n\nmodule.exports.activeSpins = activeSpins;\nmodule.exports.spinWheel = spinWheel;\nmodule.exports.calculatePayout = calculatePayout;\nmodule.exports.createResultEmbed = createResultEmbed;\nmodule.exports.createBettingEmbed = createBettingEmbed;\nmodule.exports.createBettingComponents = createBettingComponents;\nmodule.exports.wheel = wheel;","size_bytes":12983},"commands/setlogbal.js":{"content":"const { SlashCommandBuilder, EmbedBuilder, PermissionFlagsBits, ChannelType } = require('discord.js');\nconst fs = require('fs');\nconst path = require('path');\n\nconst CONFIG_FILE = path.join(__dirname, '../data/log_config.json');\n\n// Ensure data directory exists\nconst dataDir = path.join(__dirname, '../data');\nif (!fs.existsSync(dataDir)) {\n    fs.mkdirSync(dataDir, { recursive: true });\n}\n\nfunction loadLogConfig() {\n    try {\n        if (fs.existsSync(CONFIG_FILE)) {\n            const data = fs.readFileSync(CONFIG_FILE, 'utf8');\n            return JSON.parse(data);\n        }\n    } catch (error) {\n        console.error('Error loading log config:', error.message);\n    }\n    return {};\n}\n\nfunction saveLogConfig(config) {\n    try {\n        fs.writeFileSync(CONFIG_FILE, JSON.stringify(config, null, 2));\n        console.log('‚úÖ Log config saved');\n    } catch (error) {\n        console.error('Error saving log config:', error.message);\n    }\n}\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('setlogbal')\n        .setDescription('Configure balance log channel (Admin only)')\n        .addChannelOption(option =>\n            option.setName('channel')\n                .setDescription('Channel to send balance logs to')\n                .setRequired(true)\n                .addChannelTypes(ChannelType.GuildText)\n        )\n        .setDefaultMemberPermissions(PermissionFlagsBits.Administrator),\n    \n    async execute(interaction) {\n        // Check if interaction is too old\n        const interactionAge = Date.now() - interaction.createdTimestamp;\n        if (interactionAge > 10 * 60 * 1000) {\n            console.log('Interaction trop ancienne, ignor√©e');\n            return;\n        }\n        \n        await interaction.deferReply({ ephemeral: true });\n        \n        try {\n            const channel = interaction.options.getChannel('channel');\n            const serverId = interaction.guild.id;\n            \n            // Load config\n            const config = loadLogConfig();\n            \n            if (!config[serverId]) {\n                config[serverId] = {};\n            }\n            \n            config[serverId].balanceLogChannel = channel.id;\n            \n            // Save config\n            saveLogConfig(config);\n            \n            const successEmbed = new EmbedBuilder()\n                .setColor('#00ff00')\n                .setTitle('‚úÖ Balance Log Channel Set')\n                .setDescription(`Balance logs will now be sent to ${channel}`)\n                .addFields(\n                    {\n                        name: 'üìã Configuration Details',\n                        value: `**Channel:** ${channel}\\n**Channel ID:** \\`${channel.id}\\`\\n**Server:** ${interaction.guild.name}`,\n                        inline: false\n                    },\n                    {\n                        name: 'üìù What gets logged',\n                        value: '‚Ä¢ Deposit confirmations\\n‚Ä¢ Balance additions\\n‚Ä¢ Deposit channel closures\\n‚Ä¢ Address generations',\n                        inline: false\n                    }\n                )\n                .setFooter({ text: `Configured by ${interaction.user.username}` })\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [successEmbed] });\n            \n            // Send test message to the log channel\n            try {\n                const testEmbed = new EmbedBuilder()\n                    .setColor('#0099ff')\n                    .setTitle('üîß Balance Log Channel Configured')\n                    .setDescription('This channel has been set up to receive balance logs from the casino bot.')\n                    .addFields(\n                        {\n                            name: '‚öôÔ∏è Configured by',\n                            value: `${interaction.user} (${interaction.user.username})`,\n                            inline: false\n                        }\n                    )\n                    .setTimestamp();\n                \n                await channel.send({ embeds: [testEmbed] });\n            } catch (channelError) {\n                console.log('Could not send test message to log channel:', channelError.message);\n            }\n            \n            console.log(`üìù Balance log channel set to ${channel.name} for server ${interaction.guild.name}`);\n            \n        } catch (error) {\n            console.error('Erreur setlogbal:', error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Error')\n                .setDescription('An error occurred while setting the log channel.')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};","size_bytes":4791},"commands/setloggamble.js":{"content":"const { SlashCommandBuilder, EmbedBuilder, PermissionFlagsBits, ChannelType } = require('discord.js');\nconst fs = require('fs');\nconst path = require('path');\n\nconst CONFIG_FILE = path.join(__dirname, '../data/log_config.json');\n\n// Ensure data directory exists\nconst dataDir = path.join(__dirname, '../data');\nif (!fs.existsSync(dataDir)) {\n    fs.mkdirSync(dataDir, { recursive: true });\n}\n\nfunction loadLogConfig() {\n    try {\n        if (fs.existsSync(CONFIG_FILE)) {\n            const data = fs.readFileSync(CONFIG_FILE, 'utf8');\n            return JSON.parse(data);\n        }\n    } catch (error) {\n        console.error('Error loading log config:', error.message);\n    }\n    return {};\n}\n\nfunction saveLogConfig(config) {\n    try {\n        fs.writeFileSync(CONFIG_FILE, JSON.stringify(config, null, 2));\n        console.log('‚úÖ Log config saved');\n    } catch (error) {\n        console.error('Error saving log config:', error.message);\n    }\n}\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('setloggamble')\n        .setDescription('Configure gambling log channel (Admin only)')\n        .addChannelOption(option =>\n            option.setName('channel')\n                .setDescription('Channel to send gambling logs to')\n                .setRequired(true)\n                .addChannelTypes(ChannelType.GuildText)\n        )\n        .setDefaultMemberPermissions(PermissionFlagsBits.Administrator),\n    \n    async execute(interaction) {\n        // Check if interaction is too old\n        const interactionAge = Date.now() - interaction.createdTimestamp;\n        if (interactionAge > 10 * 60 * 1000) {\n            console.log('Interaction trop ancienne, ignor√©e');\n            return;\n        }\n        \n        await interaction.deferReply({ ephemeral: true });\n        \n        try {\n            const channel = interaction.options.getChannel('channel');\n            const serverId = interaction.guild.id;\n            \n            // Load config\n            const config = loadLogConfig();\n            \n            if (!config[serverId]) {\n                config[serverId] = {};\n            }\n            \n            config[serverId].gamblingLogChannel = channel.id;\n            \n            // Save config\n            saveLogConfig(config);\n            \n            const successEmbed = new EmbedBuilder()\n                .setColor('#00ff00')\n                .setTitle('‚úÖ Gambling Log Channel Set')\n                .setDescription(`Gambling logs will now be sent to ${channel}`)\n                .addFields(\n                    {\n                        name: 'üìã Configuration Details',\n                        value: `**Channel:** ${channel}\\n**Channel ID:** \\`${channel.id}\\`\\n**Server:** ${interaction.guild.name}`,\n                        inline: false\n                    },\n                    {\n                        name: 'üé∞ What gets logged',\n                        value: '‚Ä¢ Blackjack games and results\\n‚Ä¢ Roulette spins and payouts\\n‚Ä¢ Big wins and losses\\n‚Ä¢ Suspicious gambling patterns',\n                        inline: false\n                    }\n                )\n                .setFooter({ text: `Configured by ${interaction.user.username}` })\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [successEmbed] });\n            \n            // Send test message to the log channel\n            try {\n                const testEmbed = new EmbedBuilder()\n                    .setColor('#9932cc')\n                    .setTitle('üé∞ Gambling Log Channel Configured')\n                    .setDescription('This channel has been set up to receive gambling logs from the casino bot.')\n                    .addFields(\n                        {\n                            name: '‚öôÔ∏è Configured by',\n                            value: `${interaction.user} (${interaction.user.username})`,\n                            inline: false\n                        }\n                    )\n                    .setTimestamp();\n                \n                await channel.send({ embeds: [testEmbed] });\n            } catch (channelError) {\n                console.log('Could not send test message to gambling log channel:', channelError.message);\n            }\n            \n            console.log(`üé∞ Gambling log channel set to ${channel.name} for server ${interaction.guild.name}`);\n            \n        } catch (error) {\n            console.error('Erreur setloggamble:', error);\n            \n            const errorEmbed = new EmbedBuilder()\n                .setColor('#ff0000')\n                .setTitle('‚ùå Error')\n                .setDescription('An error occurred while setting the gambling log channel.')\n                .setTimestamp();\n            \n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    }\n};","size_bytes":4842},"utils/logManager.js":{"content":"const fs = require('fs');\nconst path = require('path');\nconst { EmbedBuilder } = require('discord.js');\n\nconst CONFIG_FILE = path.join(__dirname, '../data/log_config.json');\n\nfunction loadLogConfig() {\n    try {\n        if (fs.existsSync(CONFIG_FILE)) {\n            const data = fs.readFileSync(CONFIG_FILE, 'utf8');\n            return JSON.parse(data);\n        }\n    } catch (error) {\n        console.error('Error loading log config:', error.message);\n    }\n    return {};\n}\n\n/**\n * Send balance log to configured channel\n * @param {Object} client - Discord client\n * @param {string} serverId - Server ID\n * @param {Object} logData - Log data\n */\nasync function sendBalanceLog(client, serverId, logData) {\n    try {\n        const config = loadLogConfig();\n        const channelId = config[serverId]?.balanceLogChannel;\n        \n        if (!channelId) {\n            console.log('No balance log channel configured for server:', serverId);\n            return;\n        }\n        \n        const channel = await client.channels.fetch(channelId);\n        if (!channel) {\n            console.log('Balance log channel not found:', channelId);\n            return;\n        }\n        \n        const embed = createBalanceLogEmbed(logData);\n        await channel.send({ embeds: [embed] });\n        \n    } catch (error) {\n        console.error('Error sending balance log:', error.message);\n    }\n}\n\n/**\n * Send gambling log to configured channel\n * @param {Object} client - Discord client\n * @param {string} serverId - Server ID\n * @param {Object} logData - Log data\n */\nasync function sendGamblingLog(client, serverId, logData) {\n    try {\n        const config = loadLogConfig();\n        const channelId = config[serverId]?.gamblingLogChannel;\n        \n        if (!channelId) {\n            console.log('No gambling log channel configured for server:', serverId);\n            return;\n        }\n        \n        const channel = await client.channels.fetch(channelId);\n        if (!channel) {\n            console.log('Gambling log channel not found:', channelId);\n            return;\n        }\n        \n        const embed = createGamblingLogEmbed(logData);\n        await channel.send({ embeds: [embed] });\n        \n    } catch (error) {\n        console.error('Error sending gambling log:', error.message);\n    }\n}\n\n/**\n * Create balance log embed\n * @param {Object} logData - Log data\n * @returns {EmbedBuilder} Embed\n */\nfunction createBalanceLogEmbed(logData) {\n    const { type, user, amount, address, details } = logData;\n    \n    let embed = new EmbedBuilder()\n        .setTimestamp();\n    \n    switch (type) {\n        case 'deposit':\n            embed\n                .setColor('#00ff00')\n                .setTitle('üí∞ Deposit Confirmed')\n                .setDescription(`User ${user.username} deposited **${amount} LTC**`)\n                .addFields(\n                    {\n                        name: 'üë§ User',\n                        value: `${user} (${user.id})`,\n                        inline: true\n                    },\n                    {\n                        name: 'üí∞ Amount',\n                        value: `${amount} LTC`,\n                        inline: true\n                    },\n                    {\n                        name: 'üìç Address',\n                        value: `\\`${address}\\``,\n                        inline: false\n                    }\n                );\n            break;\n            \n        case 'address_generated':\n            embed\n                .setColor('#0099ff')\n                .setTitle('üîë Deposit Address Generated')\n                .setDescription(`New deposit address created for ${user.username}`)\n                .addFields(\n                    {\n                        name: 'üë§ User',\n                        value: `${user} (${user.id})`,\n                        inline: true\n                    },\n                    {\n                        name: 'üìç Address',\n                        value: `\\`${address}\\``,\n                        inline: false\n                    }\n                );\n            break;\n            \n        case 'channel_closed':\n            embed\n                .setColor('#ffaa00')\n                .setTitle('üîí Deposit Channel Closed')\n                .setDescription(`Deposit channel closed for ${user.username}`)\n                .addFields(\n                    {\n                        name: 'üë§ User',\n                        value: `${user} (${user.id})`,\n                        inline: true\n                    },\n                    {\n                        name: '‚è±Ô∏è Reason',\n                        value: details || 'Auto-close after 20 minutes',\n                        inline: true\n                    }\n                );\n            break;\n    }\n    \n    return embed;\n}\n\n/**\n * Create gambling log embed\n * @param {Object} logData - Log data\n * @returns {EmbedBuilder} Embed\n */\nfunction createGamblingLogEmbed(logData) {\n    const { type, user, game, bet, result, payout, details } = logData;\n    \n    let embed = new EmbedBuilder()\n        .setTimestamp();\n    \n    switch (type) {\n        case 'blackjack':\n            embed\n                .setColor(result === 'win' ? '#00ff00' : result === 'lose' ? '#ff0000' : '#ffaa00')\n                .setTitle('üÉè Blackjack Game')\n                .setDescription(`${user.username} ${result === 'win' ? 'won' : result === 'lose' ? 'lost' : 'tied'} ${bet} LTC`)\n                .addFields(\n                    {\n                        name: 'üë§ Player',\n                        value: `${user} (${user.id})`,\n                        inline: true\n                    },\n                    {\n                        name: 'üí∞ Bet',\n                        value: `${bet} LTC`,\n                        inline: true\n                    },\n                    {\n                        name: 'üé∞ Result',\n                        value: result.toUpperCase(),\n                        inline: true\n                    },\n                    {\n                        name: 'üíµ Payout',\n                        value: `${payout || 0} LTC`,\n                        inline: true\n                    }\n                );\n            \n            if (details) {\n                embed.addFields({\n                    name: 'üìã Game Details',\n                    value: details,\n                    inline: false\n                });\n            }\n            break;\n            \n        case 'roulette':\n            embed\n                .setColor(result === 'win' ? '#00ff00' : '#ff0000')\n                .setTitle('üé∞ Roulette Spin')\n                .setDescription(`${user.username} ${result === 'win' ? 'won' : 'lost'} ${bet} LTC`)\n                .addFields(\n                    {\n                        name: 'üë§ Player',\n                        value: `${user} (${user.id})`,\n                        inline: true\n                    },\n                    {\n                        name: 'üí∞ Bet',\n                        value: `${bet} LTC`,\n                        inline: true\n                    },\n                    {\n                        name: 'üé∞ Result',\n                        value: result.toUpperCase(),\n                        inline: true\n                    },\n                    {\n                        name: 'üíµ Payout',\n                        value: `${payout || 0} LTC`,\n                        inline: true\n                    }\n                );\n            \n            if (details) {\n                embed.addFields({\n                    name: 'üìã Spin Details',\n                    value: details,\n                    inline: false\n                });\n            }\n            break;\n            \n        case 'big_win':\n            embed\n                .setColor('#ffd700')\n                .setTitle('üèÜ BIG WIN!')\n                .setDescription(`${user.username} hit a big win of **${payout} LTC**!`)\n                .addFields(\n                    {\n                        name: 'üë§ Winner',\n                        value: `${user} (${user.id})`,\n                        inline: true\n                    },\n                    {\n                        name: 'üéÆ Game',\n                        value: game.toUpperCase(),\n                        inline: true\n                    },\n                    {\n                        name: 'üí∞ Bet',\n                        value: `${bet} LTC`,\n                        inline: true\n                    },\n                    {\n                        name: 'üèÜ Win Amount',\n                        value: `${payout} LTC`,\n                        inline: true\n                    }\n                );\n            break;\n    }\n    \n    return embed;\n}\n\nmodule.exports = {\n    sendBalanceLog,\n    sendGamblingLog,\n    createBalanceLogEmbed,\n    createGamblingLogEmbed\n};","size_bytes":8851}},"version":1}